name: 'Release to pub.dev and GitHub'

on:
  # Manual trigger - users can manually trigger this workflow
  workflow_dispatch:
    inputs:
      increment:
        description: 'The version to be released (e.g., 6.5.3 for standard, 6.5.2-sp.452143 for special)'
        required: true
        type: string
      dry-run:
        description: 'Dry-run mode (will not create real Tag/Release/publish to pub.dev)'
        required: false
        type: boolean
        default: true

  # Callable workflow - can be called by other workflows
  workflow_call:
    inputs:
      increment:
        description: 'The version to be released (e.g., 6.5.3 for standard, 6.5.2-sp.452143 for special)'
        required: false
        type: string
      dry-run:
        description: 'Dry-run mode (will not create real Tag/Release/publish to pub.dev)'
        required: false
        type: boolean
        default: true
    outputs:
      increment:
        description: 'The version that was released'
        value: ${{ jobs.release.outputs.increment }}
      release_type:
        description: 'The type of release (standard or special)'
        value: ${{ jobs.release.outputs.release_type }}
      release_success:
        description: 'Whether the release was successful'
        value: ${{ jobs.release.result == 'success' }}
      documentation_generated:
        description: 'Whether documentation was generated'
        value: ${{ jobs.attach_documentation.result == 'success' }}
      documentation_version:
        description: 'The documentation version'
        value: ${{ jobs.attach_documentation.outputs.doc_version }}

  # Also allow automatic trigger from PR merge with specific labels
  pull_request:
    types:
      - closed

jobs:
  # Main release job - handles manual, callable, and automatic releases
  release:
    if: ${{ github.event_name == 'workflow_dispatch' ||
            github.event_name == 'workflow_call' ||
            (github.event_name == 'pull_request' &&
             github.event.pull_request.merged == true &&
             ((github.event.pull_request.base.ref == 'main' && contains(github.event.pull_request.labels.*.name, 'ci:prepare_release')) ||
              contains(github.event.pull_request.labels.*.name, 'ci:ready_release_special'))) }}
    outputs:
      increment: ${{ steps.version_check.outputs.version }}
      release_type: ${{ steps.version_check.outputs.release_type }}
      is_prerelease: ${{ steps.version_check.outputs.is_prerelease }}
      dry-run: ${{ steps.version_check.outputs.dry-run }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository üõéÔ∏è
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get tags
        run: git fetch --tags origin

      - name: Get version information ‚ÑπÔ∏è
        id: version_check
        run: |
          set -eo pipefail

          # Get dry-run mode
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            DRY_RUN="${{ github.event.inputs.dry-run }}"
          elif [ "${{ github.event_name }}" = "workflow_call" ]; then
            DRY_RUN="${{ inputs.dry-run }}"
          else
            DRY_RUN="false" # PR triggers are always production mode
          fi

          echo "Dry-run mode: $DRY_RUN"
          echo "dry-run=$DRY_RUN" >> $GITHUB_OUTPUT

          # Get version from inputs (for workflow_dispatch and workflow_call) or pubspec.yaml (for PR)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            RELEASE_VERSION="${{ github.event.inputs.increment }}"
          elif [ "${{ github.event_name }}" = "workflow_call" ]; then
            RELEASE_VERSION="${{ inputs.increment }}"
          else
            RELEASE_VERSION=$(grep 'version: ' pubspec.yaml | sed -e 's,.*: \(.*\),\1,')
          fi

          # Determine release type based on PR labels or version format
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            if [ "${{ contains(github.event.pull_request.labels.*.name, 'ci:prepare_release') }}" = "true" ]; then
              RELEASE_TYPE="standard"
              IS_PRERELEASE="false"
              echo "üöÄ PR triggered standard release: $RELEASE_VERSION"
            elif [ "${{ contains(github.event.pull_request.labels.*.name, 'ci:ready_release_special') }}" = "true" ]; then
              RELEASE_TYPE="special"
              IS_PRERELEASE="true"
              echo "üîß PR triggered special release: $RELEASE_VERSION"
            fi
          else
            # Auto-detect release type based on version format for manual/callable triggers
            # Only clean semantic versions (MAJOR.MINOR.PATCH) are considered standard
            # Any version with suffix (pre-release, build metadata, etc.) is special
            if [[ $RELEASE_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              # Clean semantic version: 6.5.0 (no suffix)
              RELEASE_TYPE="standard"
              IS_PRERELEASE="false"
              echo "üöÄ Detected standard release version: $RELEASE_VERSION"
            else
              # Special version: any version with suffix
              # Examples: 6.5.0-beta.1, 6.5.0-rc.2, 6.5.2-sp.452143, 6.5.0+build.123
              RELEASE_TYPE="special"
              IS_PRERELEASE="true"
              echo "üîß Detected special release version: $RELEASE_VERSION"
            fi
          fi

          echo "Release version: $RELEASE_VERSION"
          echo "Release type: $RELEASE_TYPE" 
          echo "Is prerelease: $IS_PRERELEASE"

          echo "version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT

      - name: Install release tools
        run: |
          npm install -g release-it
          npm install -g release-it/bumper
          npm install -g release-it/conventional-changelog

      - name: Configure git
        run: |
          git config user.name "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"

      - name: Create release commit and tag (triggered by manual/callable)
        if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' }}
        run: |
          # Use auto-detected release type
          RELEASE_TYPE="${{ steps.version_check.outputs.release_type }}"
          IS_PRERELEASE="${{ steps.version_check.outputs.is_prerelease }}"
          DRY_RUN="${{ steps.version_check.outputs.dry-run }}"

          # Build release-it command
          RELEASE_IT_CMD="release-it ${{ steps.version_check.outputs.version }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "[DRY-RUN MODE] No commits/tags/releases will be created"
            RELEASE_IT_CMD="$RELEASE_IT_CMD --dry-run"
          fi

          if [ "$RELEASE_TYPE" = "special" ]; then
            echo "Creating special release (only Git tag, no GitHub release)..."
            # Use git.commit to let release-it handle the commit
            $RELEASE_IT_CMD \
              --git.commit \
              --'git.commitMessage="chore: release ${{ steps.version_check.outputs.version }}"' \
              --git.tag \
              --'git.tagName="${{ steps.version_check.outputs.version }}"' \
              --'git.tagAnnotation="Release ${{ steps.version_check.outputs.version }}"' \
              --git.push \
              --no-github.release \
              --no-github.web \
              --ci
          else
            echo "üöÄ Creating standard release (with GitHub release)..."
            if [ "$IS_PRERELEASE" = "true" ]; then
              echo "üîñ This is a pre-release version"
            fi
            # Use git.commit to let release-it handle the commit
            $RELEASE_IT_CMD \
              --git.commit \
              --'git.commitMessage="chore: release ${{ steps.version_check.outputs.version }}"' \
              --git.tag \
              --'git.tagName="${{ steps.version_check.outputs.version }}"' \
              --'git.tagAnnotation="Release ${{ steps.version_check.outputs.version }}"' \
              --git.push \
              --github.release \
              --no-github.web \
              --ci
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create release commit and tag (triggered by PR merge)
        if: github.event_name == 'pull_request'
        run: |
          RELEASE_TYPE="${{ steps.version_check.outputs.release_type }}"
          RELEASE_VERSION="${{ steps.version_check.outputs.version }}"
          DRY_RUN="${{ steps.version_check.outputs.dry-run }}"

          # PR triggers always run in production mode (dry-run=false)
          if [ "$DRY_RUN" = "true" ]; then
            echo "Warning: PR triggers ignore dry-run mode"
          fi

          if [ "$RELEASE_TYPE" = "special" ]; then
            echo "Creating special release from PR (only Git tag, no GitHub release)..."
            release-it $RELEASE_VERSION \
              --no-git.commit \
              --git.tag \
              --'git.tagName="${version}"' \
              --'git.tagAnnotation="Release ${version}"' \
              --git.push \
              --no-github.release \
              --no-github.web \
              --ci
          else
            echo "üöÄ Creating standard release from PR (with GitHub release)..."
            release-it $RELEASE_VERSION \
              --no-git.commit \
              --git.tag \
              --'git.tagName="${version}"' \
              --'git.tagAnnotation="Release ${version}"' \
              --git.push \
              --github.release \
              --no-github.web \
              --ci
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Dart for pub publish
        if: ${{ steps.version_check.outputs.release_type == 'standard' }}
        uses: dart-lang/setup-dart@v1

      - name: Publish to pub.dev (dry-run check)
        if: ${{ steps.version_check.outputs.release_type == 'standard' && steps.version_check.outputs.dry-run == 'true' }}
        run: |
          echo "[DRY-RUN MODE] Running pub publish dry-run"
          dart pub get
          dart pub publish --dry-run
      
      - name: Publish to pub.dev (real)
        if: ${{ steps.version_check.outputs.release_type == 'standard' && steps.version_check.outputs.dry-run == 'false' }}
        uses: k-paxian/dart-package-publisher@master
        with:
          accessToken: ${{ secrets.OAUTH_ACCESS_TOKEN }}
          refreshToken: ${{ secrets.OAUTH_REFRESH_TOKEN }}
          force: false
          skipTests: true

  # Generate and attach documentation (only for standard releases in production mode)
  attach_documentation:
    name: 'Generate and Attach Documentation'
    runs-on: ubuntu-latest
    needs: release
    if: ${{ needs.release.result == 'success' &&
            needs.release.outputs.release_type == 'standard' &&
            needs.release.outputs.dry-run == 'false' }}
    outputs:
      doc_version: ${{ steps.doc_version.outputs.version }}
    steps:
      - name: Checkout repository üõéÔ∏è
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      # Get version information from release job output
      - name: Get version for documentation
        id: doc_version
        run: |
          set -eo pipefail

          # Get version from release job output
          VERSION="${{ needs.release.outputs.increment }}"
          echo "Documentation version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: true

      - name: Install dependencies
        run: |
          dart pub get

      - name: Generate DartDoc üìñ
        run: |
          # Generate DartDoc
          dart doc
          # Create a zip file of the DartDoc output
          zip -r agora_rtc_engine_docs.zip doc

      - name: Upload DartDoc Artifact ‚¨ÜÔ∏è
        uses: actions/upload-artifact@v4
        with:
          name: agora_rtc_engine_docs.zip
          path: agora_rtc_engine_docs.zip

      - name: Upload DartDoc Archive to GitHub release ‚¨ÜÔ∏è
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: agora_rtc_engine_docs.zip
          asset_name: agora_rtc_engine_docs.zip
          tag: ${{ steps.doc_version.outputs.version }}
          overwrite: true

  # Post-release verification
  verify_release:
    name: 'Verify Release'
    runs-on: ubuntu-latest
    needs: [release, attach_documentation]
    if: always() && (needs.release.result == 'success' || needs.attach_documentation.result == 'success')
    steps:
      - name: Checkout repository üõéÔ∏è
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify release details
        run: |
          set -eo pipefail

          RELEASE_VERSION="${{ needs.release.outputs.increment }}"
          RELEASE_TYPE="${{ needs.release.outputs.release_type }}"
          IS_PRERELEASE="${{ needs.release.outputs.is_prerelease }}"

          echo "üîç Verifying release: $RELEASE_VERSION"
          echo "üìã Release Summary:"
          echo "  ‚Ä¢ Version: $RELEASE_VERSION"
          echo "  ‚Ä¢ Type: $RELEASE_TYPE"
          echo "  ‚Ä¢ Pre-release: $IS_PRERELEASE"
          echo "  ‚Ä¢ Branch: ${{ github.ref_name || 'main' }}"
          echo "  ‚Ä¢ Triggered by: ${{ (github.event_name == 'workflow_dispatch' && 'Manual trigger') || (github.event_name == 'workflow_call' && 'Workflow call') || 'PR merge' }}"

          if [ "$RELEASE_TYPE" = "standard" ]; then
            if [ "$IS_PRERELEASE" = "true" ]; then
              echo "  ‚Ä¢ Status: Pre-release version published"
            else
              echo "  ‚Ä¢ Status: Standard version published"
            fi
            echo "  ‚Ä¢ GitHub Release: ‚úÖ Created"
            echo "  ‚Ä¢ Pub.dev: ‚úÖ Published"
            echo "  ‚Ä¢ Documentation: ‚úÖ Generated and attached"
          else
            echo "  ‚Ä¢ Status: Special version (internal use only)"
            echo "  ‚Ä¢ GitHub Release: ‚ùå Not created (internal version)"
            echo "  ‚Ä¢ Pub.dev: ‚ùå Not published (internal version)"
            echo "  ‚Ä¢ Documentation: ‚ùå Not generated (internal version)"
          fi

          echo ""
          echo "üéâ Release workflow completed successfully!"

      - name: Notify on failure
        if: needs.release.result == 'failure'
        run: |
          echo "‚ùå Release failed!"
          echo "Please check the logs and try again."
          exit 1