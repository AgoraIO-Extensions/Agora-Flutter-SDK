/// GENERATED BY terra, DO NOT MODIFY BY HAND.

// ignore_for_file: public_member_api_docs, unused_local_variable, unused_import, annotate_overrides

import 'package:agora_rtc_engine/src/binding_forward_export.dart';
import 'package:agora_rtc_engine/src/binding/impl_forward_export.dart';
import 'package:iris_method_channel/iris_method_channel.dart';

class VideoDeviceManagerImpl implements VideoDeviceManager {
  VideoDeviceManagerImpl(this.irisMethodChannel);

  @protected
  final IrisMethodChannel irisMethodChannel;

  @protected
  Map<String, dynamic> createParams(Map<String, dynamic> param) {
    return param;
  }

  @protected
  bool get isOverrideClassName => false;

  @protected
  String get className => 'VideoDeviceManager';

  @override
  Future<List<VideoDeviceInfo>> enumerateVideoDevices() async {
    final apiType =
        '${isOverrideClassName ? className : 'VideoDeviceManager'}_enumerateVideoDevices';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as List<VideoDeviceInfo>;
  }

  @override
  Future<void> setDevice(String deviceIdUTF8) async {
    final apiType =
        '${isOverrideClassName ? className : 'VideoDeviceManager'}_setDevice_4ad5f6e';
    final param = createParams({'deviceIdUTF8': deviceIdUTF8});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<String> getDevice() async {
    final apiType =
        '${isOverrideClassName ? className : 'VideoDeviceManager'}_getDevice_73b9872';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final getDeviceJson = VideoDeviceManagerGetDeviceJson.fromJson(rm);
    return getDeviceJson.deviceIdUTF8;
  }

  @override
  Future<int> numberOfCapabilities(String deviceIdUTF8) async {
    final apiType =
        '${isOverrideClassName ? className : 'VideoDeviceManager'}_numberOfCapabilities_3a2037f';
    final param = createParams({'deviceIdUTF8': deviceIdUTF8});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<VideoFormat> getCapability(
      {required String deviceIdUTF8,
      required int deviceCapabilityNumber}) async {
    final apiType =
        '${isOverrideClassName ? className : 'VideoDeviceManager'}_getCapability_ddeefdd';
    final param = createParams({
      'deviceIdUTF8': deviceIdUTF8,
      'deviceCapabilityNumber': deviceCapabilityNumber
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final getCapabilityJson = VideoDeviceManagerGetCapabilityJson.fromJson(rm);
    return getCapabilityJson.capability;
  }

  @override
  Future<void> startDeviceTest(int hwnd) async {
    final apiType =
        '${isOverrideClassName ? className : 'VideoDeviceManager'}_startDeviceTest_a55f55f';
    final param = createParams({'hwnd': hwnd});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopDeviceTest() async {
    final apiType =
        '${isOverrideClassName ? className : 'VideoDeviceManager'}_stopDeviceTest';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> release() async {
    final apiType =
        '${isOverrideClassName ? className : 'VideoDeviceManager'}_release';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }
}

class RtcEngineImpl implements RtcEngine {
  RtcEngineImpl(this.irisMethodChannel);

  @protected
  final IrisMethodChannel irisMethodChannel;

  @protected
  Map<String, dynamic> createParams(Map<String, dynamic> param) {
    return param;
  }

  @protected
  bool get isOverrideClassName => false;

  @protected
  String get className => 'RtcEngine';

  @override
  Future<void> initialize(RtcEngineContext context) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_initialize_0320339';
    final param = createParams({'context': context.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(context.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<SDKBuildInfo> getVersion() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getVersion_915cb25';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as SDKBuildInfo;
  }

  @override
  Future<String> getErrorDescription(int code) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getErrorDescription_46f8ab7';
    final param = createParams({'code': code});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as String;
  }

  @override
  Future<List<CodecCapInfo>> queryCodecCapability(int size) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_queryCodecCapability_ddf4f31';
    final param = createParams({'size': size});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final queryCodecCapabilityJson =
        RtcEngineQueryCodecCapabilityJson.fromJson(rm);
    return queryCodecCapabilityJson.codecInfo;
  }

  @override
  Future<int> queryDeviceScore() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_queryDeviceScore';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> preloadChannel(
      {required String token,
      required String channelId,
      required int uid}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_preloadChannel_a0779eb';
    final param =
        createParams({'token': token, 'channelId': channelId, 'uid': uid});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> preloadChannelWithUserAccount(
      {required String token,
      required String channelId,
      required String userAccount}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_preloadChannelWithUserAccount_0e4f59e';
    final param = createParams(
        {'token': token, 'channelId': channelId, 'userAccount': userAccount});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> updatePreloadChannelToken(String token) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_updatePreloadChannelToken_3a2037f';
    final param = createParams({'token': token});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> joinChannel(
      {required String token,
      required String channelId,
      required int uid,
      required ChannelMediaOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_joinChannel_cdbb747';
    final param = createParams({
      'token': token,
      'channelId': channelId,
      'uid': uid,
      'options': options.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> updateChannelMediaOptions(ChannelMediaOptions options) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_updateChannelMediaOptions_7bfc1d7';
    final param = createParams({'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> leaveChannel({LeaveChannelOptions? options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_leaveChannel_2c0e3aa';
    final param = createParams({'options': options?.toJson()});
    final List<Uint8List> buffers = [];
    if (options != null) {
      buffers.addAll(options.collectBufferList());
    }
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> renewToken(String token) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_renewToken_3a2037f';
    final param = createParams({'token': token});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setChannelProfile(ChannelProfileType profile) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setChannelProfile_a78fa4f';
    final param = createParams({'profile': profile.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setClientRole(
      {required ClientRoleType role, ClientRoleOptions? options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setClientRole_b46cc48';
    final param =
        createParams({'role': role.value(), 'options': options?.toJson()});
    final List<Uint8List> buffers = [];
    if (options != null) {
      buffers.addAll(options.collectBufferList());
    }
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startEchoTest(EchoTestConfiguration config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startEchoTest_16140d7';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopEchoTest() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopEchoTest';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableMultiCamera(
      {required bool enabled,
      required CameraCapturerConfiguration config}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableMultiCamera_bffe023';
    final param = createParams({'enabled': enabled, 'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableVideo() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableVideo';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> disableVideo() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_disableVideo';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startPreview(
      {VideoSourceType sourceType =
          VideoSourceType.videoSourceCameraPrimary}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startPreview_4fd718e';
    final param = createParams({'sourceType': sourceType.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopPreview(
      {VideoSourceType sourceType =
          VideoSourceType.videoSourceCameraPrimary}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopPreview_4fd718e';
    final param = createParams({'sourceType': sourceType.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startLastmileProbeTest(LastmileProbeConfig config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startLastmileProbeTest_c4de423';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopLastmileProbeTest() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopLastmileProbeTest';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setVideoEncoderConfiguration(
      VideoEncoderConfiguration config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setVideoEncoderConfiguration_89677d8';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setBeautyEffectOptions(
      {required bool enabled,
      required BeautyOptions options,
      MediaSourceType type = MediaSourceType.primaryCameraSource}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setBeautyEffectOptions_e7635d1';
    final param = createParams({
      'enabled': enabled,
      'options': options.toJson(),
      'type': type.value()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLowlightEnhanceOptions(
      {required bool enabled,
      required LowlightEnhanceOptions options,
      MediaSourceType type = MediaSourceType.primaryCameraSource}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLowlightEnhanceOptions_4f9f013';
    final param = createParams({
      'enabled': enabled,
      'options': options.toJson(),
      'type': type.value()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setVideoDenoiserOptions(
      {required bool enabled,
      required VideoDenoiserOptions options,
      MediaSourceType type = MediaSourceType.primaryCameraSource}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setVideoDenoiserOptions_4e9fccc';
    final param = createParams({
      'enabled': enabled,
      'options': options.toJson(),
      'type': type.value()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setColorEnhanceOptions(
      {required bool enabled,
      required ColorEnhanceOptions options,
      MediaSourceType type = MediaSourceType.primaryCameraSource}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setColorEnhanceOptions_ecae2b3';
    final param = createParams({
      'enabled': enabled,
      'options': options.toJson(),
      'type': type.value()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableVirtualBackground(
      {required bool enabled,
      required VirtualBackgroundSource backgroundSource,
      required SegmentationProperty segproperty,
      MediaSourceType type = MediaSourceType.primaryCameraSource}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableVirtualBackground_6dd8ee4';
    final param = createParams({
      'enabled': enabled,
      'backgroundSource': backgroundSource.toJson(),
      'segproperty': segproperty.toJson(),
      'type': type.value()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(backgroundSource.collectBufferList());
    buffers.addAll(segproperty.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setupRemoteVideo(VideoCanvas canvas) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setupRemoteVideo_acc9c38';
    final param = createParams({'canvas': canvas.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(canvas.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setupLocalVideo(VideoCanvas canvas) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setupLocalVideo_acc9c38';
    final param = createParams({'canvas': canvas.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(canvas.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setVideoScenario(
      VideoApplicationScenarioType scenarioType) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setVideoScenario_c02cd1c';
    final param = createParams({'scenarioType': scenarioType.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setVideoQoEPreference(
      VideoQoePreferenceType qoePreference) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setVideoQoEPreference_c4a3d9f';
    final param = createParams({'qoePreference': qoePreference.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableAudio() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableAudio';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> disableAudio() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_disableAudio';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAudioProfile(
      {required AudioProfileType profile,
      AudioScenarioType scenario =
          AudioScenarioType.audioScenarioDefault}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAudioProfile_d944543';
    final param = createParams(
        {'profile': profile.value(), 'scenario': scenario.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAudioScenario(AudioScenarioType scenario) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAudioScenario_c36f5c1';
    final param = createParams({'scenario': scenario.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableLocalAudio(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableLocalAudio_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> muteLocalAudioStream(bool mute) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_muteLocalAudioStream_5039d15';
    final param = createParams({'mute': mute});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> muteAllRemoteAudioStreams(bool mute) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_muteAllRemoteAudioStreams_5039d15';
    final param = createParams({'mute': mute});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setDefaultMuteAllRemoteAudioStreams(bool mute) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setDefaultMuteAllRemoteAudioStreams_5039d15';
    final param = createParams({'mute': mute});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> muteRemoteAudioStream(
      {required int uid, required bool mute}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_muteRemoteAudioStream_dbdc15a';
    final param = createParams({'uid': uid, 'mute': mute});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> muteLocalVideoStream(bool mute) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_muteLocalVideoStream_5039d15';
    final param = createParams({'mute': mute});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableLocalVideo(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableLocalVideo_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> muteAllRemoteVideoStreams(bool mute) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_muteAllRemoteVideoStreams_5039d15';
    final param = createParams({'mute': mute});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setDefaultMuteAllRemoteVideoStreams(bool mute) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setDefaultMuteAllRemoteVideoStreams_5039d15';
    final param = createParams({'mute': mute});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setRemoteDefaultVideoStreamType(
      VideoStreamType streamType) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRemoteDefaultVideoStreamType_5a94eb0';
    final param = createParams({'streamType': streamType.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> muteRemoteVideoStream(
      {required int uid, required bool mute}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_muteRemoteVideoStream_dbdc15a';
    final param = createParams({'uid': uid, 'mute': mute});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setRemoteVideoStreamType(
      {required int uid, required VideoStreamType streamType}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRemoteVideoStreamType_9e6406e';
    final param = createParams({'uid': uid, 'streamType': streamType.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setRemoteVideoSubscriptionOptions(
      {required int uid, required VideoSubscriptionOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRemoteVideoSubscriptionOptions_0b6b258';
    final param = createParams({'uid': uid, 'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setSubscribeAudioBlocklist(
      {required List<int> uidList, required int uidNumber}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setSubscribeAudioBlocklist_2d31fd5';
    final param = createParams({'uidList': uidList, 'uidNumber': uidNumber});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setSubscribeAudioAllowlist(
      {required List<int> uidList, required int uidNumber}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setSubscribeAudioAllowlist_2d31fd5';
    final param = createParams({'uidList': uidList, 'uidNumber': uidNumber});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setSubscribeVideoBlocklist(
      {required List<int> uidList, required int uidNumber}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setSubscribeVideoBlocklist_2d31fd5';
    final param = createParams({'uidList': uidList, 'uidNumber': uidNumber});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setSubscribeVideoAllowlist(
      {required List<int> uidList, required int uidNumber}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setSubscribeVideoAllowlist_2d31fd5';
    final param = createParams({'uidList': uidList, 'uidNumber': uidNumber});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableAudioVolumeIndication(
      {required int interval,
      required int smooth,
      required bool reportVad}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableAudioVolumeIndication_39794a0';
    final param = createParams(
        {'interval': interval, 'smooth': smooth, 'reportVad': reportVad});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startAudioRecording(AudioRecordingConfiguration config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startAudioRecording_e32bb3b';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  void registerAudioEncodedFrameObserver(
      {required AudioEncodedFrameObserverConfig config,
      required AudioEncodedFrameObserver observer}) {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_registerAudioEncodedFrameObserver_ed4a177';
// final param = createParams({
//   'config': config.toJson(),'observer': observer
// });
// final List<Uint8List> buffers = [];
// buffers.addAll(config.collectBufferList());
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:buffers));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// if (result < 0) { throw AgoraRtcException(code: result); }
    throw UnimplementedError(
        'Unimplement for registerAudioEncodedFrameObserver');
  }

  @override
  Future<void> stopAudioRecording() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopAudioRecording';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<MediaPlayer?> createMediaPlayer() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_createMediaPlayer';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as MediaPlayer;
  }

  @override
  Future<void> destroyMediaPlayer(MediaPlayer mediaPlayer) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_destroyMediaPlayer_328a49b';
    final param = createParams({'media_player': mediaPlayer});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<MediaRecorder?> createMediaRecorder(RecorderStreamInfo info) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_createMediaRecorder_f779617';
    final param = createParams({'info': info.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(info.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as MediaRecorder;
  }

  @override
  Future<void> destroyMediaRecorder(MediaRecorder mediaRecorder) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_destroyMediaRecorder_95cdef5';
    final param = createParams({'mediaRecorder': mediaRecorder});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startAudioMixing(
      {required String filePath,
      required bool loopback,
      required int cycle,
      int startPos = 0}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startAudioMixing_1ee1b1e';
    final param = createParams({
      'filePath': filePath,
      'loopback': loopback,
      'cycle': cycle,
      'startPos': startPos
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopAudioMixing() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopAudioMixing';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> pauseAudioMixing() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_pauseAudioMixing';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> resumeAudioMixing() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_resumeAudioMixing';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> selectAudioTrack(int index) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_selectAudioTrack_46f8ab7';
    final param = createParams({'index': index});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getAudioTrackCount() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getAudioTrackCount';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> adjustAudioMixingVolume(int volume) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_adjustAudioMixingVolume_46f8ab7';
    final param = createParams({'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> adjustAudioMixingPublishVolume(int volume) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_adjustAudioMixingPublishVolume_46f8ab7';
    final param = createParams({'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getAudioMixingPublishVolume() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getAudioMixingPublishVolume';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> adjustAudioMixingPlayoutVolume(int volume) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_adjustAudioMixingPlayoutVolume_46f8ab7';
    final param = createParams({'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getAudioMixingPlayoutVolume() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getAudioMixingPlayoutVolume';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<int> getAudioMixingDuration() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getAudioMixingDuration';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<int> getAudioMixingCurrentPosition() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getAudioMixingCurrentPosition';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> setAudioMixingPosition(int pos) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAudioMixingPosition_46f8ab7';
    final param = createParams({'pos': pos});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAudioMixingDualMonoMode(AudioMixingDualMonoMode mode) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAudioMixingDualMonoMode_38a5515';
    final param = createParams({'mode': mode.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAudioMixingPitch(int pitch) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAudioMixingPitch_46f8ab7';
    final param = createParams({'pitch': pitch});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAudioMixingPlaybackSpeed(int speed) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAudioMixingPlaybackSpeed_46f8ab7';
    final param = createParams({'speed': speed});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getEffectsVolume() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getEffectsVolume';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> setEffectsVolume(int volume) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setEffectsVolume_46f8ab7';
    final param = createParams({'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> preloadEffect(
      {required int soundId,
      required String filePath,
      int startPos = 0}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_preloadEffect_282ba8c';
    final param = createParams(
        {'soundId': soundId, 'filePath': filePath, 'startPos': startPos});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> playEffect(
      {required int soundId,
      required String filePath,
      required int loopCount,
      required double pitch,
      required double pan,
      required int gain,
      bool publish = false,
      int startPos = 0}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_playEffect_531a783';
    final param = createParams({
      'soundId': soundId,
      'filePath': filePath,
      'loopCount': loopCount,
      'pitch': pitch,
      'pan': pan,
      'gain': gain,
      'publish': publish,
      'startPos': startPos
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> playAllEffects(
      {required int loopCount,
      required double pitch,
      required double pan,
      required int gain,
      bool publish = false}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_playAllEffects_20d7df2';
    final param = createParams({
      'loopCount': loopCount,
      'pitch': pitch,
      'pan': pan,
      'gain': gain,
      'publish': publish
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getVolumeOfEffect(int soundId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getVolumeOfEffect_46f8ab7';
    final param = createParams({'soundId': soundId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> setVolumeOfEffect(
      {required int soundId, required int volume}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setVolumeOfEffect_4e92b3c';
    final param = createParams({'soundId': soundId, 'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> pauseEffect(int soundId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_pauseEffect_46f8ab7';
    final param = createParams({'soundId': soundId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> pauseAllEffects() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_pauseAllEffects';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> resumeEffect(int soundId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_resumeEffect_46f8ab7';
    final param = createParams({'soundId': soundId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> resumeAllEffects() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_resumeAllEffects';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopEffect(int soundId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopEffect_46f8ab7';
    final param = createParams({'soundId': soundId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopAllEffects() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopAllEffects';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> unloadEffect(int soundId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_unloadEffect_46f8ab7';
    final param = createParams({'soundId': soundId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> unloadAllEffects() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_unloadAllEffects';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getEffectDuration(String filePath) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getEffectDuration_3a2037f';
    final param = createParams({'filePath': filePath});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> setEffectPosition(
      {required int soundId, required int pos}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setEffectPosition_4e92b3c';
    final param = createParams({'soundId': soundId, 'pos': pos});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getEffectCurrentPosition(int soundId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getEffectCurrentPosition_46f8ab7';
    final param = createParams({'soundId': soundId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> enableSoundPositionIndication(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableSoundPositionIndication_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setRemoteVoicePosition(
      {required int uid, required double pan, required double gain}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRemoteVoicePosition_250b42d';
    final param = createParams({'uid': uid, 'pan': pan, 'gain': gain});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableSpatialAudio(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableSpatialAudio_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setRemoteUserSpatialAudioParams(
      {required int uid, required SpatialAudioParams params}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRemoteUserSpatialAudioParams_65a7855';
    final param = createParams({'uid': uid, 'params': params.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(params.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setVoiceBeautifierPreset(VoiceBeautifierPreset preset) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setVoiceBeautifierPreset_4dd6319';
    final param = createParams({'preset': preset.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAudioEffectPreset(AudioEffectPreset preset) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAudioEffectPreset_92ea92c';
    final param = createParams({'preset': preset.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setVoiceConversionPreset(VoiceConversionPreset preset) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setVoiceConversionPreset_d14ee73';
    final param = createParams({'preset': preset.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAudioEffectParameters(
      {required AudioEffectPreset preset,
      required int param1,
      required int param2}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAudioEffectParameters_73bc670';
    final param = createParams(
        {'preset': preset.value(), 'param1': param1, 'param2': param2});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setVoiceBeautifierParameters(
      {required VoiceBeautifierPreset preset,
      required int param1,
      required int param2}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setVoiceBeautifierParameters_f3cf745';
    final param = createParams(
        {'preset': preset.value(), 'param1': param1, 'param2': param2});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setVoiceConversionParameters(
      {required VoiceConversionPreset preset,
      required int param1,
      required int param2}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setVoiceConversionParameters_2f5022e';
    final param = createParams(
        {'preset': preset.value(), 'param1': param1, 'param2': param2});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLocalVoicePitch(double pitch) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLocalVoicePitch_bdb36bb';
    final param = createParams({'pitch': pitch});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLocalVoiceFormant(double formantRatio) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLocalVoiceFormant_bdb36bb';
    final param = createParams({'formantRatio': formantRatio});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLocalVoiceEqualization(
      {required AudioEqualizationBandFrequency bandFrequency,
      required int bandGain}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLocalVoiceEqualization_d14012c';
    final param = createParams(
        {'bandFrequency': bandFrequency.value(), 'bandGain': bandGain});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLocalVoiceReverb(
      {required AudioReverbType reverbKey, required int value}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLocalVoiceReverb_29c2013';
    final param =
        createParams({'reverbKey': reverbKey.value(), 'value': value});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setHeadphoneEQPreset(HeadphoneEqualizerPreset preset) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setHeadphoneEQPreset_b679644';
    final param = createParams({'preset': preset.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setHeadphoneEQParameters(
      {required int lowGain, required int highGain}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setHeadphoneEQParameters_4e92b3c';
    final param = createParams({'lowGain': lowGain, 'highGain': highGain});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLogFile(String filePath) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLogFile_3a2037f';
    final param = createParams({'filePath': filePath});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLogFilter(LogFilterType filter) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLogFilter_2626ac7';
    final param = createParams({'filter': filter.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLogLevel(LogLevel level) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLogLevel_f125d83';
    final param = createParams({'level': level.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLogFileSize(int fileSizeInKBytes) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLogFileSize_2626ac7';
    final param = createParams({'fileSizeInKBytes': fileSizeInKBytes});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<String> uploadLogFile() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_uploadLogFile_66d4ecd';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final uploadLogFileJson = RtcEngineUploadLogFileJson.fromJson(rm);
    return uploadLogFileJson.requestId;
  }

  @override
  Future<void> writeLog({required LogLevel level, required String fmt}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_writeLog_62889f6';
    final param = createParams({'level': level.value(), 'fmt': fmt});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLocalRenderMode(
      {required RenderModeType renderMode,
      VideoMirrorModeType mirrorMode =
          VideoMirrorModeType.videoMirrorModeAuto}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLocalRenderMode_cfb201b';
    final param = createParams(
        {'renderMode': renderMode.value(), 'mirrorMode': mirrorMode.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setRemoteRenderMode(
      {required int uid,
      required RenderModeType renderMode,
      required VideoMirrorModeType mirrorMode}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRemoteRenderMode_6771ce0';
    final param = createParams({
      'uid': uid,
      'renderMode': renderMode.value(),
      'mirrorMode': mirrorMode.value()
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLocalVideoMirrorMode(VideoMirrorModeType mirrorMode) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLocalVideoMirrorMode_b8a6c69';
    final param = createParams({'mirrorMode': mirrorMode.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableDualStreamMode(
      {required bool enabled, SimulcastStreamConfig? streamConfig}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableDualStreamMode_9822d8a';
    final param = createParams(
        {'enabled': enabled, 'streamConfig': streamConfig?.toJson()});
    final List<Uint8List> buffers = [];
    if (streamConfig != null) {
      buffers.addAll(streamConfig.collectBufferList());
    }
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setDualStreamMode(
      {required SimulcastStreamMode mode,
      SimulcastStreamConfig? streamConfig}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setDualStreamMode_b3a4f6c';
    final param = createParams(
        {'mode': mode.value(), 'streamConfig': streamConfig?.toJson()});
    final List<Uint8List> buffers = [];
    if (streamConfig != null) {
      buffers.addAll(streamConfig.collectBufferList());
    }
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableCustomAudioLocalPlayback(
      {required int trackId, required bool enabled}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableCustomAudioLocalPlayback_9566341';
    final param = createParams({'trackId': trackId, 'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setRecordingAudioFrameParameters(
      {required int sampleRate,
      required int channel,
      required RawAudioFrameOpModeType mode,
      required int samplesPerCall}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRecordingAudioFrameParameters_bd46d1d';
    final param = createParams({
      'sampleRate': sampleRate,
      'channel': channel,
      'mode': mode.value(),
      'samplesPerCall': samplesPerCall
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setPlaybackAudioFrameParameters(
      {required int sampleRate,
      required int channel,
      required RawAudioFrameOpModeType mode,
      required int samplesPerCall}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setPlaybackAudioFrameParameters_bd46d1d';
    final param = createParams({
      'sampleRate': sampleRate,
      'channel': channel,
      'mode': mode.value(),
      'samplesPerCall': samplesPerCall
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setMixedAudioFrameParameters(
      {required int sampleRate,
      required int channel,
      required int samplesPerCall}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setMixedAudioFrameParameters_ee7e270';
    final param = createParams({
      'sampleRate': sampleRate,
      'channel': channel,
      'samplesPerCall': samplesPerCall
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setEarMonitoringAudioFrameParameters(
      {required int sampleRate,
      required int channel,
      required RawAudioFrameOpModeType mode,
      required int samplesPerCall}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setEarMonitoringAudioFrameParameters_bd46d1d';
    final param = createParams({
      'sampleRate': sampleRate,
      'channel': channel,
      'mode': mode.value(),
      'samplesPerCall': samplesPerCall
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setPlaybackAudioFrameBeforeMixingParameters(
      {required int sampleRate, required int channel}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setPlaybackAudioFrameBeforeMixingParameters_4e92b3c';
    final param = createParams({'sampleRate': sampleRate, 'channel': channel});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableAudioSpectrumMonitor({int intervalInMS = 100}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableAudioSpectrumMonitor_46f8ab7';
    final param = createParams({'intervalInMS': intervalInMS});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> disableAudioSpectrumMonitor() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_disableAudioSpectrumMonitor';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  void registerAudioSpectrumObserver(AudioSpectrumObserver observer) {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_registerAudioSpectrumObserver_0406ea7';
// final param = createParams({
//   'observer': observer
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// if (result < 0) { throw AgoraRtcException(code: result); }
    throw UnimplementedError('Unimplement for registerAudioSpectrumObserver');
  }

  @override
  void unregisterAudioSpectrumObserver(AudioSpectrumObserver observer) {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_unregisterAudioSpectrumObserver_0406ea7';
// final param = createParams({
//   'observer': observer
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// if (result < 0) { throw AgoraRtcException(code: result); }
    throw UnimplementedError('Unimplement for unregisterAudioSpectrumObserver');
  }

  @override
  Future<void> adjustRecordingSignalVolume(int volume) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_adjustRecordingSignalVolume_46f8ab7';
    final param = createParams({'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> muteRecordingSignal(bool mute) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_muteRecordingSignal_5039d15';
    final param = createParams({'mute': mute});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> adjustPlaybackSignalVolume(int volume) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_adjustPlaybackSignalVolume_46f8ab7';
    final param = createParams({'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> adjustUserPlaybackSignalVolume(
      {required int uid, required int volume}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_adjustUserPlaybackSignalVolume_88641bf';
    final param = createParams({'uid': uid, 'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLocalPublishFallbackOption(
      StreamFallbackOptions option) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLocalPublishFallbackOption_c29b788';
    final param = createParams({'option': option.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setRemoteSubscribeFallbackOption(
      StreamFallbackOptions option) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRemoteSubscribeFallbackOption_c29b788';
    final param = createParams({'option': option.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setHighPriorityUserList(
      {required List<int> uidList,
      required int uidNum,
      required StreamFallbackOptions option}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setHighPriorityUserList_ab88726';
    final param = createParams(
        {'uidList': uidList, 'uidNum': uidNum, 'option': option.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableExtension(
      {required String provider,
      required String extension,
      bool enable = true,
      MediaSourceType type = MediaSourceType.unknownMediaSource}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableExtension_0b60a2c';
    final param = createParams({
      'provider': provider,
      'extension': extension,
      'enable': enable,
      'type': type.value()
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setExtensionProperty(
      {required String provider,
      required String extension,
      required String key,
      required String value,
      MediaSourceType type = MediaSourceType.unknownMediaSource}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setExtensionProperty_520ac55';
    final param = createParams({
      'provider': provider,
      'extension': extension,
      'key': key,
      'value': value,
      'type': type.value()
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<String> getExtensionProperty(
      {required String provider,
      required String extension,
      required String key,
      required int bufLen,
      MediaSourceType type = MediaSourceType.unknownMediaSource}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getExtensionProperty_38c9723';
    final param = createParams({
      'provider': provider,
      'extension': extension,
      'key': key,
      'buf_len': bufLen,
      'type': type.value()
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final getExtensionPropertyJson =
        RtcEngineGetExtensionPropertyJson.fromJson(rm);
    return getExtensionPropertyJson.value;
  }

  @override
  Future<void> enableLoopbackRecording(
      {required bool enabled, String? deviceName}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableLoopbackRecording_0b8eb79';
    final param = createParams(
        {'enabled': enabled, if (deviceName != null) 'deviceName': deviceName});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> adjustLoopbackSignalVolume(int volume) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_adjustLoopbackSignalVolume_46f8ab7';
    final param = createParams({'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getLoopbackRecordingVolume() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getLoopbackRecordingVolume';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> enableInEarMonitoring(
      {required bool enabled,
      required EarMonitoringFilterType includeAudioFilters}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableInEarMonitoring_077cf5f';
    final param = createParams({
      'enabled': enabled,
      'includeAudioFilters': includeAudioFilters.value()
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setInEarMonitoringVolume(int volume) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setInEarMonitoringVolume_46f8ab7';
    final param = createParams({'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> loadExtensionProvider(
      {required String path, bool unloadAfterUse = false}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_loadExtensionProvider_7a174df';
    final param =
        createParams({'path': path, 'unload_after_use': unloadAfterUse});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setExtensionProviderProperty(
      {required String provider,
      required String key,
      required String value}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setExtensionProviderProperty_0e4f59e';
    final param =
        createParams({'provider': provider, 'key': key, 'value': value});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> registerExtension(
      {required String provider,
      required String extension,
      MediaSourceType type = MediaSourceType.unknownMediaSource}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_registerExtension_fd62af4';
    final param = createParams(
        {'provider': provider, 'extension': extension, 'type': type.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setCameraCapturerConfiguration(
      CameraCapturerConfiguration config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraCapturerConfiguration_afa93b3';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> createCustomVideoTrack() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_createCustomVideoTrack';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<int> createCustomEncodedVideoTrack(SenderOptions senderOption) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_createCustomEncodedVideoTrack_0e9dc99';
    final param = createParams({'sender_option': senderOption.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(senderOption.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> destroyCustomVideoTrack(int videoTrackId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_destroyCustomVideoTrack_3019423';
    final param = createParams({'video_track_id': videoTrackId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> destroyCustomEncodedVideoTrack(int videoTrackId) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_destroyCustomEncodedVideoTrack_3019423';
    final param = createParams({'video_track_id': videoTrackId});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> switchCamera() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_switchCamera';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<bool> isCameraZoomSupported() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isCameraZoomSupported';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<bool> isCameraFaceDetectSupported() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isCameraFaceDetectSupported';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<bool> isCameraTorchSupported() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isCameraTorchSupported';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<bool> isCameraFocusSupported() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isCameraFocusSupported';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<bool> isCameraAutoFocusFaceModeSupported() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isCameraAutoFocusFaceModeSupported';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<void> setCameraZoomFactor(double factor) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraZoomFactor_685e803';
    final param = createParams({'factor': factor});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableFaceDetection(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableFaceDetection_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<double> getCameraMaxZoomFactor() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getCameraMaxZoomFactor';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as double;
  }

  @override
  Future<void> setCameraFocusPositionInPreview(
      {required double positionX, required double positionY}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraFocusPositionInPreview_f282d50';
    final param =
        createParams({'positionX': positionX, 'positionY': positionY});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setCameraTorchOn(bool isOn) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraTorchOn_5039d15';
    final param = createParams({'isOn': isOn});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setCameraAutoFocusFaceModeEnabled(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraAutoFocusFaceModeEnabled_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<bool> isCameraExposurePositionSupported() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isCameraExposurePositionSupported';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<void> setCameraExposurePosition(
      {required double positionXinView,
      required double positionYinView}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraExposurePosition_f282d50';
    final param = createParams({
      'positionXinView': positionXinView,
      'positionYinView': positionYinView
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<bool> isCameraExposureSupported() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isCameraExposureSupported';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<void> setCameraExposureFactor(double factor) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraExposureFactor_685e803';
    final param = createParams({'factor': factor});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<bool> isCameraAutoExposureFaceModeSupported() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isCameraAutoExposureFaceModeSupported';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<void> setCameraAutoExposureFaceModeEnabled(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraAutoExposureFaceModeEnabled_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setCameraStabilizationMode(CameraStabilizationMode mode) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraStabilizationMode_701b981';
    final param = createParams({'mode': mode.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setDefaultAudioRouteToSpeakerphone(bool defaultToSpeaker) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setDefaultAudioRouteToSpeakerphone_5039d15';
    final param = createParams({'defaultToSpeaker': defaultToSpeaker});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setEnableSpeakerphone(bool speakerOn) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setEnableSpeakerphone_5039d15';
    final param = createParams({'speakerOn': speakerOn});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<bool> isSpeakerphoneEnabled() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isSpeakerphoneEnabled';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<void> setRouteInCommunicationMode(int route) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRouteInCommunicationMode_46f8ab7';
    final param = createParams({'route': route});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<bool> isCameraCenterStageSupported() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isCameraCenterStageSupported';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<void> enableCameraCenterStage(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableCameraCenterStage_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<List<ScreenCaptureSourceInfo>> getScreenCaptureSources(
      {required SIZE thumbSize,
      required SIZE iconSize,
      required bool includeScreen}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getScreenCaptureSources_f3e02cb';
    final param = createParams({
      'thumbSize': thumbSize.toJson(),
      'iconSize': iconSize.toJson(),
      'includeScreen': includeScreen
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(thumbSize.collectBufferList());
    buffers.addAll(iconSize.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as List<ScreenCaptureSourceInfo>;
  }

  @override
  Future<void> setAudioSessionOperationRestriction(
      AudioSessionOperationRestriction restriction) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAudioSessionOperationRestriction_c492897';
    final param = createParams({'restriction': restriction.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startScreenCaptureByDisplayId(
      {required int displayId,
      required Rectangle regionRect,
      required ScreenCaptureParameters captureParams}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startScreenCaptureByDisplayId_7cf6800';
    final param = createParams({
      'displayId': displayId,
      'regionRect': regionRect.toJson(),
      'captureParams': captureParams.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(regionRect.collectBufferList());
    buffers.addAll(captureParams.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startScreenCaptureByScreenRect(
      {required Rectangle screenRect,
      required Rectangle regionRect,
      required ScreenCaptureParameters captureParams}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startScreenCaptureByScreenRect_e286286';
    final param = createParams({
      'screenRect': screenRect.toJson(),
      'regionRect': regionRect.toJson(),
      'captureParams': captureParams.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(screenRect.collectBufferList());
    buffers.addAll(regionRect.collectBufferList());
    buffers.addAll(captureParams.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<DeviceInfo> getAudioDeviceInfo() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getAudioDeviceInfo_505aa0c';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final getAudioDeviceInfoJson = RtcEngineGetAudioDeviceInfoJson.fromJson(rm);
    return getAudioDeviceInfoJson.deviceInfo;
  }

  @override
  Future<void> startScreenCaptureByWindowId(
      {required int windowId,
      required Rectangle regionRect,
      required ScreenCaptureParameters captureParams}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startScreenCaptureByWindowId_5ab7e59';
    final param = createParams({
      'windowId': windowId,
      'regionRect': regionRect.toJson(),
      'captureParams': captureParams.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(regionRect.collectBufferList());
    buffers.addAll(captureParams.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setScreenCaptureContentHint(VideoContentHint contentHint) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setScreenCaptureContentHint_8ad2c79';
    final param = createParams({'contentHint': contentHint.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> updateScreenCaptureRegion(Rectangle regionRect) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_updateScreenCaptureRegion_6b327a8';
    final param = createParams({'regionRect': regionRect.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(regionRect.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> updateScreenCaptureParameters(
      ScreenCaptureParameters captureParams) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_updateScreenCaptureParameters_a2eef93';
    final param = createParams({'captureParams': captureParams.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(captureParams.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startScreenCapture(
      ScreenCaptureParameters2 captureParams) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startScreenCapture_270da41';
    final param = createParams({'captureParams': captureParams.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(captureParams.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> updateScreenCapture(
      ScreenCaptureParameters2 captureParams) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_updateScreenCapture_270da41';
    final param = createParams({'captureParams': captureParams.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(captureParams.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> queryScreenCaptureCapability() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_queryScreenCaptureCapability';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<List<FocalLengthInfo>> queryCameraFocalLengthCapability() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_queryCameraFocalLengthCapability_2dee6af';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final queryCameraFocalLengthCapabilityJson =
        RtcEngineQueryCameraFocalLengthCapabilityJson.fromJson(rm);
    return queryCameraFocalLengthCapabilityJson.focalLengthInfos;
  }

  @override
  Future<void> setScreenCaptureScenario(
      ScreenScenarioType screenScenario) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setScreenCaptureScenario_13de7b4';
    final param = createParams({'screenScenario': screenScenario.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopScreenCapture() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopScreenCapture';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<String> getCallId() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getCallId_66d4ecd';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final getCallIdJson = RtcEngineGetCallIdJson.fromJson(rm);
    return getCallIdJson.callId;
  }

  @override
  Future<void> rate(
      {required String callId,
      required int rating,
      required String description}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_rate_f1a0070';
    final param = createParams(
        {'callId': callId, 'rating': rating, 'description': description});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> complain(
      {required String callId, required String description}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_complain_ccad422';
    final param = createParams({'callId': callId, 'description': description});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startRtmpStreamWithoutTranscoding(String url) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startRtmpStreamWithoutTranscoding_3a2037f';
    final param = createParams({'url': url});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startRtmpStreamWithTranscoding(
      {required String url, required LiveTranscoding transcoding}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startRtmpStreamWithTranscoding_f76aa1a';
    final param =
        createParams({'url': url, 'transcoding': transcoding.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(transcoding.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> updateRtmpTranscoding(LiveTranscoding transcoding) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_updateRtmpTranscoding_91368d4';
    final param = createParams({'transcoding': transcoding.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(transcoding.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startLocalVideoTranscoder(
      LocalTranscoderConfiguration config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startLocalVideoTranscoder_90f9e33';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> updateLocalTranscoderConfiguration(
      LocalTranscoderConfiguration config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_updateLocalTranscoderConfiguration_90f9e33';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopRtmpStream(String url) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopRtmpStream_3a2037f';
    final param = createParams({'url': url});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopLocalVideoTranscoder() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopLocalVideoTranscoder';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startCameraCapture(
      {required VideoSourceType sourceType,
      required CameraCapturerConfiguration config}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startCameraCapture_f3692cc';
    final param = createParams(
        {'sourceType': sourceType.value(), 'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopCameraCapture(VideoSourceType sourceType) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopCameraCapture_4fd718e';
    final param = createParams({'sourceType': sourceType.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setCameraDeviceOrientation(
      {required VideoSourceType type,
      required VideoOrientation orientation}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCameraDeviceOrientation_025aae8';
    final param = createParams(
        {'type': type.value(), 'orientation': orientation.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setScreenCaptureOrientation(
      {required VideoSourceType type,
      required VideoOrientation orientation}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setScreenCaptureOrientation_025aae8';
    final param = createParams(
        {'type': type.value(), 'orientation': orientation.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<ConnectionStateType> getConnectionState() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getConnectionState';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return ConnectionStateTypeExt.fromValue(result);
  }

  @override
  void registerEventHandler(RtcEngineEventHandler eventHandler) {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_registerEventHandler_5fc0465';
// final param = createParams({
//   'eventHandler': eventHandler
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// if (result < 0) { throw AgoraRtcException(code: result); }
    throw UnimplementedError('Unimplement for registerEventHandler');
  }

  @override
  void unregisterEventHandler(RtcEngineEventHandler eventHandler) {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_unregisterEventHandler_5fc0465';
// final param = createParams({
//   'eventHandler': eventHandler
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// if (result < 0) { throw AgoraRtcException(code: result); }
    throw UnimplementedError('Unimplement for unregisterEventHandler');
  }

  @override
  Future<void> setRemoteUserPriority(
      {required int uid, required PriorityType userPriority}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setRemoteUserPriority_f34115b';
    final param =
        createParams({'uid': uid, 'userPriority': userPriority.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setEncryptionMode(String encryptionMode) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setEncryptionMode_3a2037f';
    final param = createParams({'encryptionMode': encryptionMode});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setEncryptionSecret(String secret) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setEncryptionSecret_3a2037f';
    final param = createParams({'secret': secret});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableEncryption(
      {required bool enabled, required EncryptionConfig config}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableEncryption_421c27b';
    final param = createParams({'enabled': enabled, 'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> createDataStream(DataStreamConfig config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_createDataStream_5862815';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final createDataStreamJson = RtcEngineCreateDataStreamJson.fromJson(rm);
    return createDataStreamJson.streamId;
  }

  @override
  Future<void> sendStreamMessage(
      {required int streamId,
      required Uint8List data,
      required int length}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_sendStreamMessage_8715a45';
    final param = createParams({'streamId': streamId, 'length': length});
    final List<Uint8List> buffers = [];
    buffers.add(data);
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> addVideoWatermark(
      {required String watermarkUrl, required WatermarkOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_addVideoWatermark_7480410';
    final param = createParams(
        {'watermarkUrl': watermarkUrl, 'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> clearVideoWatermarks() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_clearVideoWatermarks';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> pauseAudio() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_pauseAudio';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> resumeAudio() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_resumeAudio';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableWebSdkInteroperability(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableWebSdkInteroperability_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> sendCustomReportMessage(
      {required String id,
      required String category,
      required String event,
      required String label,
      required int value}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_sendCustomReportMessage_56d6589';
    final param = createParams({
      'id': id,
      'category': category,
      'event': event,
      'label': label,
      'value': value
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  void registerMediaMetadataObserver(
      {required MetadataObserver observer, required MetadataType type}) {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_registerMediaMetadataObserver_8701fec';
// final param = createParams({
//   'observer': observer,'type': type.value()
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// if (result < 0) { throw AgoraRtcException(code: result); }
    throw UnimplementedError('Unimplement for registerMediaMetadataObserver');
  }

  @override
  void unregisterMediaMetadataObserver(
      {required MetadataObserver observer, required MetadataType type}) {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_unregisterMediaMetadataObserver_8701fec';
// final param = createParams({
//   'observer': observer,'type': type.value()
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// if (result < 0) { throw AgoraRtcException(code: result); }
    throw UnimplementedError('Unimplement for unregisterMediaMetadataObserver');
  }

  @override
  Future<void> startAudioFrameDump(
      {required String channelId,
      required int uid,
      required String location,
      required String uuid,
      required String passwd,
      required int durationMs,
      required bool autoUpload}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startAudioFrameDump_aad7331';
    final param = createParams({
      'channel_id': channelId,
      'uid': uid,
      'location': location,
      'uuid': uuid,
      'passwd': passwd,
      'duration_ms': durationMs,
      'auto_upload': autoUpload
    });
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopAudioFrameDump(
      {required String channelId,
      required int uid,
      required String location}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopAudioFrameDump_a4c9af4';
    final param = createParams(
        {'channel_id': channelId, 'uid': uid, 'location': location});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAINSMode(
      {required bool enabled, required AudioAinsMode mode}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAINSMode_4df3049';
    final param = createParams({'enabled': enabled, 'mode': mode.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> registerLocalUserAccount(
      {required String appId, required String userAccount}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_registerLocalUserAccount_ccad422';
    final param = createParams({'appId': appId, 'userAccount': userAccount});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> joinChannelWithUserAccount(
      {required String token,
      required String channelId,
      required String userAccount,
      ChannelMediaOptions? options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_joinChannelWithUserAccount_4685af9';
    final param = createParams({
      'token': token,
      'channelId': channelId,
      'userAccount': userAccount,
      'options': options?.toJson()
    });
    final List<Uint8List> buffers = [];
    if (options != null) {
      buffers.addAll(options.collectBufferList());
    }
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> joinChannelWithUserAccountEx(
      {required String token,
      required String channelId,
      required String userAccount,
      required ChannelMediaOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_joinChannelWithUserAccountEx_268b977';
    final param = createParams({
      'token': token,
      'channelId': channelId,
      'userAccount': userAccount,
      'options': options.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<UserInfo> getUserInfoByUserAccount(String userAccount) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getUserInfoByUserAccount_c6a8f08';
    final param = createParams({'userAccount': userAccount});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final getUserInfoByUserAccountJson =
        RtcEngineGetUserInfoByUserAccountJson.fromJson(rm);
    return getUserInfoByUserAccountJson.userInfo;
  }

  @override
  Future<UserInfo> getUserInfoByUid(int uid) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getUserInfoByUid_6b7aee8';
    final param = createParams({'uid': uid});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
    final getUserInfoByUidJson = RtcEngineGetUserInfoByUidJson.fromJson(rm);
    return getUserInfoByUidJson.userInfo;
  }

  @override
  Future<void> startOrUpdateChannelMediaRelay(
      ChannelMediaRelayConfiguration configuration) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startOrUpdateChannelMediaRelay_e68f0a4';
    final param = createParams({'configuration': configuration.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(configuration.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopChannelMediaRelay() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopChannelMediaRelay';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> pauseAllChannelMediaRelay() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_pauseAllChannelMediaRelay';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> resumeAllChannelMediaRelay() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_resumeAllChannelMediaRelay';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setDirectCdnStreamingAudioConfiguration(
      AudioProfileType profile) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setDirectCdnStreamingAudioConfiguration_ac39c15';
    final param = createParams({'profile': profile.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setDirectCdnStreamingVideoConfiguration(
      VideoEncoderConfiguration config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setDirectCdnStreamingVideoConfiguration_89677d8';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startDirectCdnStreaming(
      {required DirectCdnStreamingEventHandler eventHandler,
      required String publishUrl,
      required DirectCdnStreamingMediaOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startDirectCdnStreaming_ed8d77b';
    final param = createParams({
      'eventHandler': eventHandler,
      'publishUrl': publishUrl,
      'options': options.toJson()
    });
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopDirectCdnStreaming() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopDirectCdnStreaming';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> updateDirectCdnStreamingMediaOptions(
      DirectCdnStreamingMediaOptions options) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_updateDirectCdnStreamingMediaOptions_d2556c8';
    final param = createParams({'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startRhythmPlayer(
      {required String sound1,
      required String sound2,
      required AgoraRhythmPlayerConfig config}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startRhythmPlayer_e1f6565';
    final param = createParams(
        {'sound1': sound1, 'sound2': sound2, 'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopRhythmPlayer() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopRhythmPlayer';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> configRhythmPlayer(AgoraRhythmPlayerConfig config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_configRhythmPlayer_b36c805';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> takeSnapshot(
      {required int uid, required String filePath}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_takeSnapshot_1922dd1';
    final param = createParams({'uid': uid, 'filePath': filePath});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableContentInspect(
      {required bool enabled, required ContentInspectConfig config}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableContentInspect_e15e514';
    final param = createParams({'enabled': enabled, 'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> adjustCustomAudioPublishVolume(
      {required int trackId, required int volume}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_adjustCustomAudioPublishVolume_f8da2ca';
    final param = createParams({'trackId': trackId, 'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> adjustCustomAudioPlayoutVolume(
      {required int trackId, required int volume}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_adjustCustomAudioPlayoutVolume_f8da2ca';
    final param = createParams({'trackId': trackId, 'volume': volume});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setCloudProxy(CloudProxyType proxyType) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setCloudProxy_39d115e';
    final param = createParams({'proxyType': proxyType.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setLocalAccessPoint(LocalAccessPointConfiguration config) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setLocalAccessPoint_798c8c7';
    final param = createParams({'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAdvancedAudioOptions(
      {required AdvancedAudioOptions options, int sourceType = 0}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAdvancedAudioOptions_38d986b';
    final param =
        createParams({'options': options.toJson(), 'sourceType': sourceType});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setAVSyncSource(
      {required String channelId, required int uid}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setAVSyncSource_bf26e54';
    final param = createParams({'channelId': channelId, 'uid': uid});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableVideoImageSource(
      {required bool enable, required ImageTrackOptions options}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableVideoImageSource_5f39ea0';
    final param = createParams({'enable': enable, 'options': options.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(options.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getCurrentMonotonicTimeInMs() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getCurrentMonotonicTimeInMs';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> enableWirelessAccelerate(bool enabled) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableWirelessAccelerate_5039d15';
    final param = createParams({'enabled': enabled});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getNetworkType() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getNetworkType';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<void> setParameters(String parameters) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setParameters_3a2037f';
    final param = createParams({'parameters': parameters});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startMediaRenderingTracing() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startMediaRenderingTracing';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> enableInstantMediaRendering() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_enableInstantMediaRendering';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<int> getNtpWallTimeInMs() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getNtpWallTimeInMs';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }

  @override
  Future<bool> isFeatureAvailableOnDevice(FeatureType type) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_isFeatureAvailableOnDevice_a694b62';
    final param = createParams({'type': type.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as bool;
  }

  @override
  Future<void> sendAudioMetadata(
      {required Uint8List metadata, required int length}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_sendAudioMetadata_878f309';
    final param = createParams({'length': length});
    final List<Uint8List> buffers = [];
    buffers.add(metadata);
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startScreenCaptureBySourceType(
      {required VideoSourceType sourceType,
      required ScreenCaptureConfiguration config}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startScreenCapture_9ebb320';
    final param = createParams(
        {'sourceType': sourceType.value(), 'config': config.toJson()});
    final List<Uint8List> buffers = [];
    buffers.addAll(config.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> stopScreenCaptureBySourceType(VideoSourceType sourceType) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_stopScreenCapture_4fd718e';
    final param = createParams({'sourceType': sourceType.value()});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> release({bool sync = false}) async {
    final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_release';
    final param = createParams({'sync': sync});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> startPreviewWithoutSourceType() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_startPreview';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  AudioDeviceManager getAudioDeviceManager() {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_queryInterface_257d192';
// final param = createParams({
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// return result as AudioDeviceManager;
    throw UnimplementedError('Unimplement for getAudioDeviceManager');
  }

  @override
  VideoDeviceManager getVideoDeviceManager() {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_queryInterface_257d192';
// final param = createParams({
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// return result as VideoDeviceManager;
    throw UnimplementedError('Unimplement for getVideoDeviceManager');
  }

  @override
  MusicContentCenter getMusicContentCenter() {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_queryInterface_257d192';
// final param = createParams({
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// return result as MusicContentCenter;
    throw UnimplementedError('Unimplement for getMusicContentCenter');
  }

  @override
  MediaEngine getMediaEngine() {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_queryInterface_257d192';
// final param = createParams({
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// return result as MediaEngine;
    throw UnimplementedError('Unimplement for getMediaEngine');
  }

  @override
  LocalSpatialAudioEngine getLocalSpatialAudioEngine() {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_queryInterface_257d192';
// final param = createParams({
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// return result as LocalSpatialAudioEngine;
    throw UnimplementedError('Unimplement for getLocalSpatialAudioEngine');
  }

  @override
  H265Transcoder getH265Transcoder() {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_queryInterface_257d192';
// final param = createParams({
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// return result as H265Transcoder;
    throw UnimplementedError('Unimplement for getH265Transcoder');
  }

  @override
  Future<void> sendMetaData(
      {required Metadata metadata, required VideoSourceType sourceType}) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_sendMetaData';
    final param = createParams(
        {'metadata': metadata.toJson(), 'source_type': sourceType.value()});
    final List<Uint8List> buffers = [];
    buffers.addAll(metadata.collectBufferList());
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: buffers));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  Future<void> setMaxMetadataSize(int size) async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_setMaxMetadataSize';
    final param = createParams({'size': size});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    if (result < 0) {
      throw AgoraRtcException(code: result);
    }
  }

  @override
  void unregisterAudioEncodedFrameObserver(AudioEncodedFrameObserver observer) {
    // Implementation template
// final apiType = '${isOverrideClassName ? className : 'RtcEngine'}_unregisterAudioEncodedFrameObserver';
// final param = createParams({
//   'observer': observer
// });
// final callApiResult = await irisMethodChannel.invokeMethod(IrisMethodCall(apiType, jsonEncode(param), buffers:null));
// if (callApiResult.irisReturnCode < 0) {
//   throw AgoraRtcException(code: callApiResult.irisReturnCode);
// }
// final rm = callApiResult.data;
// final result = rm['result'];
// if (result < 0) { throw AgoraRtcException(code: result); }
    throw UnimplementedError(
        'Unimplement for unregisterAudioEncodedFrameObserver');
  }

  @override
  Future<int> getNativeHandle() async {
    final apiType =
        '${isOverrideClassName ? className : 'RtcEngine'}_getNativeHandle';
    final param = createParams({});
    final callApiResult = await irisMethodChannel.invokeMethod(
        IrisMethodCall(apiType, jsonEncode(param), buffers: null));
    if (callApiResult.irisReturnCode < 0) {
      throw AgoraRtcException(code: callApiResult.irisReturnCode);
    }
    final rm = callApiResult.data;
    final result = rm['result'];
    return result as int;
  }
}
