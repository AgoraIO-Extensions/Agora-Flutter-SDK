/// GENERATED BY testcase_gen. DO NOT MODIFY BY HAND.

// ignore_for_file: deprecated_member_use,constant_identifier_names

import 'dart:async';
import 'dart:typed_data';

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:iris_tester/iris_tester.dart';
import 'package:agora_rtc_engine/src/impl/api_caller.dart';

void generatedTestCases() {
  testWidgets(
    'onRecorderStateChanged',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.getDebugApiEngineNativeHandle();
      setMockIrisApiEngineIntPtr(debugApiEngineIntPtr);

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final mediaRecorder = rtcEngine.getMediaRecorder();

      final onRecorderStateChangedCompleter = Completer<bool>();
      final theMediaRecorderObserver = MediaRecorderObserver(
        onRecorderStateChanged: (RecorderState state, RecorderErrorCode error) {
          onRecorderStateChangedCompleter.complete(true);
        },
      );

      const String connectionChannelId = "hello";
      const int connectionLocalUid = 10;
      const RtcConnection connection = RtcConnection(
        channelId: connectionChannelId,
        localUid: connectionLocalUid,
      );

      await mediaRecorder.setMediaRecorderObserver(
        connection: connection,
        callback: theMediaRecorderObserver,
      );

// Delay 500 milliseconds to ensure the setMediaRecorderObserver call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const RecorderState state = RecorderState.recorderStateError;
        const RecorderErrorCode error = RecorderErrorCode.recorderErrorNone;

        final eventJson = {
          'state': state.value(),
          'error': error.value(),
        };

        irisTester.fireEvent('MediaRecorderObserver_onRecorderStateChanged',
            params: eventJson);
      }

      final eventCalled = await onRecorderStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await mediaRecorder.release();
      await rtcEngine.release();
    },
  );

  testWidgets(
    'onRecorderInfoUpdated',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.getDebugApiEngineNativeHandle();
      setMockIrisApiEngineIntPtr(debugApiEngineIntPtr);

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final mediaRecorder = rtcEngine.getMediaRecorder();

      final onRecorderInfoUpdatedCompleter = Completer<bool>();
      final theMediaRecorderObserver = MediaRecorderObserver(
        onRecorderInfoUpdated: (RecorderInfo info) {
          onRecorderInfoUpdatedCompleter.complete(true);
        },
      );

      const String connectionChannelId = "hello";
      const int connectionLocalUid = 10;
      const RtcConnection connection = RtcConnection(
        channelId: connectionChannelId,
        localUid: connectionLocalUid,
      );

      await mediaRecorder.setMediaRecorderObserver(
        connection: connection,
        callback: theMediaRecorderObserver,
      );

// Delay 500 milliseconds to ensure the setMediaRecorderObserver call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String infoFileName = "hello";
        const int infoDurationMs = 10;
        const int infoFileSize = 10;
        const RecorderInfo info = RecorderInfo(
          fileName: infoFileName,
          durationMs: infoDurationMs,
          fileSize: infoFileSize,
        );

        final eventJson = {
          'info': info.toJson(),
        };

        irisTester.fireEvent('MediaRecorderObserver_onRecorderInfoUpdated',
            params: eventJson);
      }

      final eventCalled = await onRecorderInfoUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {}
// Delay 500 milliseconds to ensure the  call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await mediaRecorder.release();
      await rtcEngine.release();
    },
  );
}

