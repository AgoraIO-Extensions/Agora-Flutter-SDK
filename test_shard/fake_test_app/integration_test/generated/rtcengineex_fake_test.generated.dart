/// GENERATED BY testcase_gen. DO NOT MODIFY BY HAND.

// ignore_for_file: deprecated_member_use,constant_identifier_names

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:flutter_test/flutter_test.dart';
import 'dart:typed_data';
import 'package:flutter/foundation.dart';
import 'package:fake_test_app/main.dart' as app;
import 'package:iris_tester/iris_tester.dart';
import 'package:iris_method_channel/iris_method_channel.dart';

void rtcEngineExSmokeTestCases() {
  testWidgets(
    'joinChannelEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String token = "hello";
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const ClientRoleType optionsClientRoleType =
            ClientRoleType.clientRoleBroadcaster;
        const AudienceLatencyLevelType optionsAudienceLatencyLevel =
            AudienceLatencyLevelType.audienceLatencyLevelLowLatency;
        const VideoStreamType optionsDefaultVideoStreamType =
            VideoStreamType.videoStreamHigh;
        const ChannelProfileType optionsChannelProfile =
            ChannelProfileType.channelProfileCommunication;
        const bool optionsPublishCameraTrack = true;
        const bool optionsPublishSecondaryCameraTrack = true;
        const bool optionsPublishThirdCameraTrack = true;
        const bool optionsPublishFourthCameraTrack = true;
        const bool optionsPublishMicrophoneTrack = true;
        const bool optionsPublishScreenCaptureVideo = true;
        const bool optionsPublishScreenCaptureAudio = true;
        const bool optionsPublishScreenTrack = true;
        const bool optionsPublishSecondaryScreenTrack = true;
        const bool optionsPublishThirdScreenTrack = true;
        const bool optionsPublishFourthScreenTrack = true;
        const bool optionsPublishCustomAudioTrack = true;
        const int optionsPublishCustomAudioTrackId = 10;
        const bool optionsPublishCustomAudioTrackAec = true;
        const bool optionsPublishCustomVideoTrack = true;
        const bool optionsPublishEncodedVideoTrack = true;
        const bool optionsPublishMediaPlayerAudioTrack = true;
        const bool optionsPublishMediaPlayerVideoTrack = true;
        const bool optionsPublishTrancodedVideoTrack = true;
        const bool optionsPublishMixedAudioTrack = true;
        const bool optionsAutoSubscribeAudio = true;
        const bool optionsAutoSubscribeVideo = true;
        const bool optionsEnableAudioRecordingOrPlayout = true;
        const int optionsPublishMediaPlayerId = 10;
        const int optionsAudioDelayMs = 10;
        const int optionsMediaPlayerAudioDelayMs = 10;
        const String optionsToken = "hello";
        const bool optionsEnableBuiltInMediaEncryption = true;
        const bool optionsPublishRhythmPlayerTrack = true;
        const bool optionsIsInteractiveAudience = true;
        const int optionsCustomVideoTrackId = 10;
        const bool optionsIsAudioFilterable = true;
        const String optionsParameters = "hello";
        const ChannelMediaOptions options = ChannelMediaOptions(
          publishCameraTrack: optionsPublishCameraTrack,
          publishSecondaryCameraTrack: optionsPublishSecondaryCameraTrack,
          publishThirdCameraTrack: optionsPublishThirdCameraTrack,
          publishFourthCameraTrack: optionsPublishFourthCameraTrack,
          publishMicrophoneTrack: optionsPublishMicrophoneTrack,
          publishScreenCaptureVideo: optionsPublishScreenCaptureVideo,
          publishScreenCaptureAudio: optionsPublishScreenCaptureAudio,
          publishScreenTrack: optionsPublishScreenTrack,
          publishSecondaryScreenTrack: optionsPublishSecondaryScreenTrack,
          publishThirdScreenTrack: optionsPublishThirdScreenTrack,
          publishFourthScreenTrack: optionsPublishFourthScreenTrack,
          publishCustomAudioTrack: optionsPublishCustomAudioTrack,
          publishCustomAudioTrackId: optionsPublishCustomAudioTrackId,
          publishCustomAudioTrackAec: optionsPublishCustomAudioTrackAec,
          publishCustomVideoTrack: optionsPublishCustomVideoTrack,
          publishEncodedVideoTrack: optionsPublishEncodedVideoTrack,
          publishMediaPlayerAudioTrack: optionsPublishMediaPlayerAudioTrack,
          publishMediaPlayerVideoTrack: optionsPublishMediaPlayerVideoTrack,
          publishTrancodedVideoTrack: optionsPublishTrancodedVideoTrack,
          publishMixedAudioTrack: optionsPublishMixedAudioTrack,
          autoSubscribeAudio: optionsAutoSubscribeAudio,
          autoSubscribeVideo: optionsAutoSubscribeVideo,
          enableAudioRecordingOrPlayout: optionsEnableAudioRecordingOrPlayout,
          publishMediaPlayerId: optionsPublishMediaPlayerId,
          clientRoleType: optionsClientRoleType,
          audienceLatencyLevel: optionsAudienceLatencyLevel,
          defaultVideoStreamType: optionsDefaultVideoStreamType,
          channelProfile: optionsChannelProfile,
          audioDelayMs: optionsAudioDelayMs,
          mediaPlayerAudioDelayMs: optionsMediaPlayerAudioDelayMs,
          token: optionsToken,
          enableBuiltInMediaEncryption: optionsEnableBuiltInMediaEncryption,
          publishRhythmPlayerTrack: optionsPublishRhythmPlayerTrack,
          isInteractiveAudience: optionsIsInteractiveAudience,
          customVideoTrackId: optionsCustomVideoTrackId,
          isAudioFilterable: optionsIsAudioFilterable,
          parameters: optionsParameters,
        );
        await rtcEngineEx.joinChannelEx(
          token: token,
          connection: connection,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[joinChannelEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'leaveChannelEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const bool optionsStopAudioMixing = true;
        const bool optionsStopAllEffect = true;
        const bool optionsStopMicrophoneRecording = true;
        const LeaveChannelOptions options = LeaveChannelOptions(
          stopAudioMixing: optionsStopAudioMixing,
          stopAllEffect: optionsStopAllEffect,
          stopMicrophoneRecording: optionsStopMicrophoneRecording,
        );
        await rtcEngineEx.leaveChannelEx(
          connection: connection,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[leaveChannelEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'updateChannelMediaOptionsEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const ClientRoleType optionsClientRoleType =
            ClientRoleType.clientRoleBroadcaster;
        const AudienceLatencyLevelType optionsAudienceLatencyLevel =
            AudienceLatencyLevelType.audienceLatencyLevelLowLatency;
        const VideoStreamType optionsDefaultVideoStreamType =
            VideoStreamType.videoStreamHigh;
        const ChannelProfileType optionsChannelProfile =
            ChannelProfileType.channelProfileCommunication;
        const bool optionsPublishCameraTrack = true;
        const bool optionsPublishSecondaryCameraTrack = true;
        const bool optionsPublishThirdCameraTrack = true;
        const bool optionsPublishFourthCameraTrack = true;
        const bool optionsPublishMicrophoneTrack = true;
        const bool optionsPublishScreenCaptureVideo = true;
        const bool optionsPublishScreenCaptureAudio = true;
        const bool optionsPublishScreenTrack = true;
        const bool optionsPublishSecondaryScreenTrack = true;
        const bool optionsPublishThirdScreenTrack = true;
        const bool optionsPublishFourthScreenTrack = true;
        const bool optionsPublishCustomAudioTrack = true;
        const int optionsPublishCustomAudioTrackId = 10;
        const bool optionsPublishCustomAudioTrackAec = true;
        const bool optionsPublishCustomVideoTrack = true;
        const bool optionsPublishEncodedVideoTrack = true;
        const bool optionsPublishMediaPlayerAudioTrack = true;
        const bool optionsPublishMediaPlayerVideoTrack = true;
        const bool optionsPublishTrancodedVideoTrack = true;
        const bool optionsPublishMixedAudioTrack = true;
        const bool optionsAutoSubscribeAudio = true;
        const bool optionsAutoSubscribeVideo = true;
        const bool optionsEnableAudioRecordingOrPlayout = true;
        const int optionsPublishMediaPlayerId = 10;
        const int optionsAudioDelayMs = 10;
        const int optionsMediaPlayerAudioDelayMs = 10;
        const String optionsToken = "hello";
        const bool optionsEnableBuiltInMediaEncryption = true;
        const bool optionsPublishRhythmPlayerTrack = true;
        const bool optionsIsInteractiveAudience = true;
        const int optionsCustomVideoTrackId = 10;
        const bool optionsIsAudioFilterable = true;
        const String optionsParameters = "hello";
        const ChannelMediaOptions options = ChannelMediaOptions(
          publishCameraTrack: optionsPublishCameraTrack,
          publishSecondaryCameraTrack: optionsPublishSecondaryCameraTrack,
          publishThirdCameraTrack: optionsPublishThirdCameraTrack,
          publishFourthCameraTrack: optionsPublishFourthCameraTrack,
          publishMicrophoneTrack: optionsPublishMicrophoneTrack,
          publishScreenCaptureVideo: optionsPublishScreenCaptureVideo,
          publishScreenCaptureAudio: optionsPublishScreenCaptureAudio,
          publishScreenTrack: optionsPublishScreenTrack,
          publishSecondaryScreenTrack: optionsPublishSecondaryScreenTrack,
          publishThirdScreenTrack: optionsPublishThirdScreenTrack,
          publishFourthScreenTrack: optionsPublishFourthScreenTrack,
          publishCustomAudioTrack: optionsPublishCustomAudioTrack,
          publishCustomAudioTrackId: optionsPublishCustomAudioTrackId,
          publishCustomAudioTrackAec: optionsPublishCustomAudioTrackAec,
          publishCustomVideoTrack: optionsPublishCustomVideoTrack,
          publishEncodedVideoTrack: optionsPublishEncodedVideoTrack,
          publishMediaPlayerAudioTrack: optionsPublishMediaPlayerAudioTrack,
          publishMediaPlayerVideoTrack: optionsPublishMediaPlayerVideoTrack,
          publishTrancodedVideoTrack: optionsPublishTrancodedVideoTrack,
          publishMixedAudioTrack: optionsPublishMixedAudioTrack,
          autoSubscribeAudio: optionsAutoSubscribeAudio,
          autoSubscribeVideo: optionsAutoSubscribeVideo,
          enableAudioRecordingOrPlayout: optionsEnableAudioRecordingOrPlayout,
          publishMediaPlayerId: optionsPublishMediaPlayerId,
          clientRoleType: optionsClientRoleType,
          audienceLatencyLevel: optionsAudienceLatencyLevel,
          defaultVideoStreamType: optionsDefaultVideoStreamType,
          channelProfile: optionsChannelProfile,
          audioDelayMs: optionsAudioDelayMs,
          mediaPlayerAudioDelayMs: optionsMediaPlayerAudioDelayMs,
          token: optionsToken,
          enableBuiltInMediaEncryption: optionsEnableBuiltInMediaEncryption,
          publishRhythmPlayerTrack: optionsPublishRhythmPlayerTrack,
          isInteractiveAudience: optionsIsInteractiveAudience,
          customVideoTrackId: optionsCustomVideoTrackId,
          isAudioFilterable: optionsIsAudioFilterable,
          parameters: optionsParameters,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.updateChannelMediaOptionsEx(
          options: options,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[updateChannelMediaOptionsEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'setVideoEncoderConfigurationEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoCodecType configCodecType = VideoCodecType.videoCodecNone;
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions configDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const OrientationMode configOrientationMode =
            OrientationMode.orientationModeAdaptive;
        const DegradationPreference configDegradationPreference =
            DegradationPreference.maintainQuality;
        const VideoMirrorModeType configMirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const EncodingPreference advanceOptionsEncodingPreference =
            EncodingPreference.preferAuto;
        const CompressionPreference advanceOptionsCompressionPreference =
            CompressionPreference.preferLowLatency;
        const AdvanceOptions configAdvanceOptions = AdvanceOptions(
          encodingPreference: advanceOptionsEncodingPreference,
          compressionPreference: advanceOptionsCompressionPreference,
        );
        const int configFrameRate = 10;
        const int configBitrate = 10;
        const int configMinBitrate = 10;
        const VideoEncoderConfiguration config = VideoEncoderConfiguration(
          codecType: configCodecType,
          dimensions: configDimensions,
          frameRate: configFrameRate,
          bitrate: configBitrate,
          minBitrate: configMinBitrate,
          orientationMode: configOrientationMode,
          degradationPreference: configDegradationPreference,
          mirrorMode: configMirrorMode,
          advanceOptions: configAdvanceOptions,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.setVideoEncoderConfigurationEx(
          config: config,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setVideoEncoderConfigurationEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'setupRemoteVideoEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const RenderModeType canvasRenderMode = RenderModeType.renderModeHidden;
        const VideoMirrorModeType canvasMirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const VideoViewSetupMode canvasSetupMode =
            VideoViewSetupMode.videoViewSetupReplace;
        const VideoSourceType canvasSourceType =
            VideoSourceType.videoSourceCameraPrimary;
        const int cropAreaX = 10;
        const int cropAreaY = 10;
        const int cropAreaWidth = 10;
        const int cropAreaHeight = 10;
        const Rectangle canvasCropArea = Rectangle(
          x: cropAreaX,
          y: cropAreaY,
          width: cropAreaWidth,
          height: cropAreaHeight,
        );
        const int canvasView = 10;
        const int canvasUid = 10;
        const int canvasSubviewUid = 10;
        const int canvasMediaPlayerId = 10;
        const bool canvasEnableAlphaMask = true;
        const VideoCanvas canvas = VideoCanvas(
          view: canvasView,
          uid: canvasUid,
          subviewUid: canvasSubviewUid,
          renderMode: canvasRenderMode,
          mirrorMode: canvasMirrorMode,
          setupMode: canvasSetupMode,
          sourceType: canvasSourceType,
          mediaPlayerId: canvasMediaPlayerId,
          cropArea: canvasCropArea,
          enableAlphaMask: canvasEnableAlphaMask,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.setupRemoteVideoEx(
          canvas: canvas,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setupRemoteVideoEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'muteRemoteAudioStreamEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const bool mute = true;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.muteRemoteAudioStreamEx(
          uid: uid,
          mute: mute,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteRemoteAudioStreamEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'muteRemoteVideoStreamEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const bool mute = true;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.muteRemoteVideoStreamEx(
          uid: uid,
          mute: mute,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteRemoteVideoStreamEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'setRemoteVideoStreamTypeEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const VideoStreamType streamType = VideoStreamType.videoStreamHigh;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.setRemoteVideoStreamTypeEx(
          uid: uid,
          streamType: streamType,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setRemoteVideoStreamTypeEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'muteLocalAudioStreamEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.muteLocalAudioStreamEx(
          mute: mute,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteLocalAudioStreamEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'muteLocalVideoStreamEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.muteLocalVideoStreamEx(
          mute: mute,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteLocalVideoStreamEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'muteAllRemoteAudioStreamsEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.muteAllRemoteAudioStreamsEx(
          mute: mute,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteAllRemoteAudioStreamsEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'muteAllRemoteVideoStreamsEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.muteAllRemoteVideoStreamsEx(
          mute: mute,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteAllRemoteVideoStreamsEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'setRemoteVideoSubscriptionOptionsEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const VideoStreamType optionsType = VideoStreamType.videoStreamHigh;
        const bool optionsEncodedFrameOnly = true;
        const VideoSubscriptionOptions options = VideoSubscriptionOptions(
          type: optionsType,
          encodedFrameOnly: optionsEncodedFrameOnly,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.setRemoteVideoSubscriptionOptionsEx(
          uid: uid,
          options: options,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setRemoteVideoSubscriptionOptionsEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'setRemoteVoicePositionEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const double pan = 10.0;
        const double gain = 10.0;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.setRemoteVoicePositionEx(
          uid: uid,
          pan: pan,
          gain: gain,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setRemoteVoicePositionEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'setRemoteUserSpatialAudioParamsEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const double paramsSpeakerAzimuth = 10.0;
        const double paramsSpeakerElevation = 10.0;
        const double paramsSpeakerDistance = 10.0;
        const int paramsSpeakerOrientation = 10;
        const bool paramsEnableBlur = true;
        const bool paramsEnableAirAbsorb = true;
        const double paramsSpeakerAttenuation = 10.0;
        const bool paramsEnableDoppler = true;
        const SpatialAudioParams params = SpatialAudioParams(
          speakerAzimuth: paramsSpeakerAzimuth,
          speakerElevation: paramsSpeakerElevation,
          speakerDistance: paramsSpeakerDistance,
          speakerOrientation: paramsSpeakerOrientation,
          enableBlur: paramsEnableBlur,
          enableAirAbsorb: paramsEnableAirAbsorb,
          speakerAttenuation: paramsSpeakerAttenuation,
          enableDoppler: paramsEnableDoppler,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.setRemoteUserSpatialAudioParamsEx(
          uid: uid,
          params: params,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setRemoteUserSpatialAudioParamsEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'setRemoteRenderModeEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const RenderModeType renderMode = RenderModeType.renderModeHidden;
        const VideoMirrorModeType mirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.setRemoteRenderModeEx(
          uid: uid,
          renderMode: renderMode,
          mirrorMode: mirrorMode,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setRemoteRenderModeEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'enableLoopbackRecordingEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const bool enabled = true;
        const String deviceName = "hello";
        await rtcEngineEx.enableLoopbackRecordingEx(
          connection: connection,
          enabled: enabled,
          deviceName: deviceName,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableLoopbackRecordingEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'adjustRecordingSignalVolumeEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int volume = 10;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.adjustRecordingSignalVolumeEx(
          volume: volume,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustRecordingSignalVolumeEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'muteRecordingSignalEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.muteRecordingSignalEx(
          mute: mute,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteRecordingSignalEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'adjustUserPlaybackSignalVolumeEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const int volume = 10;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.adjustUserPlaybackSignalVolumeEx(
          uid: uid,
          volume: volume,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[adjustUserPlaybackSignalVolumeEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'getConnectionStateEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.getConnectionStateEx(
          connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getConnectionStateEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'enableEncryptionEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const bool enabled = true;
        const EncryptionMode configEncryptionMode = EncryptionMode.aes128Xts;
        const String configEncryptionKey = "hello";
        Uint8List configEncryptionKdfSalt = Uint8List.fromList([1, 2, 3, 4, 5]);
        final EncryptionConfig config = EncryptionConfig(
          encryptionMode: configEncryptionMode,
          encryptionKey: configEncryptionKey,
          encryptionKdfSalt: configEncryptionKdfSalt,
        );
        await rtcEngineEx.enableEncryptionEx(
          connection: connection,
          enabled: enabled,
          config: config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableEncryptionEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'sendStreamMessageEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int streamId = 10;
        Uint8List data = Uint8List.fromList([1, 2, 3, 4, 5]);
        const int length = 10;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.sendStreamMessageEx(
          streamId: streamId,
          data: data,
          length: length,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[sendStreamMessageEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'addVideoWatermarkEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String watermarkUrl = "hello";
        const int positionInLandscapeModeX = 10;
        const int positionInLandscapeModeY = 10;
        const int positionInLandscapeModeWidth = 10;
        const int positionInLandscapeModeHeight = 10;
        const Rectangle optionsPositionInLandscapeMode = Rectangle(
          x: positionInLandscapeModeX,
          y: positionInLandscapeModeY,
          width: positionInLandscapeModeWidth,
          height: positionInLandscapeModeHeight,
        );
        const int positionInPortraitModeX = 10;
        const int positionInPortraitModeY = 10;
        const int positionInPortraitModeWidth = 10;
        const int positionInPortraitModeHeight = 10;
        const Rectangle optionsPositionInPortraitMode = Rectangle(
          x: positionInPortraitModeX,
          y: positionInPortraitModeY,
          width: positionInPortraitModeWidth,
          height: positionInPortraitModeHeight,
        );
        const double watermarkRatioXRatio = 10.0;
        const double watermarkRatioYRatio = 10.0;
        const double watermarkRatioWidthRatio = 10.0;
        const WatermarkRatio optionsWatermarkRatio = WatermarkRatio(
          xRatio: watermarkRatioXRatio,
          yRatio: watermarkRatioYRatio,
          widthRatio: watermarkRatioWidthRatio,
        );
        const WatermarkFitMode optionsMode =
            WatermarkFitMode.fitModeCoverPosition;
        const bool optionsVisibleInPreview = true;
        const WatermarkOptions options = WatermarkOptions(
          visibleInPreview: optionsVisibleInPreview,
          positionInLandscapeMode: optionsPositionInLandscapeMode,
          positionInPortraitMode: optionsPositionInPortraitMode,
          watermarkRatio: optionsWatermarkRatio,
          mode: optionsMode,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.addVideoWatermarkEx(
          watermarkUrl: watermarkUrl,
          options: options,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[addVideoWatermarkEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'clearVideoWatermarkEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.clearVideoWatermarkEx(
          connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[clearVideoWatermarkEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'sendCustomReportMessageEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String id = "hello";
        const String category = "hello";
        const String event = "hello";
        const String label = "hello";
        const int value = 10;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.sendCustomReportMessageEx(
          id: id,
          category: category,
          event: event,
          label: label,
          value: value,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[sendCustomReportMessageEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'enableAudioVolumeIndicationEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int interval = 10;
        const int smooth = 10;
        const bool reportVad = true;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.enableAudioVolumeIndicationEx(
          interval: interval,
          smooth: smooth,
          reportVad: reportVad,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableAudioVolumeIndicationEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'startRtmpStreamWithoutTranscodingEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String url = "hello";
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.startRtmpStreamWithoutTranscodingEx(
          url: url,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[startRtmpStreamWithoutTranscodingEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'startRtmpStreamWithTranscodingEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String url = "hello";
        const VideoCodecProfileType transcodingVideoCodecProfile =
            VideoCodecProfileType.videoCodecProfileBaseline;
        const VideoCodecTypeForStream transcodingVideoCodecType =
            VideoCodecTypeForStream.videoCodecH264ForStream;
        const AudioSampleRateType transcodingAudioSampleRate =
            AudioSampleRateType.audioSampleRate32000;
        const AudioCodecProfileType transcodingAudioCodecProfile =
            AudioCodecProfileType.audioCodecProfileLcAac;
        const int transcodingWidth = 10;
        const int transcodingHeight = 10;
        const int transcodingVideoBitrate = 10;
        const int transcodingVideoFramerate = 10;
        const bool transcodingLowLatency = true;
        const int transcodingVideoGop = 10;
        const int transcodingBackgroundColor = 10;
        const int transcodingUserCount = 10;
        const List<TranscodingUser> transcodingTranscodingUsers = [];
        const String transcodingTranscodingExtraInfo = "hello";
        const String transcodingMetadata = "hello";
        const List<RtcImage> transcodingWatermark = [];
        const int transcodingWatermarkCount = 10;
        const List<RtcImage> transcodingBackgroundImage = [];
        const int transcodingBackgroundImageCount = 10;
        const int transcodingAudioBitrate = 10;
        const int transcodingAudioChannels = 10;
        const List<LiveStreamAdvancedFeature> transcodingAdvancedFeatures = [];
        const int transcodingAdvancedFeatureCount = 10;
        const LiveTranscoding transcoding = LiveTranscoding(
          width: transcodingWidth,
          height: transcodingHeight,
          videoBitrate: transcodingVideoBitrate,
          videoFramerate: transcodingVideoFramerate,
          lowLatency: transcodingLowLatency,
          videoGop: transcodingVideoGop,
          videoCodecProfile: transcodingVideoCodecProfile,
          backgroundColor: transcodingBackgroundColor,
          videoCodecType: transcodingVideoCodecType,
          userCount: transcodingUserCount,
          transcodingUsers: transcodingTranscodingUsers,
          transcodingExtraInfo: transcodingTranscodingExtraInfo,
          metadata: transcodingMetadata,
          watermark: transcodingWatermark,
          watermarkCount: transcodingWatermarkCount,
          backgroundImage: transcodingBackgroundImage,
          backgroundImageCount: transcodingBackgroundImageCount,
          audioSampleRate: transcodingAudioSampleRate,
          audioBitrate: transcodingAudioBitrate,
          audioChannels: transcodingAudioChannels,
          audioCodecProfile: transcodingAudioCodecProfile,
          advancedFeatures: transcodingAdvancedFeatures,
          advancedFeatureCount: transcodingAdvancedFeatureCount,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.startRtmpStreamWithTranscodingEx(
          url: url,
          transcoding: transcoding,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[startRtmpStreamWithTranscodingEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'updateRtmpTranscodingEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoCodecProfileType transcodingVideoCodecProfile =
            VideoCodecProfileType.videoCodecProfileBaseline;
        const VideoCodecTypeForStream transcodingVideoCodecType =
            VideoCodecTypeForStream.videoCodecH264ForStream;
        const AudioSampleRateType transcodingAudioSampleRate =
            AudioSampleRateType.audioSampleRate32000;
        const AudioCodecProfileType transcodingAudioCodecProfile =
            AudioCodecProfileType.audioCodecProfileLcAac;
        const int transcodingWidth = 10;
        const int transcodingHeight = 10;
        const int transcodingVideoBitrate = 10;
        const int transcodingVideoFramerate = 10;
        const bool transcodingLowLatency = true;
        const int transcodingVideoGop = 10;
        const int transcodingBackgroundColor = 10;
        const int transcodingUserCount = 10;
        const List<TranscodingUser> transcodingTranscodingUsers = [];
        const String transcodingTranscodingExtraInfo = "hello";
        const String transcodingMetadata = "hello";
        const List<RtcImage> transcodingWatermark = [];
        const int transcodingWatermarkCount = 10;
        const List<RtcImage> transcodingBackgroundImage = [];
        const int transcodingBackgroundImageCount = 10;
        const int transcodingAudioBitrate = 10;
        const int transcodingAudioChannels = 10;
        const List<LiveStreamAdvancedFeature> transcodingAdvancedFeatures = [];
        const int transcodingAdvancedFeatureCount = 10;
        const LiveTranscoding transcoding = LiveTranscoding(
          width: transcodingWidth,
          height: transcodingHeight,
          videoBitrate: transcodingVideoBitrate,
          videoFramerate: transcodingVideoFramerate,
          lowLatency: transcodingLowLatency,
          videoGop: transcodingVideoGop,
          videoCodecProfile: transcodingVideoCodecProfile,
          backgroundColor: transcodingBackgroundColor,
          videoCodecType: transcodingVideoCodecType,
          userCount: transcodingUserCount,
          transcodingUsers: transcodingTranscodingUsers,
          transcodingExtraInfo: transcodingTranscodingExtraInfo,
          metadata: transcodingMetadata,
          watermark: transcodingWatermark,
          watermarkCount: transcodingWatermarkCount,
          backgroundImage: transcodingBackgroundImage,
          backgroundImageCount: transcodingBackgroundImageCount,
          audioSampleRate: transcodingAudioSampleRate,
          audioBitrate: transcodingAudioBitrate,
          audioChannels: transcodingAudioChannels,
          audioCodecProfile: transcodingAudioCodecProfile,
          advancedFeatures: transcodingAdvancedFeatures,
          advancedFeatureCount: transcodingAdvancedFeatureCount,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.updateRtmpTranscodingEx(
          transcoding: transcoding,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[updateRtmpTranscodingEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'stopRtmpStreamEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String url = "hello";
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.stopRtmpStreamEx(
          url: url,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopRtmpStreamEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'stopChannelMediaRelayEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.stopChannelMediaRelayEx(
          connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopChannelMediaRelayEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'pauseAllChannelMediaRelayEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.pauseAllChannelMediaRelayEx(
          connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[pauseAllChannelMediaRelayEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'resumeAllChannelMediaRelayEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.resumeAllChannelMediaRelayEx(
          connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[resumeAllChannelMediaRelayEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'getUserInfoByUserAccountEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String userAccount = "hello";
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.getUserInfoByUserAccountEx(
          userAccount: userAccount,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getUserInfoByUserAccountEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'getUserInfoByUidEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.getUserInfoByUidEx(
          uid: uid,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getUserInfoByUidEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'setVideoProfileEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int width = 10;
        const int height = 10;
        const int frameRate = 10;
        const int bitrate = 10;
        await rtcEngineEx.setVideoProfileEx(
          width: width,
          height: height,
          frameRate: frameRate,
          bitrate: bitrate,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setVideoProfileEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'enableDualStreamModeEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions streamConfigDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int streamConfigKBitrate = 10;
        const int streamConfigFramerate = 10;
        const SimulcastStreamConfig streamConfig = SimulcastStreamConfig(
          dimensions: streamConfigDimensions,
          kBitrate: streamConfigKBitrate,
          framerate: streamConfigFramerate,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.enableDualStreamModeEx(
          enabled: enabled,
          streamConfig: streamConfig,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableDualStreamModeEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'setDualStreamModeEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const SimulcastStreamMode mode =
            SimulcastStreamMode.autoSimulcastStream;
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions streamConfigDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int streamConfigKBitrate = 10;
        const int streamConfigFramerate = 10;
        const SimulcastStreamConfig streamConfig = SimulcastStreamConfig(
          dimensions: streamConfigDimensions,
          kBitrate: streamConfigKBitrate,
          framerate: streamConfigFramerate,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.setDualStreamModeEx(
          mode: mode,
          streamConfig: streamConfig,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setDualStreamModeEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'enableWirelessAccelerate',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngineEx.enableWirelessAccelerate(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableWirelessAccelerate] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'takeSnapshotEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int uid = 10;
        const String filePath = "hello";
        await rtcEngineEx.takeSnapshotEx(
          connection: connection,
          uid: uid,
          filePath: filePath,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[takeSnapshotEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'enableContentInspectEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const String configExtraInfo = "hello";
        const List<ContentInspectModule> configModules = [];
        const int configModuleCount = 10;
        const ContentInspectConfig config = ContentInspectConfig(
          extraInfo: configExtraInfo,
          modules: configModules,
          moduleCount: configModuleCount,
        );
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.enableContentInspectEx(
          enabled: enabled,
          config: config,
          connection: connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableContentInspectEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'startMediaRenderingTracingEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.startMediaRenderingTracingEx(
          connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startMediaRenderingTracingEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'sendAudioMetadataEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        Uint8List metadata = Uint8List.fromList([1, 2, 3, 4, 5]);
        const int length = 10;
        await rtcEngineEx.sendAudioMetadataEx(
          connection: connection,
          metadata: metadata,
          length: length,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[sendAudioMetadataEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );

  testWidgets(
    'getCallIdEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngineEx rtcEngineEx = createAgoraRtcEngineEx();
      await rtcEngineEx.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        await rtcEngineEx.getCallIdEx(
          connection,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getCallIdEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngineEx.release();
    },
//  skip: !(),
  );
}

