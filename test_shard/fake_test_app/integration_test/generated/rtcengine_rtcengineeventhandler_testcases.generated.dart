/// GENERATED BY testcase_gen. DO NOT MODIFY BY HAND.

// ignore_for_file: deprecated_member_use,constant_identifier_names

import 'dart:async';
import 'dart:typed_data';

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:iris_tester/iris_tester.dart';
import 'package:iris_method_channel/iris_method_channel.dart';

import '../testcases/event_ids_mapping.dart';

void generatedTestCases(ValueGetter<IrisTester> irisTester) {
  testWidgets(
    'RtcEngineEventHandler.onJoinChannelSuccess',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onJoinChannelSuccessCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onJoinChannelSuccess: (RtcConnection connection, int elapsed) {
          onJoinChannelSuccessCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'elapsed': elapsed,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onJoinChannelSuccess'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onJoinChannelSuccessCompleter.isCompleted) {
              onJoinChannelSuccessCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onJoinChannelSuccessCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRejoinChannelSuccess',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRejoinChannelSuccessCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRejoinChannelSuccess: (RtcConnection connection, int elapsed) {
          onRejoinChannelSuccessCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'elapsed': elapsed,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onRejoinChannelSuccess'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRejoinChannelSuccessCompleter.isCompleted) {
              onRejoinChannelSuccessCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRejoinChannelSuccessCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onProxyConnected',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onProxyConnectedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onProxyConnected: (String channel, int uid, ProxyType proxyType,
            String localProxyIp, int elapsed) {
          onProxyConnectedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String channel = "hello";
        const int uid = 10;
        const ProxyType proxyType = ProxyType.noneProxyType;
        const String localProxyIp = "hello";
        const int elapsed = 10;

        final eventJson = {
          'channel': channel,
          'uid': uid,
          'proxyType': proxyType.value(),
          'localProxyIp': localProxyIp,
          'elapsed': elapsed,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onProxyConnected'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onProxyConnectedCompleter.isCompleted) {
              onProxyConnectedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onProxyConnectedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onError: (ErrorCodeType err, String msg) {
          onErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const ErrorCodeType err = ErrorCodeType.errOk;
        const String msg = "hello";

        final eventJson = {
          'err': err.value(),
          'msg': msg,
        };

        final eventIds = eventIdsMapping['RtcEngineEventHandler_onError'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onErrorCompleter.isCompleted) {
              onErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioQuality',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioQualityCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioQuality: (RtcConnection connection, int remoteUid,
            QualityType quality, int delay, int lost) {
          onAudioQualityCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const QualityType quality = QualityType.qualityUnknown;
        const int delay = 10;
        const int lost = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'quality': quality.value(),
          'delay': delay,
          'lost': lost,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onAudioQuality'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioQualityCompleter.isCompleted) {
              onAudioQualityCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioQualityCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLastmileProbeResult',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLastmileProbeResultCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLastmileProbeResult: (LastmileProbeResult result) {
          onLastmileProbeResultCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const LastmileProbeResultState resultState =
            LastmileProbeResultState.lastmileProbeResultComplete;
        const int uplinkReportPacketLossRate = 10;
        const int uplinkReportJitter = 10;
        const int uplinkReportAvailableBandwidth = 10;
        const LastmileProbeOneWayResult resultUplinkReport =
            LastmileProbeOneWayResult(
          packetLossRate: uplinkReportPacketLossRate,
          jitter: uplinkReportJitter,
          availableBandwidth: uplinkReportAvailableBandwidth,
        );
        const int downlinkReportPacketLossRate = 10;
        const int downlinkReportJitter = 10;
        const int downlinkReportAvailableBandwidth = 10;
        const LastmileProbeOneWayResult resultDownlinkReport =
            LastmileProbeOneWayResult(
          packetLossRate: downlinkReportPacketLossRate,
          jitter: downlinkReportJitter,
          availableBandwidth: downlinkReportAvailableBandwidth,
        );
        const int resultRtt = 10;
        const LastmileProbeResult result = LastmileProbeResult(
          state: resultState,
          uplinkReport: resultUplinkReport,
          downlinkReport: resultDownlinkReport,
          rtt: resultRtt,
        );

        final eventJson = {
          'result': result.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onLastmileProbeResult'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLastmileProbeResultCompleter.isCompleted) {
              onLastmileProbeResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLastmileProbeResultCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioVolumeIndication',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioVolumeIndicationCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioVolumeIndication: (RtcConnection connection, List speakers,
            int speakerNumber, int totalVolume) {
          onAudioVolumeIndicationCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const List<AudioVolumeInfo> speakers = [];
        const int speakerNumber = 10;
        const int totalVolume = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'speakers': speakers,
          'speakerNumber': speakerNumber,
          'totalVolume': totalVolume,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onAudioVolumeIndication'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioVolumeIndicationCompleter.isCompleted) {
              onAudioVolumeIndicationCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioVolumeIndicationCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLeaveChannel',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLeaveChannelCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLeaveChannel: (RtcConnection connection, RtcStats stats) {
          onLeaveChannelCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int statsDuration = 10;
        const int statsTxBytes = 10;
        const int statsRxBytes = 10;
        const int statsTxAudioBytes = 10;
        const int statsTxVideoBytes = 10;
        const int statsRxAudioBytes = 10;
        const int statsRxVideoBytes = 10;
        const int statsTxKBitRate = 10;
        const int statsRxKBitRate = 10;
        const int statsRxAudioKBitRate = 10;
        const int statsTxAudioKBitRate = 10;
        const int statsRxVideoKBitRate = 10;
        const int statsTxVideoKBitRate = 10;
        const int statsLastmileDelay = 10;
        const int statsUserCount = 10;
        const double statsCpuAppUsage = 10.0;
        const double statsCpuTotalUsage = 10.0;
        const int statsGatewayRtt = 10;
        const double statsMemoryAppUsageRatio = 10.0;
        const double statsMemoryTotalUsageRatio = 10.0;
        const int statsMemoryAppUsageInKbytes = 10;
        const int statsConnectTimeMs = 10;
        const int statsFirstAudioPacketDuration = 10;
        const int statsFirstVideoPacketDuration = 10;
        const int statsFirstVideoKeyFramePacketDuration = 10;
        const int statsPacketsBeforeFirstKeyFramePacket = 10;
        const int statsFirstAudioPacketDurationAfterUnmute = 10;
        const int statsFirstVideoPacketDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFramePacketDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFrameDecodedDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFrameRenderedDurationAfterUnmute = 10;
        const int statsTxPacketLossRate = 10;
        const int statsRxPacketLossRate = 10;
        const RtcStats stats = RtcStats(
          duration: statsDuration,
          txBytes: statsTxBytes,
          rxBytes: statsRxBytes,
          txAudioBytes: statsTxAudioBytes,
          txVideoBytes: statsTxVideoBytes,
          rxAudioBytes: statsRxAudioBytes,
          rxVideoBytes: statsRxVideoBytes,
          txKBitRate: statsTxKBitRate,
          rxKBitRate: statsRxKBitRate,
          rxAudioKBitRate: statsRxAudioKBitRate,
          txAudioKBitRate: statsTxAudioKBitRate,
          rxVideoKBitRate: statsRxVideoKBitRate,
          txVideoKBitRate: statsTxVideoKBitRate,
          lastmileDelay: statsLastmileDelay,
          userCount: statsUserCount,
          cpuAppUsage: statsCpuAppUsage,
          cpuTotalUsage: statsCpuTotalUsage,
          gatewayRtt: statsGatewayRtt,
          memoryAppUsageRatio: statsMemoryAppUsageRatio,
          memoryTotalUsageRatio: statsMemoryTotalUsageRatio,
          memoryAppUsageInKbytes: statsMemoryAppUsageInKbytes,
          connectTimeMs: statsConnectTimeMs,
          firstAudioPacketDuration: statsFirstAudioPacketDuration,
          firstVideoPacketDuration: statsFirstVideoPacketDuration,
          firstVideoKeyFramePacketDuration:
              statsFirstVideoKeyFramePacketDuration,
          packetsBeforeFirstKeyFramePacket:
              statsPacketsBeforeFirstKeyFramePacket,
          firstAudioPacketDurationAfterUnmute:
              statsFirstAudioPacketDurationAfterUnmute,
          firstVideoPacketDurationAfterUnmute:
              statsFirstVideoPacketDurationAfterUnmute,
          firstVideoKeyFramePacketDurationAfterUnmute:
              statsFirstVideoKeyFramePacketDurationAfterUnmute,
          firstVideoKeyFrameDecodedDurationAfterUnmute:
              statsFirstVideoKeyFrameDecodedDurationAfterUnmute,
          firstVideoKeyFrameRenderedDurationAfterUnmute:
              statsFirstVideoKeyFrameRenderedDurationAfterUnmute,
          txPacketLossRate: statsTxPacketLossRate,
          rxPacketLossRate: statsRxPacketLossRate,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onLeaveChannel'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLeaveChannelCompleter.isCompleted) {
              onLeaveChannelCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLeaveChannelCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRtcStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRtcStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRtcStats: (RtcConnection connection, RtcStats stats) {
          onRtcStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int statsDuration = 10;
        const int statsTxBytes = 10;
        const int statsRxBytes = 10;
        const int statsTxAudioBytes = 10;
        const int statsTxVideoBytes = 10;
        const int statsRxAudioBytes = 10;
        const int statsRxVideoBytes = 10;
        const int statsTxKBitRate = 10;
        const int statsRxKBitRate = 10;
        const int statsRxAudioKBitRate = 10;
        const int statsTxAudioKBitRate = 10;
        const int statsRxVideoKBitRate = 10;
        const int statsTxVideoKBitRate = 10;
        const int statsLastmileDelay = 10;
        const int statsUserCount = 10;
        const double statsCpuAppUsage = 10.0;
        const double statsCpuTotalUsage = 10.0;
        const int statsGatewayRtt = 10;
        const double statsMemoryAppUsageRatio = 10.0;
        const double statsMemoryTotalUsageRatio = 10.0;
        const int statsMemoryAppUsageInKbytes = 10;
        const int statsConnectTimeMs = 10;
        const int statsFirstAudioPacketDuration = 10;
        const int statsFirstVideoPacketDuration = 10;
        const int statsFirstVideoKeyFramePacketDuration = 10;
        const int statsPacketsBeforeFirstKeyFramePacket = 10;
        const int statsFirstAudioPacketDurationAfterUnmute = 10;
        const int statsFirstVideoPacketDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFramePacketDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFrameDecodedDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFrameRenderedDurationAfterUnmute = 10;
        const int statsTxPacketLossRate = 10;
        const int statsRxPacketLossRate = 10;
        const RtcStats stats = RtcStats(
          duration: statsDuration,
          txBytes: statsTxBytes,
          rxBytes: statsRxBytes,
          txAudioBytes: statsTxAudioBytes,
          txVideoBytes: statsTxVideoBytes,
          rxAudioBytes: statsRxAudioBytes,
          rxVideoBytes: statsRxVideoBytes,
          txKBitRate: statsTxKBitRate,
          rxKBitRate: statsRxKBitRate,
          rxAudioKBitRate: statsRxAudioKBitRate,
          txAudioKBitRate: statsTxAudioKBitRate,
          rxVideoKBitRate: statsRxVideoKBitRate,
          txVideoKBitRate: statsTxVideoKBitRate,
          lastmileDelay: statsLastmileDelay,
          userCount: statsUserCount,
          cpuAppUsage: statsCpuAppUsage,
          cpuTotalUsage: statsCpuTotalUsage,
          gatewayRtt: statsGatewayRtt,
          memoryAppUsageRatio: statsMemoryAppUsageRatio,
          memoryTotalUsageRatio: statsMemoryTotalUsageRatio,
          memoryAppUsageInKbytes: statsMemoryAppUsageInKbytes,
          connectTimeMs: statsConnectTimeMs,
          firstAudioPacketDuration: statsFirstAudioPacketDuration,
          firstVideoPacketDuration: statsFirstVideoPacketDuration,
          firstVideoKeyFramePacketDuration:
              statsFirstVideoKeyFramePacketDuration,
          packetsBeforeFirstKeyFramePacket:
              statsPacketsBeforeFirstKeyFramePacket,
          firstAudioPacketDurationAfterUnmute:
              statsFirstAudioPacketDurationAfterUnmute,
          firstVideoPacketDurationAfterUnmute:
              statsFirstVideoPacketDurationAfterUnmute,
          firstVideoKeyFramePacketDurationAfterUnmute:
              statsFirstVideoKeyFramePacketDurationAfterUnmute,
          firstVideoKeyFrameDecodedDurationAfterUnmute:
              statsFirstVideoKeyFrameDecodedDurationAfterUnmute,
          firstVideoKeyFrameRenderedDurationAfterUnmute:
              statsFirstVideoKeyFrameRenderedDurationAfterUnmute,
          txPacketLossRate: statsTxPacketLossRate,
          rxPacketLossRate: statsRxPacketLossRate,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onRtcStats'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRtcStatsCompleter.isCompleted) {
              onRtcStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRtcStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioDeviceStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioDeviceStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioDeviceStateChanged: (String deviceId, MediaDeviceType deviceType,
            MediaDeviceStateType deviceState) {
          onAudioDeviceStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String deviceId = "hello";
        const MediaDeviceType deviceType = MediaDeviceType.unknownAudioDevice;
        const MediaDeviceStateType deviceState =
            MediaDeviceStateType.mediaDeviceStateIdle;

        final eventJson = {
          'deviceId': deviceId,
          'deviceType': deviceType.value(),
          'deviceState': deviceState.value(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onAudioDeviceStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioDeviceStateChangedCompleter.isCompleted) {
              onAudioDeviceStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioDeviceStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioMixingPositionChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioMixingPositionChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioMixingPositionChanged: (int position) {
          onAudioMixingPositionChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int position = 10;

        final eventJson = {
          'position': position,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onAudioMixingPositionChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioMixingPositionChangedCompleter.isCompleted) {
              onAudioMixingPositionChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioMixingPositionChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioMixingFinished',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioMixingFinishedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioMixingFinished: () {
          onAudioMixingFinishedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onAudioMixingFinished'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioMixingFinishedCompleter.isCompleted) {
              onAudioMixingFinishedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioMixingFinishedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioEffectFinished',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioEffectFinishedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioEffectFinished: (int soundId) {
          onAudioEffectFinishedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int soundId = 10;

        final eventJson = {
          'soundId': soundId,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onAudioEffectFinished'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioEffectFinishedCompleter.isCompleted) {
              onAudioEffectFinishedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioEffectFinishedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onVideoDeviceStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onVideoDeviceStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoDeviceStateChanged: (String deviceId, MediaDeviceType deviceType,
            MediaDeviceStateType deviceState) {
          onVideoDeviceStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String deviceId = "hello";
        const MediaDeviceType deviceType = MediaDeviceType.unknownAudioDevice;
        const MediaDeviceStateType deviceState =
            MediaDeviceStateType.mediaDeviceStateIdle;

        final eventJson = {
          'deviceId': deviceId,
          'deviceType': deviceType.value(),
          'deviceState': deviceState.value(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onVideoDeviceStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onVideoDeviceStateChangedCompleter.isCompleted) {
              onVideoDeviceStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoDeviceStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onNetworkQuality',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onNetworkQualityCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onNetworkQuality: (RtcConnection connection, int remoteUid,
            QualityType txQuality, QualityType rxQuality) {
          onNetworkQualityCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const QualityType txQuality = QualityType.qualityUnknown;
        const QualityType rxQuality = QualityType.qualityUnknown;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'txQuality': txQuality.value(),
          'rxQuality': rxQuality.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onNetworkQuality'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onNetworkQualityCompleter.isCompleted) {
              onNetworkQualityCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onNetworkQualityCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onIntraRequestReceived',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onIntraRequestReceivedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onIntraRequestReceived: (RtcConnection connection) {
          onIntraRequestReceivedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onIntraRequestReceived'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onIntraRequestReceivedCompleter.isCompleted) {
              onIntraRequestReceivedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onIntraRequestReceivedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUplinkNetworkInfoUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUplinkNetworkInfoUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUplinkNetworkInfoUpdated: (UplinkNetworkInfo info) {
          onUplinkNetworkInfoUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int infoVideoEncoderTargetBitrateBps = 10;
        const UplinkNetworkInfo info = UplinkNetworkInfo(
          videoEncoderTargetBitrateBps: infoVideoEncoderTargetBitrateBps,
        );

        final eventJson = {
          'info': info.toJson(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onUplinkNetworkInfoUpdated'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUplinkNetworkInfoUpdatedCompleter.isCompleted) {
              onUplinkNetworkInfoUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUplinkNetworkInfoUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onDownlinkNetworkInfoUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onDownlinkNetworkInfoUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onDownlinkNetworkInfoUpdated: (DownlinkNetworkInfo info) {
          onDownlinkNetworkInfoUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int infoLastmileBufferDelayTimeMs = 10;
        const int infoBandwidthEstimationBps = 10;
        const int infoTotalDownscaleLevelCount = 10;
        const List<PeerDownlinkInfo> infoPeerDownlinkInfo = [];
        const int infoTotalReceivedVideoCount = 10;
        const DownlinkNetworkInfo info = DownlinkNetworkInfo(
          lastmileBufferDelayTimeMs: infoLastmileBufferDelayTimeMs,
          bandwidthEstimationBps: infoBandwidthEstimationBps,
          totalDownscaleLevelCount: infoTotalDownscaleLevelCount,
          peerDownlinkInfo: infoPeerDownlinkInfo,
          totalReceivedVideoCount: infoTotalReceivedVideoCount,
        );

        final eventJson = {
          'info': info.toJson(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onDownlinkNetworkInfoUpdated'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onDownlinkNetworkInfoUpdatedCompleter.isCompleted) {
              onDownlinkNetworkInfoUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onDownlinkNetworkInfoUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLastmileQuality',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLastmileQualityCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLastmileQuality: (QualityType quality) {
          onLastmileQualityCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const QualityType quality = QualityType.qualityUnknown;

        final eventJson = {
          'quality': quality.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onLastmileQuality'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLastmileQualityCompleter.isCompleted) {
              onLastmileQualityCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLastmileQualityCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onFirstLocalVideoFrame',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onFirstLocalVideoFrameCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstLocalVideoFrame:
            (VideoSourceType source, int width, int height, int elapsed) {
          onFirstLocalVideoFrameCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const int width = 10;
        const int height = 10;
        const int elapsed = 10;

        final eventJson = {
          'source': source.value(),
          'width': width,
          'height': height,
          'elapsed': elapsed,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onFirstLocalVideoFrame'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onFirstLocalVideoFrameCompleter.isCompleted) {
              onFirstLocalVideoFrameCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstLocalVideoFrameCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onFirstLocalVideoFramePublished',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onFirstLocalVideoFramePublishedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstLocalVideoFramePublished: (VideoSourceType source, int elapsed) {
          onFirstLocalVideoFramePublishedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const int elapsed = 10;

        final eventJson = {
          'source': source.value(),
          'elapsed': elapsed,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onFirstLocalVideoFramePublished'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onFirstLocalVideoFramePublishedCompleter.isCompleted) {
              onFirstLocalVideoFramePublishedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstLocalVideoFramePublishedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onFirstRemoteVideoDecoded',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onFirstRemoteVideoDecodedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstRemoteVideoDecoded: (RtcConnection connection, int remoteUid,
            int width, int height, int elapsed) {
          onFirstRemoteVideoDecodedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int width = 10;
        const int height = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'width': width,
          'height': height,
          'elapsed': elapsed,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onFirstRemoteVideoDecoded'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onFirstRemoteVideoDecodedCompleter.isCompleted) {
              onFirstRemoteVideoDecodedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstRemoteVideoDecodedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onVideoSizeChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onVideoSizeChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoSizeChanged: (RtcConnection connection,
            VideoSourceType sourceType,
            int uid,
            int width,
            int height,
            int rotation) {
          onVideoSizeChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const VideoSourceType sourceType =
            VideoSourceType.videoSourceCameraPrimary;
        const int uid = 10;
        const int width = 10;
        const int height = 10;
        const int rotation = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'sourceType': sourceType.value(),
          'uid': uid,
          'width': width,
          'height': height,
          'rotation': rotation,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onVideoSizeChanged'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onVideoSizeChangedCompleter.isCompleted) {
              onVideoSizeChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoSizeChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLocalVideoStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLocalVideoStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalVideoStateChanged: (VideoSourceType source,
            LocalVideoStreamState state, LocalVideoStreamError error) {
          onLocalVideoStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const LocalVideoStreamState state =
            LocalVideoStreamState.localVideoStreamStateStopped;
        const LocalVideoStreamError error =
            LocalVideoStreamError.localVideoStreamErrorOk;

        final eventJson = {
          'source': source.value(),
          'state': state.value(),
          'error': error.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onLocalVideoStateChanged'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLocalVideoStateChangedCompleter.isCompleted) {
              onLocalVideoStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalVideoStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRemoteVideoStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRemoteVideoStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteVideoStateChanged: (RtcConnection connection,
            int remoteUid,
            RemoteVideoState state,
            RemoteVideoStateReason reason,
            int elapsed) {
          onRemoteVideoStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const RemoteVideoState state = RemoteVideoState.remoteVideoStateStopped;
        const RemoteVideoStateReason reason =
            RemoteVideoStateReason.remoteVideoStateReasonInternal;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'state': state.value(),
          'reason': reason.value(),
          'elapsed': elapsed,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onRemoteVideoStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoteVideoStateChangedCompleter.isCompleted) {
              onRemoteVideoStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteVideoStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onFirstRemoteVideoFrame',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onFirstRemoteVideoFrameCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstRemoteVideoFrame: (RtcConnection connection, int remoteUid,
            int width, int height, int elapsed) {
          onFirstRemoteVideoFrameCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int width = 10;
        const int height = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'width': width,
          'height': height,
          'elapsed': elapsed,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onFirstRemoteVideoFrame'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onFirstRemoteVideoFrameCompleter.isCompleted) {
              onFirstRemoteVideoFrameCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstRemoteVideoFrameCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUserJoined',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUserJoinedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserJoined: (RtcConnection connection, int remoteUid, int elapsed) {
          onUserJoinedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'elapsed': elapsed,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUserJoined'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUserJoinedCompleter.isCompleted) {
              onUserJoinedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserJoinedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUserOffline',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUserOfflineCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserOffline: (RtcConnection connection, int remoteUid,
            UserOfflineReasonType reason) {
          onUserOfflineCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const UserOfflineReasonType reason =
            UserOfflineReasonType.userOfflineQuit;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'reason': reason.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUserOffline'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUserOfflineCompleter.isCompleted) {
              onUserOfflineCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserOfflineCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUserMuteAudio',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUserMuteAudioCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserMuteAudio: (RtcConnection connection, int remoteUid, bool muted) {
          onUserMuteAudioCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const bool muted = true;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'muted': muted,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUserMuteAudio'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUserMuteAudioCompleter.isCompleted) {
              onUserMuteAudioCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserMuteAudioCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUserMuteVideo',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUserMuteVideoCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserMuteVideo: (RtcConnection connection, int remoteUid, bool muted) {
          onUserMuteVideoCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const bool muted = true;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'muted': muted,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUserMuteVideo'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUserMuteVideoCompleter.isCompleted) {
              onUserMuteVideoCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserMuteVideoCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUserEnableVideo',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUserEnableVideoCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserEnableVideo:
            (RtcConnection connection, int remoteUid, bool enabled) {
          onUserEnableVideoCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const bool enabled = true;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'enabled': enabled,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUserEnableVideo'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUserEnableVideoCompleter.isCompleted) {
              onUserEnableVideoCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserEnableVideoCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUserStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUserStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserStateChanged:
            (RtcConnection connection, int remoteUid, int state) {
          onUserStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int state = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'state': state,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUserStateChanged'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUserStateChangedCompleter.isCompleted) {
              onUserStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUserEnableLocalVideo',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUserEnableLocalVideoCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserEnableLocalVideo:
            (RtcConnection connection, int remoteUid, bool enabled) {
          onUserEnableLocalVideoCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const bool enabled = true;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'enabled': enabled,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUserEnableLocalVideo'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUserEnableLocalVideoCompleter.isCompleted) {
              onUserEnableLocalVideoCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserEnableLocalVideoCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLocalAudioStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLocalAudioStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalAudioStats: (RtcConnection connection, LocalAudioStats stats) {
          onLocalAudioStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int statsNumChannels = 10;
        const int statsSentSampleRate = 10;
        const int statsSentBitrate = 10;
        const int statsInternalCodec = 10;
        const int statsTxPacketLossRate = 10;
        const int statsAudioDeviceDelay = 10;
        const LocalAudioStats stats = LocalAudioStats(
          numChannels: statsNumChannels,
          sentSampleRate: statsSentSampleRate,
          sentBitrate: statsSentBitrate,
          internalCodec: statsInternalCodec,
          txPacketLossRate: statsTxPacketLossRate,
          audioDeviceDelay: statsAudioDeviceDelay,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onLocalAudioStats'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLocalAudioStatsCompleter.isCompleted) {
              onLocalAudioStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalAudioStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRemoteAudioStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRemoteAudioStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteAudioStats: (RtcConnection connection, RemoteAudioStats stats) {
          onRemoteAudioStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int statsUid = 10;
        const int statsQuality = 10;
        const int statsNetworkTransportDelay = 10;
        const int statsJitterBufferDelay = 10;
        const int statsAudioLossRate = 10;
        const int statsNumChannels = 10;
        const int statsReceivedSampleRate = 10;
        const int statsReceivedBitrate = 10;
        const int statsTotalFrozenTime = 10;
        const int statsFrozenRate = 10;
        const int statsMosValue = 10;
        const int statsFrozenRateByCustomPlcCount = 10;
        const int statsPlcCount = 10;
        const int statsTotalActiveTime = 10;
        const int statsPublishDuration = 10;
        const int statsQoeQuality = 10;
        const int statsQualityChangedReason = 10;
        const int statsRxAudioBytes = 10;
        const RemoteAudioStats stats = RemoteAudioStats(
          uid: statsUid,
          quality: statsQuality,
          networkTransportDelay: statsNetworkTransportDelay,
          jitterBufferDelay: statsJitterBufferDelay,
          audioLossRate: statsAudioLossRate,
          numChannels: statsNumChannels,
          receivedSampleRate: statsReceivedSampleRate,
          receivedBitrate: statsReceivedBitrate,
          totalFrozenTime: statsTotalFrozenTime,
          frozenRate: statsFrozenRate,
          mosValue: statsMosValue,
          frozenRateByCustomPlcCount: statsFrozenRateByCustomPlcCount,
          plcCount: statsPlcCount,
          totalActiveTime: statsTotalActiveTime,
          publishDuration: statsPublishDuration,
          qoeQuality: statsQoeQuality,
          qualityChangedReason: statsQualityChangedReason,
          rxAudioBytes: statsRxAudioBytes,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onRemoteAudioStats'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoteAudioStatsCompleter.isCompleted) {
              onRemoteAudioStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteAudioStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLocalVideoStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLocalVideoStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalVideoStats: (VideoSourceType source, LocalVideoStats stats) {
          onLocalVideoStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const QualityAdaptIndication statsQualityAdaptIndication =
            QualityAdaptIndication.adaptNone;
        const VideoCodecType statsCodecType = VideoCodecType.videoCodecNone;
        const CaptureBrightnessLevelType statsCaptureBrightnessLevel =
            CaptureBrightnessLevelType.captureBrightnessLevelInvalid;
        const int statsUid = 10;
        const int statsSentBitrate = 10;
        const int statsSentFrameRate = 10;
        const int statsCaptureFrameRate = 10;
        const int statsCaptureFrameWidth = 10;
        const int statsCaptureFrameHeight = 10;
        const int statsRegulatedCaptureFrameRate = 10;
        const int statsRegulatedCaptureFrameWidth = 10;
        const int statsRegulatedCaptureFrameHeight = 10;
        const int statsEncoderOutputFrameRate = 10;
        const int statsEncodedFrameWidth = 10;
        const int statsEncodedFrameHeight = 10;
        const int statsRendererOutputFrameRate = 10;
        const int statsTargetBitrate = 10;
        const int statsTargetFrameRate = 10;
        const int statsEncodedBitrate = 10;
        const int statsEncodedFrameCount = 10;
        const int statsTxPacketLossRate = 10;
        const bool statsDualStreamEnabled = true;
        const int statsHwEncoderAccelerating = 10;
        const LocalVideoStats stats = LocalVideoStats(
          uid: statsUid,
          sentBitrate: statsSentBitrate,
          sentFrameRate: statsSentFrameRate,
          captureFrameRate: statsCaptureFrameRate,
          captureFrameWidth: statsCaptureFrameWidth,
          captureFrameHeight: statsCaptureFrameHeight,
          regulatedCaptureFrameRate: statsRegulatedCaptureFrameRate,
          regulatedCaptureFrameWidth: statsRegulatedCaptureFrameWidth,
          regulatedCaptureFrameHeight: statsRegulatedCaptureFrameHeight,
          encoderOutputFrameRate: statsEncoderOutputFrameRate,
          encodedFrameWidth: statsEncodedFrameWidth,
          encodedFrameHeight: statsEncodedFrameHeight,
          rendererOutputFrameRate: statsRendererOutputFrameRate,
          targetBitrate: statsTargetBitrate,
          targetFrameRate: statsTargetFrameRate,
          qualityAdaptIndication: statsQualityAdaptIndication,
          encodedBitrate: statsEncodedBitrate,
          encodedFrameCount: statsEncodedFrameCount,
          codecType: statsCodecType,
          txPacketLossRate: statsTxPacketLossRate,
          captureBrightnessLevel: statsCaptureBrightnessLevel,
          dualStreamEnabled: statsDualStreamEnabled,
          hwEncoderAccelerating: statsHwEncoderAccelerating,
        );

        final eventJson = {
          'source': source.value(),
          'stats': stats.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onLocalVideoStats'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLocalVideoStatsCompleter.isCompleted) {
              onLocalVideoStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalVideoStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRemoteVideoStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRemoteVideoStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteVideoStats: (RtcConnection connection, RemoteVideoStats stats) {
          onRemoteVideoStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const VideoStreamType statsRxStreamType =
            VideoStreamType.videoStreamHigh;
        const int statsUid = 10;
        const int statsDelay = 10;
        const int statsE2eDelay = 10;
        const int statsWidth = 10;
        const int statsHeight = 10;
        const int statsReceivedBitrate = 10;
        const int statsDecoderOutputFrameRate = 10;
        const int statsRendererOutputFrameRate = 10;
        const int statsFrameLossRate = 10;
        const int statsPacketLossRate = 10;
        const int statsTotalFrozenTime = 10;
        const int statsFrozenRate = 10;
        const int statsAvSyncTimeMs = 10;
        const int statsTotalActiveTime = 10;
        const int statsPublishDuration = 10;
        const int statsMosValue = 10;
        const int statsRxVideoBytes = 10;
        const RemoteVideoStats stats = RemoteVideoStats(
          uid: statsUid,
          delay: statsDelay,
          e2eDelay: statsE2eDelay,
          width: statsWidth,
          height: statsHeight,
          receivedBitrate: statsReceivedBitrate,
          decoderOutputFrameRate: statsDecoderOutputFrameRate,
          rendererOutputFrameRate: statsRendererOutputFrameRate,
          frameLossRate: statsFrameLossRate,
          packetLossRate: statsPacketLossRate,
          rxStreamType: statsRxStreamType,
          totalFrozenTime: statsTotalFrozenTime,
          frozenRate: statsFrozenRate,
          avSyncTimeMs: statsAvSyncTimeMs,
          totalActiveTime: statsTotalActiveTime,
          publishDuration: statsPublishDuration,
          mosValue: statsMosValue,
          rxVideoBytes: statsRxVideoBytes,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onRemoteVideoStats'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoteVideoStatsCompleter.isCompleted) {
              onRemoteVideoStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteVideoStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onCameraReady',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onCameraReadyCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onCameraReady: () {
          onCameraReadyCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onCameraReady'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onCameraReadyCompleter.isCompleted) {
              onCameraReadyCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onCameraReadyCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onCameraFocusAreaChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onCameraFocusAreaChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onCameraFocusAreaChanged: (int x, int y, int width, int height) {
          onCameraFocusAreaChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int x = 10;
        const int y = 10;
        const int width = 10;
        const int height = 10;

        final eventJson = {
          'x': x,
          'y': y,
          'width': width,
          'height': height,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onCameraFocusAreaChanged'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onCameraFocusAreaChangedCompleter.isCompleted) {
              onCameraFocusAreaChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onCameraFocusAreaChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onCameraExposureAreaChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onCameraExposureAreaChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onCameraExposureAreaChanged: (int x, int y, int width, int height) {
          onCameraExposureAreaChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int x = 10;
        const int y = 10;
        const int width = 10;
        const int height = 10;

        final eventJson = {
          'x': x,
          'y': y,
          'width': width,
          'height': height,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onCameraExposureAreaChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onCameraExposureAreaChangedCompleter.isCompleted) {
              onCameraExposureAreaChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onCameraExposureAreaChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onVideoStopped',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onVideoStoppedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoStopped: () {
          onVideoStoppedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onVideoStopped'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onVideoStoppedCompleter.isCompleted) {
              onVideoStoppedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoStoppedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioMixingStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioMixingStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioMixingStateChanged:
            (AudioMixingStateType state, AudioMixingReasonType reason) {
          onAudioMixingStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const AudioMixingStateType state =
            AudioMixingStateType.audioMixingStatePlaying;
        const AudioMixingReasonType reason =
            AudioMixingReasonType.audioMixingReasonCanNotOpen;

        final eventJson = {
          'state': state.value(),
          'reason': reason.value(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onAudioMixingStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioMixingStateChangedCompleter.isCompleted) {
              onAudioMixingStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioMixingStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRhythmPlayerStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRhythmPlayerStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRhythmPlayerStateChanged:
            (RhythmPlayerStateType state, RhythmPlayerErrorType errorCode) {
          onRhythmPlayerStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const RhythmPlayerStateType state =
            RhythmPlayerStateType.rhythmPlayerStateIdle;
        const RhythmPlayerErrorType errorCode =
            RhythmPlayerErrorType.rhythmPlayerErrorOk;

        final eventJson = {
          'state': state.value(),
          'errorCode': errorCode.value(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onRhythmPlayerStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRhythmPlayerStateChangedCompleter.isCompleted) {
              onRhythmPlayerStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRhythmPlayerStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onConnectionLost',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onConnectionLostCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onConnectionLost: (RtcConnection connection) {
          onConnectionLostCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onConnectionLost'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onConnectionLostCompleter.isCompleted) {
              onConnectionLostCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onConnectionLostCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onConnectionInterrupted',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onConnectionInterruptedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onConnectionInterrupted: (RtcConnection connection) {
          onConnectionInterruptedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onConnectionInterrupted'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onConnectionInterruptedCompleter.isCompleted) {
              onConnectionInterruptedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onConnectionInterruptedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onConnectionBanned',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onConnectionBannedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onConnectionBanned: (RtcConnection connection) {
          onConnectionBannedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onConnectionBanned'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onConnectionBannedCompleter.isCompleted) {
              onConnectionBannedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onConnectionBannedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onStreamMessage',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onStreamMessageCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onStreamMessage: (RtcConnection connection, int remoteUid, int streamId,
            Uint8List data, int length, int sentTs) {
          onStreamMessageCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int streamId = 10;
        Uint8List data = Uint8List.fromList([1, 2, 3, 4, 5]);
        const int length = 10;
        const int sentTs = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'streamId': streamId,
          'data': data.toList(),
          'length': length,
          'sentTs': sentTs,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onStreamMessage'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onStreamMessageCompleter.isCompleted) {
              onStreamMessageCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onStreamMessageCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onStreamMessageError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onStreamMessageErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onStreamMessageError: (RtcConnection connection, int remoteUid,
            int streamId, ErrorCodeType code, int missed, int cached) {
          onStreamMessageErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int streamId = 10;
        const ErrorCodeType code = ErrorCodeType.errOk;
        const int missed = 10;
        const int cached = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'streamId': streamId,
          'code': code.value(),
          'missed': missed,
          'cached': cached,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onStreamMessageError'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onStreamMessageErrorCompleter.isCompleted) {
              onStreamMessageErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onStreamMessageErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRdtMessage',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRdtMessageCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRdtMessage: (RtcConnection connection, int userId, RdtStreamType type,
            Uint8List data, int length) {
          onRdtMessageCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int userId = 10;
        const RdtStreamType type = RdtStreamType.rdtStreamCmd;
        Uint8List data = Uint8List.fromList([1, 2, 3, 4, 5]);
        const int length = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'userId': userId,
          'type': type.value(),
          'data': data.toList(),
          'length': length,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onRdtMessage'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRdtMessageCompleter.isCompleted) {
              onRdtMessageCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRdtMessageCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRdtStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRdtStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRdtStateChanged:
            (RtcConnection connection, int userId, RdtState state) {
          onRdtStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int userId = 10;
        const RdtState state = RdtState.rdtStateClosed;

        final eventJson = {
          'connection': connection.toJson(),
          'userId': userId,
          'state': state.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onRdtStateChanged'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRdtStateChangedCompleter.isCompleted) {
              onRdtStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRdtStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onMediaControlMessage',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onMediaControlMessageCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onMediaControlMessage:
            (RtcConnection connection, int userId, Uint8List data, int length) {
          onMediaControlMessageCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int userId = 10;
        Uint8List data = Uint8List.fromList([1, 2, 3, 4, 5]);
        const int length = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'userId': userId,
          'data': data.toList(),
          'length': length,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onMediaControlMessage'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onMediaControlMessageCompleter.isCompleted) {
              onMediaControlMessageCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onMediaControlMessageCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRequestToken',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRequestTokenCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRequestToken: (RtcConnection connection) {
          onRequestTokenCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onRequestToken'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRequestTokenCompleter.isCompleted) {
              onRequestTokenCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRequestTokenCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onTokenPrivilegeWillExpire',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onTokenPrivilegeWillExpireCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onTokenPrivilegeWillExpire: (RtcConnection connection, String token) {
          onTokenPrivilegeWillExpireCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const String token = "hello";

        final eventJson = {
          'connection': connection.toJson(),
          'token': token,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onTokenPrivilegeWillExpire'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onTokenPrivilegeWillExpireCompleter.isCompleted) {
              onTokenPrivilegeWillExpireCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onTokenPrivilegeWillExpireCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLicenseValidationFailure',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLicenseValidationFailureCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLicenseValidationFailure:
            (RtcConnection connection, LicenseErrorType reason) {
          onLicenseValidationFailureCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const LicenseErrorType reason = LicenseErrorType.licenseErrInvalid;

        final eventJson = {
          'connection': connection.toJson(),
          'reason': reason.value(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onLicenseValidationFailure'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLicenseValidationFailureCompleter.isCompleted) {
              onLicenseValidationFailureCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLicenseValidationFailureCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onFirstLocalAudioFramePublished',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onFirstLocalAudioFramePublishedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstLocalAudioFramePublished:
            (RtcConnection connection, int elapsed) {
          onFirstLocalAudioFramePublishedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'elapsed': elapsed,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onFirstLocalAudioFramePublished'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onFirstLocalAudioFramePublishedCompleter.isCompleted) {
              onFirstLocalAudioFramePublishedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstLocalAudioFramePublishedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onFirstRemoteAudioFrame',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onFirstRemoteAudioFrameCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstRemoteAudioFrame:
            (RtcConnection connection, int userId, int elapsed) {
          onFirstRemoteAudioFrameCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int userId = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'userId': userId,
          'elapsed': elapsed,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onFirstRemoteAudioFrame'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onFirstRemoteAudioFrameCompleter.isCompleted) {
              onFirstRemoteAudioFrameCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstRemoteAudioFrameCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onFirstRemoteAudioDecoded',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onFirstRemoteAudioDecodedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstRemoteAudioDecoded:
            (RtcConnection connection, int uid, int elapsed) {
          onFirstRemoteAudioDecodedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int uid = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'uid': uid,
          'elapsed': elapsed,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onFirstRemoteAudioDecoded'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onFirstRemoteAudioDecodedCompleter.isCompleted) {
              onFirstRemoteAudioDecodedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstRemoteAudioDecodedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLocalAudioStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLocalAudioStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalAudioStateChanged: (RtcConnection connection,
            LocalAudioStreamState state, LocalAudioStreamError error) {
          onLocalAudioStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const LocalAudioStreamState state =
            LocalAudioStreamState.localAudioStreamStateStopped;
        const LocalAudioStreamError error =
            LocalAudioStreamError.localAudioStreamErrorOk;

        final eventJson = {
          'connection': connection.toJson(),
          'state': state.value(),
          'error': error.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onLocalAudioStateChanged'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLocalAudioStateChangedCompleter.isCompleted) {
              onLocalAudioStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalAudioStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRemoteAudioStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRemoteAudioStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteAudioStateChanged: (RtcConnection connection,
            int remoteUid,
            RemoteAudioState state,
            RemoteAudioStateReason reason,
            int elapsed) {
          onRemoteAudioStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const RemoteAudioState state = RemoteAudioState.remoteAudioStateStopped;
        const RemoteAudioStateReason reason =
            RemoteAudioStateReason.remoteAudioReasonInternal;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'state': state.value(),
          'reason': reason.value(),
          'elapsed': elapsed,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onRemoteAudioStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoteAudioStateChangedCompleter.isCompleted) {
              onRemoteAudioStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteAudioStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onActiveSpeaker',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onActiveSpeakerCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onActiveSpeaker: (RtcConnection connection, int uid) {
          onActiveSpeakerCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int uid = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'uid': uid,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onActiveSpeaker'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onActiveSpeakerCompleter.isCompleted) {
              onActiveSpeakerCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onActiveSpeakerCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onContentInspectResult',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onContentInspectResultCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onContentInspectResult: (ContentInspectResult result) {
          onContentInspectResultCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const ContentInspectResult result =
            ContentInspectResult.contentInspectNeutral;

        final eventJson = {
          'result': result.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onContentInspectResult'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onContentInspectResultCompleter.isCompleted) {
              onContentInspectResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onContentInspectResultCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onSnapshotTaken',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onSnapshotTakenCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onSnapshotTaken: (RtcConnection connection, int uid, String filePath,
            int width, int height, int errCode) {
          onSnapshotTakenCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int uid = 10;
        const String filePath = "hello";
        const int width = 10;
        const int height = 10;
        const int errCode = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'uid': uid,
          'filePath': filePath,
          'width': width,
          'height': height,
          'errCode': errCode,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onSnapshotTaken'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onSnapshotTakenCompleter.isCompleted) {
              onSnapshotTakenCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onSnapshotTakenCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onClientRoleChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onClientRoleChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onClientRoleChanged: (RtcConnection connection, ClientRoleType oldRole,
            ClientRoleType newRole, ClientRoleOptions newRoleOptions) {
          onClientRoleChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const ClientRoleType oldRole = ClientRoleType.clientRoleBroadcaster;
        const ClientRoleType newRole = ClientRoleType.clientRoleBroadcaster;
        const AudienceLatencyLevelType newRoleOptionsAudienceLatencyLevel =
            AudienceLatencyLevelType.audienceLatencyLevelLowLatency;
        const ClientRoleOptions newRoleOptions = ClientRoleOptions(
          audienceLatencyLevel: newRoleOptionsAudienceLatencyLevel,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'oldRole': oldRole.value(),
          'newRole': newRole.value(),
          'newRoleOptions': newRoleOptions.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onClientRoleChanged'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onClientRoleChangedCompleter.isCompleted) {
              onClientRoleChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onClientRoleChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onClientRoleChangeFailed',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onClientRoleChangeFailedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onClientRoleChangeFailed: (RtcConnection connection,
            ClientRoleChangeFailedReason reason, ClientRoleType currentRole) {
          onClientRoleChangeFailedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const ClientRoleChangeFailedReason reason = ClientRoleChangeFailedReason
            .clientRoleChangeFailedTooManyBroadcasters;
        const ClientRoleType currentRole = ClientRoleType.clientRoleBroadcaster;

        final eventJson = {
          'connection': connection.toJson(),
          'reason': reason.value(),
          'currentRole': currentRole.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onClientRoleChangeFailed'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onClientRoleChangeFailedCompleter.isCompleted) {
              onClientRoleChangeFailedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onClientRoleChangeFailedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioDeviceVolumeChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioDeviceVolumeChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioDeviceVolumeChanged:
            (MediaDeviceType deviceType, int volume, bool muted) {
          onAudioDeviceVolumeChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const MediaDeviceType deviceType = MediaDeviceType.unknownAudioDevice;
        const int volume = 10;
        const bool muted = true;

        final eventJson = {
          'deviceType': deviceType.value(),
          'volume': volume,
          'muted': muted,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onAudioDeviceVolumeChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioDeviceVolumeChangedCompleter.isCompleted) {
              onAudioDeviceVolumeChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioDeviceVolumeChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRtmpStreamingStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRtmpStreamingStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRtmpStreamingStateChanged: (String url, RtmpStreamPublishState state,
            RtmpStreamPublishErrorType errCode) {
          onRtmpStreamingStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String url = "hello";
        const RtmpStreamPublishState state =
            RtmpStreamPublishState.rtmpStreamPublishStateIdle;
        const RtmpStreamPublishErrorType errCode =
            RtmpStreamPublishErrorType.rtmpStreamPublishErrorOk;

        final eventJson = {
          'url': url,
          'state': state.value(),
          'errCode': errCode.value(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onRtmpStreamingStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRtmpStreamingStateChangedCompleter.isCompleted) {
              onRtmpStreamingStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRtmpStreamingStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRtmpStreamingEvent',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRtmpStreamingEventCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRtmpStreamingEvent: (String url, RtmpStreamingEvent eventCode) {
          onRtmpStreamingEventCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String url = "hello";
        const RtmpStreamingEvent eventCode =
            RtmpStreamingEvent.rtmpStreamingEventFailedLoadImage;

        final eventJson = {
          'url': url,
          'eventCode': eventCode.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onRtmpStreamingEvent'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRtmpStreamingEventCompleter.isCompleted) {
              onRtmpStreamingEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRtmpStreamingEventCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onTranscodingUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onTranscodingUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onTranscodingUpdated: () {
          onTranscodingUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        final eventJson = {};

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onTranscodingUpdated'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onTranscodingUpdatedCompleter.isCompleted) {
              onTranscodingUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onTranscodingUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioRoutingChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioRoutingChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioRoutingChanged: (int deviceType, int routing) {
          onAudioRoutingChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int deviceType = 10;
        const int routing = 10;

        final eventJson = {
          'deviceType': deviceType,
          'routing': routing,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onAudioRoutingChanged'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioRoutingChangedCompleter.isCompleted) {
              onAudioRoutingChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioRoutingChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onChannelMediaRelayStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onChannelMediaRelayStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onChannelMediaRelayStateChanged:
            (ChannelMediaRelayState state, ChannelMediaRelayError code) {
          onChannelMediaRelayStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const ChannelMediaRelayState state =
            ChannelMediaRelayState.relayStateIdle;
        const ChannelMediaRelayError code = ChannelMediaRelayError.relayOk;

        final eventJson = {
          'state': state.value(),
          'code': code.value(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onChannelMediaRelayStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onChannelMediaRelayStateChangedCompleter.isCompleted) {
              onChannelMediaRelayStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onChannelMediaRelayStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onChannelMediaRelayEvent',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onChannelMediaRelayEventCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onChannelMediaRelayEvent: (int code) {
          onChannelMediaRelayEventCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int code = 10;

        final eventJson = {
          'code': code,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onChannelMediaRelayEvent'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onChannelMediaRelayEventCompleter.isCompleted) {
              onChannelMediaRelayEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onChannelMediaRelayEventCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLocalPublishFallbackToAudioOnly',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLocalPublishFallbackToAudioOnlyCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalPublishFallbackToAudioOnly: (bool isFallbackOrRecover) {
          onLocalPublishFallbackToAudioOnlyCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const bool isFallbackOrRecover = true;

        final eventJson = {
          'isFallbackOrRecover': isFallbackOrRecover,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onLocalPublishFallbackToAudioOnly'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLocalPublishFallbackToAudioOnlyCompleter.isCompleted) {
              onLocalPublishFallbackToAudioOnlyCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled =
          await onLocalPublishFallbackToAudioOnlyCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRemoteSubscribeFallbackToAudioOnly',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRemoteSubscribeFallbackToAudioOnlyCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteSubscribeFallbackToAudioOnly:
            (int uid, bool isFallbackOrRecover) {
          onRemoteSubscribeFallbackToAudioOnlyCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int uid = 10;
        const bool isFallbackOrRecover = true;

        final eventJson = {
          'uid': uid,
          'isFallbackOrRecover': isFallbackOrRecover,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onRemoteSubscribeFallbackToAudioOnly'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoteSubscribeFallbackToAudioOnlyCompleter.isCompleted) {
              onRemoteSubscribeFallbackToAudioOnlyCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled =
          await onRemoteSubscribeFallbackToAudioOnlyCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRemoteAudioTransportStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRemoteAudioTransportStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteAudioTransportStats: (RtcConnection connection, int remoteUid,
            int delay, int lost, int rxKBitRate) {
          onRemoteAudioTransportStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int delay = 10;
        const int lost = 10;
        const int rxKBitRate = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'delay': delay,
          'lost': lost,
          'rxKBitRate': rxKBitRate,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onRemoteAudioTransportStats'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoteAudioTransportStatsCompleter.isCompleted) {
              onRemoteAudioTransportStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteAudioTransportStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onRemoteVideoTransportStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onRemoteVideoTransportStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteVideoTransportStats: (RtcConnection connection, int remoteUid,
            int delay, int lost, int rxKBitRate) {
          onRemoteVideoTransportStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int delay = 10;
        const int lost = 10;
        const int rxKBitRate = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'delay': delay,
          'lost': lost,
          'rxKBitRate': rxKBitRate,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onRemoteVideoTransportStats'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onRemoteVideoTransportStatsCompleter.isCompleted) {
              onRemoteVideoTransportStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteVideoTransportStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onConnectionStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onConnectionStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onConnectionStateChanged: (RtcConnection connection,
            ConnectionStateType state, ConnectionChangedReasonType reason) {
          onConnectionStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const ConnectionStateType state =
            ConnectionStateType.connectionStateDisconnected;
        const ConnectionChangedReasonType reason =
            ConnectionChangedReasonType.connectionChangedConnecting;

        final eventJson = {
          'connection': connection.toJson(),
          'state': state.value(),
          'reason': reason.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onConnectionStateChanged'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onConnectionStateChangedCompleter.isCompleted) {
              onConnectionStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onConnectionStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onWlAccMessage',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onWlAccMessageCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onWlAccMessage: (RtcConnection connection, WlaccMessageReason reason,
            WlaccSuggestAction action, String wlAccMsg) {
          onWlAccMessageCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const WlaccMessageReason reason =
            WlaccMessageReason.wlaccMessageReasonWeakSignal;
        const WlaccSuggestAction action =
            WlaccSuggestAction.wlaccSuggestActionCloseToWifi;
        const String wlAccMsg = "hello";

        final eventJson = {
          'connection': connection.toJson(),
          'reason': reason.value(),
          'action': action.value(),
          'wlAccMsg': wlAccMsg,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onWlAccMessage'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onWlAccMessageCompleter.isCompleted) {
              onWlAccMessageCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onWlAccMessageCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onWlAccStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onWlAccStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onWlAccStats: (RtcConnection connection, WlAccStats currentStats,
            WlAccStats averageStats) {
          onWlAccStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int currentStatsE2eDelayPercent = 10;
        const int currentStatsFrozenRatioPercent = 10;
        const int currentStatsLossRatePercent = 10;
        const WlAccStats currentStats = WlAccStats(
          e2eDelayPercent: currentStatsE2eDelayPercent,
          frozenRatioPercent: currentStatsFrozenRatioPercent,
          lossRatePercent: currentStatsLossRatePercent,
        );
        const int averageStatsE2eDelayPercent = 10;
        const int averageStatsFrozenRatioPercent = 10;
        const int averageStatsLossRatePercent = 10;
        const WlAccStats averageStats = WlAccStats(
          e2eDelayPercent: averageStatsE2eDelayPercent,
          frozenRatioPercent: averageStatsFrozenRatioPercent,
          lossRatePercent: averageStatsLossRatePercent,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'currentStats': currentStats.toJson(),
          'averageStats': averageStats.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onWlAccStats'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onWlAccStatsCompleter.isCompleted) {
              onWlAccStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onWlAccStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onNetworkTypeChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onNetworkTypeChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onNetworkTypeChanged: (RtcConnection connection, NetworkType type) {
          onNetworkTypeChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const NetworkType type = NetworkType.networkTypeUnknown;

        final eventJson = {
          'connection': connection.toJson(),
          'type': type.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onNetworkTypeChanged'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onNetworkTypeChangedCompleter.isCompleted) {
              onNetworkTypeChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onNetworkTypeChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onEncryptionError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onEncryptionErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onEncryptionError:
            (RtcConnection connection, EncryptionErrorType errorType) {
          onEncryptionErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const EncryptionErrorType errorType =
            EncryptionErrorType.encryptionErrorInternalFailure;

        final eventJson = {
          'connection': connection.toJson(),
          'errorType': errorType.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onEncryptionError'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onEncryptionErrorCompleter.isCompleted) {
              onEncryptionErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onEncryptionErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onPermissionError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onPermissionErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onPermissionError: (PermissionType permissionType) {
          onPermissionErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const PermissionType permissionType = PermissionType.recordAudio;

        final eventJson = {
          'permissionType': permissionType.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onPermissionError'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onPermissionErrorCompleter.isCompleted) {
              onPermissionErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onPermissionErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLocalUserRegistered',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLocalUserRegisteredCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalUserRegistered: (int uid, String userAccount) {
          onLocalUserRegisteredCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int uid = 10;
        const String userAccount = "hello";

        final eventJson = {
          'uid': uid,
          'userAccount': userAccount,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onLocalUserRegistered'] ??
                [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLocalUserRegisteredCompleter.isCompleted) {
              onLocalUserRegisteredCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalUserRegisteredCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUserInfoUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUserInfoUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserInfoUpdated: (int uid, UserInfo info) {
          onUserInfoUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int uid = 10;
        const int infoUid = 10;
        const String infoUserAccount = "hello";
        const UserInfo info = UserInfo(
          uid: infoUid,
          userAccount: infoUserAccount,
        );

        final eventJson = {
          'uid': uid,
          'info': info.toJson(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUserInfoUpdated'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUserInfoUpdatedCompleter.isCompleted) {
              onUserInfoUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserInfoUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUploadLogResult',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUploadLogResultCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUploadLogResult: (RtcConnection connection, String requestId,
            bool success, UploadErrorReason reason) {
          onUploadLogResultCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const String requestId = "hello";
        const bool success = true;
        const UploadErrorReason reason = UploadErrorReason.uploadSuccess;

        final eventJson = {
          'connection': connection.toJson(),
          'requestId': requestId,
          'success': success,
          'reason': reason.value(),
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUploadLogResult'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUploadLogResultCompleter.isCompleted) {
              onUploadLogResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUploadLogResultCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioSubscribeStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioSubscribeStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioSubscribeStateChanged: (String channel,
            int uid,
            StreamSubscribeState oldState,
            StreamSubscribeState newState,
            int elapseSinceLastState) {
          onAudioSubscribeStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String channel = "hello";
        const int uid = 10;
        const StreamSubscribeState oldState = StreamSubscribeState.subStateIdle;
        const StreamSubscribeState newState = StreamSubscribeState.subStateIdle;
        const int elapseSinceLastState = 10;

        final eventJson = {
          'channel': channel,
          'uid': uid,
          'oldState': oldState.value(),
          'newState': newState.value(),
          'elapseSinceLastState': elapseSinceLastState,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onAudioSubscribeStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioSubscribeStateChangedCompleter.isCompleted) {
              onAudioSubscribeStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioSubscribeStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onVideoSubscribeStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onVideoSubscribeStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoSubscribeStateChanged: (String channel,
            int uid,
            StreamSubscribeState oldState,
            StreamSubscribeState newState,
            int elapseSinceLastState) {
          onVideoSubscribeStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String channel = "hello";
        const int uid = 10;
        const StreamSubscribeState oldState = StreamSubscribeState.subStateIdle;
        const StreamSubscribeState newState = StreamSubscribeState.subStateIdle;
        const int elapseSinceLastState = 10;

        final eventJson = {
          'channel': channel,
          'uid': uid,
          'oldState': oldState.value(),
          'newState': newState.value(),
          'elapseSinceLastState': elapseSinceLastState,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onVideoSubscribeStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onVideoSubscribeStateChangedCompleter.isCompleted) {
              onVideoSubscribeStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoSubscribeStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onAudioPublishStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onAudioPublishStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioPublishStateChanged: (String channel,
            StreamPublishState oldState,
            StreamPublishState newState,
            int elapseSinceLastState) {
          onAudioPublishStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String channel = "hello";
        const StreamPublishState oldState = StreamPublishState.pubStateIdle;
        const StreamPublishState newState = StreamPublishState.pubStateIdle;
        const int elapseSinceLastState = 10;

        final eventJson = {
          'channel': channel,
          'oldState': oldState.value(),
          'newState': newState.value(),
          'elapseSinceLastState': elapseSinceLastState,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onAudioPublishStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onAudioPublishStateChangedCompleter.isCompleted) {
              onAudioPublishStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioPublishStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onVideoPublishStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onVideoPublishStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoPublishStateChanged: (VideoSourceType source,
            String channel,
            StreamPublishState oldState,
            StreamPublishState newState,
            int elapseSinceLastState) {
          onVideoPublishStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const String channel = "hello";
        const StreamPublishState oldState = StreamPublishState.pubStateIdle;
        const StreamPublishState newState = StreamPublishState.pubStateIdle;
        const int elapseSinceLastState = 10;

        final eventJson = {
          'source': source.value(),
          'channel': channel,
          'oldState': oldState.value(),
          'newState': newState.value(),
          'elapseSinceLastState': elapseSinceLastState,
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onVideoPublishStateChanged'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onVideoPublishStateChangedCompleter.isCompleted) {
              onVideoPublishStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoPublishStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onExtensionEvent',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onExtensionEventCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onExtensionEvent:
            (String provider, String extension, String key, String value) {
          onExtensionEventCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String provider = "hello";
        const String extension = "hello";
        const String key = "hello";
        const String value = "hello";

        final eventJson = {
          'provider': provider,
          'extension': extension,
          'key': key,
          'value': value,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onExtensionEvent'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onExtensionEventCompleter.isCompleted) {
              onExtensionEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onExtensionEventCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onExtensionStarted',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onExtensionStartedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onExtensionStarted: (String provider, String extension) {
          onExtensionStartedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String provider = "hello";
        const String extension = "hello";

        final eventJson = {
          'provider': provider,
          'extension': extension,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onExtensionStarted'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onExtensionStartedCompleter.isCompleted) {
              onExtensionStartedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onExtensionStartedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onExtensionStopped',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onExtensionStoppedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onExtensionStopped: (String provider, String extension) {
          onExtensionStoppedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String provider = "hello";
        const String extension = "hello";

        final eventJson = {
          'provider': provider,
          'extension': extension,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onExtensionStopped'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onExtensionStoppedCompleter.isCompleted) {
              onExtensionStoppedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onExtensionStoppedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onExtensionError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onExtensionErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onExtensionError:
            (String provider, String extension, int error, String message) {
          onExtensionErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String provider = "hello";
        const String extension = "hello";
        const int error = 10;
        const String message = "hello";

        final eventJson = {
          'provider': provider,
          'extension': extension,
          'error': error,
          'message': message,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onExtensionError'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onExtensionErrorCompleter.isCompleted) {
              onExtensionErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onExtensionErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onUserAccountUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onUserAccountUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserAccountUpdated:
            (RtcConnection connection, int remoteUid, String userAccount) {
          onUserAccountUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const String userAccount = "hello";

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'userAccount': userAccount,
        };

        final eventIds =
            eventIdsMapping['RtcEngineEventHandler_onUserAccountUpdated'] ?? [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onUserAccountUpdatedCompleter.isCompleted) {
              onUserAccountUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserAccountUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onLocalVideoTranscoderError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onLocalVideoTranscoderErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalVideoTranscoderError:
            (TranscodingVideoStream stream, VideoTranscoderError error) {
          onLocalVideoTranscoderErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType streamSourceType =
            VideoSourceType.videoSourceCameraPrimary;
        const int streamRemoteUserUid = 10;
        const String streamImageUrl = "hello";
        const int streamMediaPlayerId = 10;
        const int streamX = 10;
        const int streamY = 10;
        const int streamWidth = 10;
        const int streamHeight = 10;
        const int streamZOrder = 10;
        const double streamAlpha = 10.0;
        const bool streamMirror = true;
        const TranscodingVideoStream stream = TranscodingVideoStream(
          sourceType: streamSourceType,
          remoteUserUid: streamRemoteUserUid,
          imageUrl: streamImageUrl,
          mediaPlayerId: streamMediaPlayerId,
          x: streamX,
          y: streamY,
          width: streamWidth,
          height: streamHeight,
          zOrder: streamZOrder,
          alpha: streamAlpha,
          mirror: streamMirror,
        );
        const VideoTranscoderError error =
            VideoTranscoderError.vtErrVideoSourceNotReady;

        final eventJson = {
          'stream': stream.toJson(),
          'error': error.value(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onLocalVideoTranscoderError'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onLocalVideoTranscoderErrorCompleter.isCompleted) {
              onLocalVideoTranscoderErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalVideoTranscoderErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'RtcEngineEventHandler.onVideoRenderingTracingResult',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      await rtcEngine.setParameters('{"rtc.enable_debug_log": true}');

      final onVideoRenderingTracingResultCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoRenderingTracingResult: (RtcConnection connection,
            int uid,
            MediaTraceEvent currentEvent,
            VideoRenderingTracingInfo tracingInfo) {
          onVideoRenderingTracingResultCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int uid = 10;
        const MediaTraceEvent currentEvent =
            MediaTraceEvent.mediaTraceEventVideoRendered;
        const int tracingInfoElapsedTime = 10;
        const int tracingInfoStart2JoinChannel = 10;
        const int tracingInfoJoin2JoinSuccess = 10;
        const int tracingInfoJoinSuccess2RemoteJoined = 10;
        const int tracingInfoRemoteJoined2SetView = 10;
        const int tracingInfoRemoteJoined2UnmuteVideo = 10;
        const int tracingInfoRemoteJoined2PacketReceived = 10;
        const VideoRenderingTracingInfo tracingInfo = VideoRenderingTracingInfo(
          elapsedTime: tracingInfoElapsedTime,
          start2JoinChannel: tracingInfoStart2JoinChannel,
          join2JoinSuccess: tracingInfoJoin2JoinSuccess,
          joinSuccess2RemoteJoined: tracingInfoJoinSuccess2RemoteJoined,
          remoteJoined2SetView: tracingInfoRemoteJoined2SetView,
          remoteJoined2UnmuteVideo: tracingInfoRemoteJoined2UnmuteVideo,
          remoteJoined2PacketReceived: tracingInfoRemoteJoined2PacketReceived,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'uid': uid,
          'currentEvent': currentEvent.value(),
          'tracingInfo': tracingInfo.toJson(),
        };

        final eventIds = eventIdsMapping[
                'RtcEngineEventHandler_onVideoRenderingTracingResult'] ??
            [];
        for (final event in eventIds) {
          final ret = irisTester().fireEvent(event, params: eventJson);
          // Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
          // TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (kIsWeb && ret) {
            if (!onVideoRenderingTracingResultCompleter.isCompleted) {
              onVideoRenderingTracingResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoRenderingTracingResultCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );
}
