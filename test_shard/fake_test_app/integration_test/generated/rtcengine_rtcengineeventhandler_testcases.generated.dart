/// GENERATED BY testcase_gen. DO NOT MODIFY BY HAND.

// ignore_for_file: deprecated_member_use,constant_identifier_names

import 'dart:async';
import 'dart:typed_data';

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:iris_tester/iris_tester.dart';
import 'package:iris_method_channel/iris_method_channel.dart';

void generatedTestCases(IrisTester irisTester) {
  testWidgets(
    'onJoinChannelSuccess',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onJoinChannelSuccessCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onJoinChannelSuccess: (RtcConnection connection, int elapsed) {
          onJoinChannelSuccessCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onJoinChannelSuccess',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onJoinChannelSuccess',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onJoinChannelSuccessEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onJoinChannelSuccessCompleter.isCompleted) {
              onJoinChannelSuccessCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onJoinChannelSuccessCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRejoinChannelSuccess',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRejoinChannelSuccessCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRejoinChannelSuccess: (RtcConnection connection, int elapsed) {
          onRejoinChannelSuccessCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onRejoinChannelSuccess',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onRejoinChannelSuccess',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRejoinChannelSuccessEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRejoinChannelSuccessCompleter.isCompleted) {
              onRejoinChannelSuccessCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRejoinChannelSuccessCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onProxyConnected',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onProxyConnectedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onProxyConnected: (String channel, int uid, ProxyType proxyType,
            String localProxyIp, int elapsed) {
          onProxyConnectedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String channel = "hello";
        const int uid = 10;
        const ProxyType proxyType = ProxyType.noneProxyType;
        const String localProxyIp = "hello";
        const int elapsed = 10;

        final eventJson = {
          'channel': channel,
          'uid': uid,
          'proxyType': proxyType.value(),
          'localProxyIp': localProxyIp,
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onProxyConnected',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onProxyConnected',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onProxyConnected',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onProxyConnectedCompleter.isCompleted) {
              onProxyConnectedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onProxyConnectedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onError: (ErrorCodeType err, String msg) {
          onErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const ErrorCodeType err = ErrorCodeType.errOk;
        const String msg = "hello";

        final eventJson = {
          'err': err.value(),
          'msg': msg,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onError',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onError',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent('RtcEngineEventHandler_onError',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onErrorCompleter.isCompleted) {
              onErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioQuality',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioQualityCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioQuality: (RtcConnection connection, int remoteUid,
            QualityType quality, int delay, int lost) {
          onAudioQualityCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const QualityType quality = QualityType.qualityUnknown;
        const int delay = 10;
        const int lost = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'quality': quality.value(),
          'delay': delay,
          'lost': lost,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onAudioQuality',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onAudioQuality',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioQualityEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioQualityCompleter.isCompleted) {
              onAudioQualityCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioQualityCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLastmileProbeResult',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLastmileProbeResultCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLastmileProbeResult: (LastmileProbeResult result) {
          onLastmileProbeResultCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const LastmileProbeResultState resultState =
            LastmileProbeResultState.lastmileProbeResultComplete;
        const int uplinkReportPacketLossRate = 10;
        const int uplinkReportJitter = 10;
        const int uplinkReportAvailableBandwidth = 10;
        const LastmileProbeOneWayResult resultUplinkReport =
            LastmileProbeOneWayResult(
          packetLossRate: uplinkReportPacketLossRate,
          jitter: uplinkReportJitter,
          availableBandwidth: uplinkReportAvailableBandwidth,
        );
        const int downlinkReportPacketLossRate = 10;
        const int downlinkReportJitter = 10;
        const int downlinkReportAvailableBandwidth = 10;
        const LastmileProbeOneWayResult resultDownlinkReport =
            LastmileProbeOneWayResult(
          packetLossRate: downlinkReportPacketLossRate,
          jitter: downlinkReportJitter,
          availableBandwidth: downlinkReportAvailableBandwidth,
        );
        const int resultRtt = 10;
        const LastmileProbeResult result = LastmileProbeResult(
          state: resultState,
          uplinkReport: resultUplinkReport,
          downlinkReport: resultDownlinkReport,
          rtt: resultRtt,
        );

        final eventJson = {
          'result': result.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onLastmileProbeResult',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onLastmileProbeResult',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLastmileProbeResult',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLastmileProbeResultCompleter.isCompleted) {
              onLastmileProbeResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLastmileProbeResultCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioVolumeIndication',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioVolumeIndicationCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioVolumeIndication: (RtcConnection connection, List speakers,
            int speakerNumber, int totalVolume) {
          onAudioVolumeIndicationCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const List<AudioVolumeInfo> speakers = [];
        const int speakerNumber = 10;
        const int totalVolume = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'speakers': speakers,
          'speakerNumber': speakerNumber,
          'totalVolume': totalVolume,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onAudioVolumeIndication',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onAudioVolumeIndication',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioVolumeIndicationEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioVolumeIndicationCompleter.isCompleted) {
              onAudioVolumeIndicationCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioVolumeIndicationCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLeaveChannel',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLeaveChannelCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLeaveChannel: (RtcConnection connection, RtcStats stats) {
          onLeaveChannelCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int statsDuration = 10;
        const int statsTxBytes = 10;
        const int statsRxBytes = 10;
        const int statsTxAudioBytes = 10;
        const int statsTxVideoBytes = 10;
        const int statsRxAudioBytes = 10;
        const int statsRxVideoBytes = 10;
        const int statsTxKBitRate = 10;
        const int statsRxKBitRate = 10;
        const int statsRxAudioKBitRate = 10;
        const int statsTxAudioKBitRate = 10;
        const int statsRxVideoKBitRate = 10;
        const int statsTxVideoKBitRate = 10;
        const int statsLastmileDelay = 10;
        const int statsUserCount = 10;
        const double statsCpuAppUsage = 10.0;
        const double statsCpuTotalUsage = 10.0;
        const int statsGatewayRtt = 10;
        const double statsMemoryAppUsageRatio = 10.0;
        const double statsMemoryTotalUsageRatio = 10.0;
        const int statsMemoryAppUsageInKbytes = 10;
        const int statsConnectTimeMs = 10;
        const int statsFirstAudioPacketDuration = 10;
        const int statsFirstVideoPacketDuration = 10;
        const int statsFirstVideoKeyFramePacketDuration = 10;
        const int statsPacketsBeforeFirstKeyFramePacket = 10;
        const int statsFirstAudioPacketDurationAfterUnmute = 10;
        const int statsFirstVideoPacketDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFramePacketDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFrameDecodedDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFrameRenderedDurationAfterUnmute = 10;
        const int statsTxPacketLossRate = 10;
        const int statsRxPacketLossRate = 10;
        const RtcStats stats = RtcStats(
          duration: statsDuration,
          txBytes: statsTxBytes,
          rxBytes: statsRxBytes,
          txAudioBytes: statsTxAudioBytes,
          txVideoBytes: statsTxVideoBytes,
          rxAudioBytes: statsRxAudioBytes,
          rxVideoBytes: statsRxVideoBytes,
          txKBitRate: statsTxKBitRate,
          rxKBitRate: statsRxKBitRate,
          rxAudioKBitRate: statsRxAudioKBitRate,
          txAudioKBitRate: statsTxAudioKBitRate,
          rxVideoKBitRate: statsRxVideoKBitRate,
          txVideoKBitRate: statsTxVideoKBitRate,
          lastmileDelay: statsLastmileDelay,
          userCount: statsUserCount,
          cpuAppUsage: statsCpuAppUsage,
          cpuTotalUsage: statsCpuTotalUsage,
          gatewayRtt: statsGatewayRtt,
          memoryAppUsageRatio: statsMemoryAppUsageRatio,
          memoryTotalUsageRatio: statsMemoryTotalUsageRatio,
          memoryAppUsageInKbytes: statsMemoryAppUsageInKbytes,
          connectTimeMs: statsConnectTimeMs,
          firstAudioPacketDuration: statsFirstAudioPacketDuration,
          firstVideoPacketDuration: statsFirstVideoPacketDuration,
          firstVideoKeyFramePacketDuration:
              statsFirstVideoKeyFramePacketDuration,
          packetsBeforeFirstKeyFramePacket:
              statsPacketsBeforeFirstKeyFramePacket,
          firstAudioPacketDurationAfterUnmute:
              statsFirstAudioPacketDurationAfterUnmute,
          firstVideoPacketDurationAfterUnmute:
              statsFirstVideoPacketDurationAfterUnmute,
          firstVideoKeyFramePacketDurationAfterUnmute:
              statsFirstVideoKeyFramePacketDurationAfterUnmute,
          firstVideoKeyFrameDecodedDurationAfterUnmute:
              statsFirstVideoKeyFrameDecodedDurationAfterUnmute,
          firstVideoKeyFrameRenderedDurationAfterUnmute:
              statsFirstVideoKeyFrameRenderedDurationAfterUnmute,
          txPacketLossRate: statsTxPacketLossRate,
          rxPacketLossRate: statsRxPacketLossRate,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onLeaveChannel',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onLeaveChannel',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLeaveChannelEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLeaveChannelCompleter.isCompleted) {
              onLeaveChannelCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLeaveChannelCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRtcStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRtcStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRtcStats: (RtcConnection connection, RtcStats stats) {
          onRtcStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int statsDuration = 10;
        const int statsTxBytes = 10;
        const int statsRxBytes = 10;
        const int statsTxAudioBytes = 10;
        const int statsTxVideoBytes = 10;
        const int statsRxAudioBytes = 10;
        const int statsRxVideoBytes = 10;
        const int statsTxKBitRate = 10;
        const int statsRxKBitRate = 10;
        const int statsRxAudioKBitRate = 10;
        const int statsTxAudioKBitRate = 10;
        const int statsRxVideoKBitRate = 10;
        const int statsTxVideoKBitRate = 10;
        const int statsLastmileDelay = 10;
        const int statsUserCount = 10;
        const double statsCpuAppUsage = 10.0;
        const double statsCpuTotalUsage = 10.0;
        const int statsGatewayRtt = 10;
        const double statsMemoryAppUsageRatio = 10.0;
        const double statsMemoryTotalUsageRatio = 10.0;
        const int statsMemoryAppUsageInKbytes = 10;
        const int statsConnectTimeMs = 10;
        const int statsFirstAudioPacketDuration = 10;
        const int statsFirstVideoPacketDuration = 10;
        const int statsFirstVideoKeyFramePacketDuration = 10;
        const int statsPacketsBeforeFirstKeyFramePacket = 10;
        const int statsFirstAudioPacketDurationAfterUnmute = 10;
        const int statsFirstVideoPacketDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFramePacketDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFrameDecodedDurationAfterUnmute = 10;
        const int statsFirstVideoKeyFrameRenderedDurationAfterUnmute = 10;
        const int statsTxPacketLossRate = 10;
        const int statsRxPacketLossRate = 10;
        const RtcStats stats = RtcStats(
          duration: statsDuration,
          txBytes: statsTxBytes,
          rxBytes: statsRxBytes,
          txAudioBytes: statsTxAudioBytes,
          txVideoBytes: statsTxVideoBytes,
          rxAudioBytes: statsRxAudioBytes,
          rxVideoBytes: statsRxVideoBytes,
          txKBitRate: statsTxKBitRate,
          rxKBitRate: statsRxKBitRate,
          rxAudioKBitRate: statsRxAudioKBitRate,
          txAudioKBitRate: statsTxAudioKBitRate,
          rxVideoKBitRate: statsRxVideoKBitRate,
          txVideoKBitRate: statsTxVideoKBitRate,
          lastmileDelay: statsLastmileDelay,
          userCount: statsUserCount,
          cpuAppUsage: statsCpuAppUsage,
          cpuTotalUsage: statsCpuTotalUsage,
          gatewayRtt: statsGatewayRtt,
          memoryAppUsageRatio: statsMemoryAppUsageRatio,
          memoryTotalUsageRatio: statsMemoryTotalUsageRatio,
          memoryAppUsageInKbytes: statsMemoryAppUsageInKbytes,
          connectTimeMs: statsConnectTimeMs,
          firstAudioPacketDuration: statsFirstAudioPacketDuration,
          firstVideoPacketDuration: statsFirstVideoPacketDuration,
          firstVideoKeyFramePacketDuration:
              statsFirstVideoKeyFramePacketDuration,
          packetsBeforeFirstKeyFramePacket:
              statsPacketsBeforeFirstKeyFramePacket,
          firstAudioPacketDurationAfterUnmute:
              statsFirstAudioPacketDurationAfterUnmute,
          firstVideoPacketDurationAfterUnmute:
              statsFirstVideoPacketDurationAfterUnmute,
          firstVideoKeyFramePacketDurationAfterUnmute:
              statsFirstVideoKeyFramePacketDurationAfterUnmute,
          firstVideoKeyFrameDecodedDurationAfterUnmute:
              statsFirstVideoKeyFrameDecodedDurationAfterUnmute,
          firstVideoKeyFrameRenderedDurationAfterUnmute:
              statsFirstVideoKeyFrameRenderedDurationAfterUnmute,
          txPacketLossRate: statsTxPacketLossRate,
          rxPacketLossRate: statsRxPacketLossRate,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onRtcStats',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onRtcStats',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent('RtcEngineEventHandler_onRtcStatsEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRtcStatsCompleter.isCompleted) {
              onRtcStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRtcStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioDeviceStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioDeviceStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioDeviceStateChanged: (String deviceId, MediaDeviceType deviceType,
            MediaDeviceStateType deviceState) {
          onAudioDeviceStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String deviceId = "hello";
        const MediaDeviceType deviceType = MediaDeviceType.unknownAudioDevice;
        const MediaDeviceStateType deviceState =
            MediaDeviceStateType.mediaDeviceStateIdle;

        final eventJson = {
          'deviceId': deviceId,
          'deviceType': deviceType.value(),
          'deviceState': deviceState.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioDeviceStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onAudioDeviceStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioDeviceStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioDeviceStateChangedCompleter.isCompleted) {
              onAudioDeviceStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioDeviceStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioMixingPositionChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioMixingPositionChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioMixingPositionChanged: (int position) {
          onAudioMixingPositionChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int position = 10;

        final eventJson = {
          'position': position,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioMixingPositionChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onAudioMixingPositionChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioMixingPositionChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioMixingPositionChangedCompleter.isCompleted) {
              onAudioMixingPositionChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioMixingPositionChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioMixingFinished',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioMixingFinishedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioMixingFinished: () {
          onAudioMixingFinishedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        final eventJson = {};

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onAudioMixingFinished',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onAudioMixingFinished',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioMixingFinished',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioMixingFinishedCompleter.isCompleted) {
              onAudioMixingFinishedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioMixingFinishedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioEffectFinished',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioEffectFinishedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioEffectFinished: (int soundId) {
          onAudioEffectFinishedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int soundId = 10;

        final eventJson = {
          'soundId': soundId,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onAudioEffectFinished',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onAudioEffectFinished',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioEffectFinished',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioEffectFinishedCompleter.isCompleted) {
              onAudioEffectFinishedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioEffectFinishedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onVideoDeviceStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onVideoDeviceStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoDeviceStateChanged: (String deviceId, MediaDeviceType deviceType,
            MediaDeviceStateType deviceState) {
          onVideoDeviceStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String deviceId = "hello";
        const MediaDeviceType deviceType = MediaDeviceType.unknownAudioDevice;
        const MediaDeviceStateType deviceState =
            MediaDeviceStateType.mediaDeviceStateIdle;

        final eventJson = {
          'deviceId': deviceId,
          'deviceType': deviceType.value(),
          'deviceState': deviceState.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoDeviceStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onVideoDeviceStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoDeviceStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onVideoDeviceStateChangedCompleter.isCompleted) {
              onVideoDeviceStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoDeviceStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onNetworkQuality',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onNetworkQualityCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onNetworkQuality: (RtcConnection connection, int remoteUid,
            QualityType txQuality, QualityType rxQuality) {
          onNetworkQualityCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const QualityType txQuality = QualityType.qualityUnknown;
        const QualityType rxQuality = QualityType.qualityUnknown;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'txQuality': txQuality.value(),
          'rxQuality': rxQuality.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onNetworkQuality',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onNetworkQuality',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onNetworkQualityEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onNetworkQualityCompleter.isCompleted) {
              onNetworkQualityCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onNetworkQualityCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onIntraRequestReceived',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onIntraRequestReceivedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onIntraRequestReceived: (RtcConnection connection) {
          onIntraRequestReceivedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onIntraRequestReceived',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onIntraRequestReceived',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onIntraRequestReceivedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onIntraRequestReceivedCompleter.isCompleted) {
              onIntraRequestReceivedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onIntraRequestReceivedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUplinkNetworkInfoUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUplinkNetworkInfoUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUplinkNetworkInfoUpdated: (UplinkNetworkInfo info) {
          onUplinkNetworkInfoUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int infoVideoEncoderTargetBitrateBps = 10;
        const UplinkNetworkInfo info = UplinkNetworkInfo(
          videoEncoderTargetBitrateBps: infoVideoEncoderTargetBitrateBps,
        );

        final eventJson = {
          'info': info.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onUplinkNetworkInfoUpdated',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onUplinkNetworkInfoUpdated',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUplinkNetworkInfoUpdated',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUplinkNetworkInfoUpdatedCompleter.isCompleted) {
              onUplinkNetworkInfoUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUplinkNetworkInfoUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onDownlinkNetworkInfoUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onDownlinkNetworkInfoUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onDownlinkNetworkInfoUpdated: (DownlinkNetworkInfo info) {
          onDownlinkNetworkInfoUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int infoLastmileBufferDelayTimeMs = 10;
        const int infoBandwidthEstimationBps = 10;
        const int infoTotalDownscaleLevelCount = 10;
        const List<PeerDownlinkInfo> infoPeerDownlinkInfo = [];
        const int infoTotalReceivedVideoCount = 10;
        const DownlinkNetworkInfo info = DownlinkNetworkInfo(
          lastmileBufferDelayTimeMs: infoLastmileBufferDelayTimeMs,
          bandwidthEstimationBps: infoBandwidthEstimationBps,
          totalDownscaleLevelCount: infoTotalDownscaleLevelCount,
          peerDownlinkInfo: infoPeerDownlinkInfo,
          totalReceivedVideoCount: infoTotalReceivedVideoCount,
        );

        final eventJson = {
          'info': info.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onDownlinkNetworkInfoUpdated',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onDownlinkNetworkInfoUpdated',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onDownlinkNetworkInfoUpdated',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onDownlinkNetworkInfoUpdatedCompleter.isCompleted) {
              onDownlinkNetworkInfoUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onDownlinkNetworkInfoUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLastmileQuality',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLastmileQualityCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLastmileQuality: (QualityType quality) {
          onLastmileQualityCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const QualityType quality = QualityType.qualityUnknown;

        final eventJson = {
          'quality': quality.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onLastmileQuality',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onLastmileQuality',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLastmileQuality',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLastmileQualityCompleter.isCompleted) {
              onLastmileQualityCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLastmileQualityCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onFirstLocalVideoFrame',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onFirstLocalVideoFrameCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstLocalVideoFrame:
            (VideoSourceType source, int width, int height, int elapsed) {
          onFirstLocalVideoFrameCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const int width = 10;
        const int height = 10;
        const int elapsed = 10;

        final eventJson = {
          'source': source.value(),
          'width': width,
          'height': height,
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onFirstLocalVideoFrame',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onFirstLocalVideoFrame',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstLocalVideoFrame',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onFirstLocalVideoFrameCompleter.isCompleted) {
              onFirstLocalVideoFrameCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstLocalVideoFrameCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onFirstLocalVideoFramePublished',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onFirstLocalVideoFramePublishedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstLocalVideoFramePublished: (VideoSourceType source, int elapsed) {
          onFirstLocalVideoFramePublishedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const int elapsed = 10;

        final eventJson = {
          'source': source.value(),
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstLocalVideoFramePublished',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onFirstLocalVideoFramePublished',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstLocalVideoFramePublished',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onFirstLocalVideoFramePublishedCompleter.isCompleted) {
              onFirstLocalVideoFramePublishedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstLocalVideoFramePublishedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onFirstRemoteVideoDecoded',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onFirstRemoteVideoDecodedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstRemoteVideoDecoded: (RtcConnection connection, int remoteUid,
            int width, int height, int elapsed) {
          onFirstRemoteVideoDecodedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int width = 10;
        const int height = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'width': width,
          'height': height,
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstRemoteVideoDecoded',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onFirstRemoteVideoDecoded',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstRemoteVideoDecodedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onFirstRemoteVideoDecodedCompleter.isCompleted) {
              onFirstRemoteVideoDecodedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstRemoteVideoDecodedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onVideoSizeChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onVideoSizeChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoSizeChanged: (RtcConnection connection,
            VideoSourceType sourceType,
            int uid,
            int width,
            int height,
            int rotation) {
          onVideoSizeChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const VideoSourceType sourceType =
            VideoSourceType.videoSourceCameraPrimary;
        const int uid = 10;
        const int width = 10;
        const int height = 10;
        const int rotation = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'sourceType': sourceType.value(),
          'uid': uid,
          'width': width,
          'height': height,
          'rotation': rotation,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onVideoSizeChanged',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onVideoSizeChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoSizeChangedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onVideoSizeChangedCompleter.isCompleted) {
              onVideoSizeChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoSizeChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLocalVideoStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLocalVideoStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalVideoStateChanged: (VideoSourceType source,
            LocalVideoStreamState state, LocalVideoStreamError error) {
          onLocalVideoStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const LocalVideoStreamState state =
            LocalVideoStreamState.localVideoStreamStateStopped;
        const LocalVideoStreamError error =
            LocalVideoStreamError.localVideoStreamErrorOk;

        final eventJson = {
          'source': source.value(),
          'state': state.value(),
          'error': error.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onLocalVideoStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onLocalVideoStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLocalVideoStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLocalVideoStateChangedCompleter.isCompleted) {
              onLocalVideoStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalVideoStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRemoteVideoStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRemoteVideoStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteVideoStateChanged: (RtcConnection connection,
            int remoteUid,
            RemoteVideoState state,
            RemoteVideoStateReason reason,
            int elapsed) {
          onRemoteVideoStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const RemoteVideoState state = RemoteVideoState.remoteVideoStateStopped;
        const RemoteVideoStateReason reason =
            RemoteVideoStateReason.remoteVideoStateReasonInternal;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'state': state.value(),
          'reason': reason.value(),
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteVideoStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onRemoteVideoStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteVideoStateChangedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRemoteVideoStateChangedCompleter.isCompleted) {
              onRemoteVideoStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteVideoStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onFirstRemoteVideoFrame',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onFirstRemoteVideoFrameCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstRemoteVideoFrame: (RtcConnection connection, int remoteUid,
            int width, int height, int elapsed) {
          onFirstRemoteVideoFrameCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int width = 10;
        const int height = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'width': width,
          'height': height,
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onFirstRemoteVideoFrame',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onFirstRemoteVideoFrame',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstRemoteVideoFrameEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onFirstRemoteVideoFrameCompleter.isCompleted) {
              onFirstRemoteVideoFrameCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstRemoteVideoFrameCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUserJoined',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUserJoinedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserJoined: (RtcConnection connection, int remoteUid, int elapsed) {
          onUserJoinedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUserJoined',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUserJoined',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUserJoinedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUserJoinedCompleter.isCompleted) {
              onUserJoinedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserJoinedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUserOffline',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUserOfflineCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserOffline: (RtcConnection connection, int remoteUid,
            UserOfflineReasonType reason) {
          onUserOfflineCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const UserOfflineReasonType reason =
            UserOfflineReasonType.userOfflineQuit;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'reason': reason.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUserOffline',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUserOffline',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUserOfflineEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUserOfflineCompleter.isCompleted) {
              onUserOfflineCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserOfflineCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUserMuteAudio',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUserMuteAudioCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserMuteAudio: (RtcConnection connection, int remoteUid, bool muted) {
          onUserMuteAudioCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const bool muted = true;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'muted': muted,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUserMuteAudio',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUserMuteAudio',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUserMuteAudioEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUserMuteAudioCompleter.isCompleted) {
              onUserMuteAudioCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserMuteAudioCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUserMuteVideo',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUserMuteVideoCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserMuteVideo: (RtcConnection connection, int remoteUid, bool muted) {
          onUserMuteVideoCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const bool muted = true;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'muted': muted,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUserMuteVideo',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUserMuteVideo',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUserMuteVideoEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUserMuteVideoCompleter.isCompleted) {
              onUserMuteVideoCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserMuteVideoCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUserEnableVideo',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUserEnableVideoCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserEnableVideo:
            (RtcConnection connection, int remoteUid, bool enabled) {
          onUserEnableVideoCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const bool enabled = true;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'enabled': enabled,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUserEnableVideo',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUserEnableVideo',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUserEnableVideoEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUserEnableVideoCompleter.isCompleted) {
              onUserEnableVideoCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserEnableVideoCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUserStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUserStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserStateChanged:
            (RtcConnection connection, int remoteUid, int state) {
          onUserStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int state = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'state': state,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUserStateChanged',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUserStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUserStateChangedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUserStateChangedCompleter.isCompleted) {
              onUserStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUserEnableLocalVideo',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUserEnableLocalVideoCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserEnableLocalVideo:
            (RtcConnection connection, int remoteUid, bool enabled) {
          onUserEnableLocalVideoCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const bool enabled = true;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'enabled': enabled,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUserEnableLocalVideo',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUserEnableLocalVideo',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUserEnableLocalVideoEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUserEnableLocalVideoCompleter.isCompleted) {
              onUserEnableLocalVideoCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserEnableLocalVideoCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLocalAudioStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLocalAudioStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalAudioStats: (RtcConnection connection, LocalAudioStats stats) {
          onLocalAudioStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int statsNumChannels = 10;
        const int statsSentSampleRate = 10;
        const int statsSentBitrate = 10;
        const int statsInternalCodec = 10;
        const int statsTxPacketLossRate = 10;
        const int statsAudioDeviceDelay = 10;
        const LocalAudioStats stats = LocalAudioStats(
          numChannels: statsNumChannels,
          sentSampleRate: statsSentSampleRate,
          sentBitrate: statsSentBitrate,
          internalCodec: statsInternalCodec,
          txPacketLossRate: statsTxPacketLossRate,
          audioDeviceDelay: statsAudioDeviceDelay,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onLocalAudioStats',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onLocalAudioStats',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLocalAudioStatsEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLocalAudioStatsCompleter.isCompleted) {
              onLocalAudioStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalAudioStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRemoteAudioStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRemoteAudioStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteAudioStats: (RtcConnection connection, RemoteAudioStats stats) {
          onRemoteAudioStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int statsUid = 10;
        const int statsQuality = 10;
        const int statsNetworkTransportDelay = 10;
        const int statsJitterBufferDelay = 10;
        const int statsAudioLossRate = 10;
        const int statsNumChannels = 10;
        const int statsReceivedSampleRate = 10;
        const int statsReceivedBitrate = 10;
        const int statsTotalFrozenTime = 10;
        const int statsFrozenRate = 10;
        const int statsMosValue = 10;
        const int statsFrozenRateByCustomPlcCount = 10;
        const int statsPlcCount = 10;
        const int statsTotalActiveTime = 10;
        const int statsPublishDuration = 10;
        const int statsQoeQuality = 10;
        const int statsQualityChangedReason = 10;
        const int statsRxAudioBytes = 10;
        const RemoteAudioStats stats = RemoteAudioStats(
          uid: statsUid,
          quality: statsQuality,
          networkTransportDelay: statsNetworkTransportDelay,
          jitterBufferDelay: statsJitterBufferDelay,
          audioLossRate: statsAudioLossRate,
          numChannels: statsNumChannels,
          receivedSampleRate: statsReceivedSampleRate,
          receivedBitrate: statsReceivedBitrate,
          totalFrozenTime: statsTotalFrozenTime,
          frozenRate: statsFrozenRate,
          mosValue: statsMosValue,
          frozenRateByCustomPlcCount: statsFrozenRateByCustomPlcCount,
          plcCount: statsPlcCount,
          totalActiveTime: statsTotalActiveTime,
          publishDuration: statsPublishDuration,
          qoeQuality: statsQoeQuality,
          qualityChangedReason: statsQualityChangedReason,
          rxAudioBytes: statsRxAudioBytes,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onRemoteAudioStats',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onRemoteAudioStats',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteAudioStatsEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRemoteAudioStatsCompleter.isCompleted) {
              onRemoteAudioStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteAudioStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLocalVideoStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLocalVideoStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalVideoStats: (VideoSourceType source, LocalVideoStats stats) {
          onLocalVideoStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const QualityAdaptIndication statsQualityAdaptIndication =
            QualityAdaptIndication.adaptNone;
        const VideoCodecType statsCodecType = VideoCodecType.videoCodecNone;
        const CaptureBrightnessLevelType statsCaptureBrightnessLevel =
            CaptureBrightnessLevelType.captureBrightnessLevelInvalid;
        const int statsUid = 10;
        const int statsSentBitrate = 10;
        const int statsSentFrameRate = 10;
        const int statsCaptureFrameRate = 10;
        const int statsCaptureFrameWidth = 10;
        const int statsCaptureFrameHeight = 10;
        const int statsRegulatedCaptureFrameRate = 10;
        const int statsRegulatedCaptureFrameWidth = 10;
        const int statsRegulatedCaptureFrameHeight = 10;
        const int statsEncoderOutputFrameRate = 10;
        const int statsEncodedFrameWidth = 10;
        const int statsEncodedFrameHeight = 10;
        const int statsRendererOutputFrameRate = 10;
        const int statsTargetBitrate = 10;
        const int statsTargetFrameRate = 10;
        const int statsEncodedBitrate = 10;
        const int statsEncodedFrameCount = 10;
        const int statsTxPacketLossRate = 10;
        const bool statsDualStreamEnabled = true;
        const int statsHwEncoderAccelerating = 10;
        const LocalVideoStats stats = LocalVideoStats(
          uid: statsUid,
          sentBitrate: statsSentBitrate,
          sentFrameRate: statsSentFrameRate,
          captureFrameRate: statsCaptureFrameRate,
          captureFrameWidth: statsCaptureFrameWidth,
          captureFrameHeight: statsCaptureFrameHeight,
          regulatedCaptureFrameRate: statsRegulatedCaptureFrameRate,
          regulatedCaptureFrameWidth: statsRegulatedCaptureFrameWidth,
          regulatedCaptureFrameHeight: statsRegulatedCaptureFrameHeight,
          encoderOutputFrameRate: statsEncoderOutputFrameRate,
          encodedFrameWidth: statsEncodedFrameWidth,
          encodedFrameHeight: statsEncodedFrameHeight,
          rendererOutputFrameRate: statsRendererOutputFrameRate,
          targetBitrate: statsTargetBitrate,
          targetFrameRate: statsTargetFrameRate,
          qualityAdaptIndication: statsQualityAdaptIndication,
          encodedBitrate: statsEncodedBitrate,
          encodedFrameCount: statsEncodedFrameCount,
          codecType: statsCodecType,
          txPacketLossRate: statsTxPacketLossRate,
          captureBrightnessLevel: statsCaptureBrightnessLevel,
          dualStreamEnabled: statsDualStreamEnabled,
          hwEncoderAccelerating: statsHwEncoderAccelerating,
        );

        final eventJson = {
          'source': source.value(),
          'stats': stats.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onLocalVideoStats',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onLocalVideoStats',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLocalVideoStats',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLocalVideoStatsCompleter.isCompleted) {
              onLocalVideoStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalVideoStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRemoteVideoStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRemoteVideoStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteVideoStats: (RtcConnection connection, RemoteVideoStats stats) {
          onRemoteVideoStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const VideoStreamType statsRxStreamType =
            VideoStreamType.videoStreamHigh;
        const int statsUid = 10;
        const int statsDelay = 10;
        const int statsE2eDelay = 10;
        const int statsWidth = 10;
        const int statsHeight = 10;
        const int statsReceivedBitrate = 10;
        const int statsDecoderOutputFrameRate = 10;
        const int statsRendererOutputFrameRate = 10;
        const int statsFrameLossRate = 10;
        const int statsPacketLossRate = 10;
        const int statsTotalFrozenTime = 10;
        const int statsFrozenRate = 10;
        const int statsAvSyncTimeMs = 10;
        const int statsTotalActiveTime = 10;
        const int statsPublishDuration = 10;
        const int statsMosValue = 10;
        const int statsRxVideoBytes = 10;
        const RemoteVideoStats stats = RemoteVideoStats(
          uid: statsUid,
          delay: statsDelay,
          e2eDelay: statsE2eDelay,
          width: statsWidth,
          height: statsHeight,
          receivedBitrate: statsReceivedBitrate,
          decoderOutputFrameRate: statsDecoderOutputFrameRate,
          rendererOutputFrameRate: statsRendererOutputFrameRate,
          frameLossRate: statsFrameLossRate,
          packetLossRate: statsPacketLossRate,
          rxStreamType: statsRxStreamType,
          totalFrozenTime: statsTotalFrozenTime,
          frozenRate: statsFrozenRate,
          avSyncTimeMs: statsAvSyncTimeMs,
          totalActiveTime: statsTotalActiveTime,
          publishDuration: statsPublishDuration,
          mosValue: statsMosValue,
          rxVideoBytes: statsRxVideoBytes,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'stats': stats.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onRemoteVideoStats',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onRemoteVideoStats',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteVideoStatsEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRemoteVideoStatsCompleter.isCompleted) {
              onRemoteVideoStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteVideoStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onCameraReady',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onCameraReadyCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onCameraReady: () {
          onCameraReadyCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        final eventJson = {};

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onCameraReady',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onCameraReady',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onCameraReady',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onCameraReadyCompleter.isCompleted) {
              onCameraReadyCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onCameraReadyCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onCameraFocusAreaChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onCameraFocusAreaChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onCameraFocusAreaChanged: (int x, int y, int width, int height) {
          onCameraFocusAreaChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int x = 10;
        const int y = 10;
        const int width = 10;
        const int height = 10;

        final eventJson = {
          'x': x,
          'y': y,
          'width': width,
          'height': height,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onCameraFocusAreaChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onCameraFocusAreaChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onCameraFocusAreaChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onCameraFocusAreaChangedCompleter.isCompleted) {
              onCameraFocusAreaChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onCameraFocusAreaChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onCameraExposureAreaChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onCameraExposureAreaChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onCameraExposureAreaChanged: (int x, int y, int width, int height) {
          onCameraExposureAreaChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int x = 10;
        const int y = 10;
        const int width = 10;
        const int height = 10;

        final eventJson = {
          'x': x,
          'y': y,
          'width': width,
          'height': height,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onCameraExposureAreaChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onCameraExposureAreaChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onCameraExposureAreaChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onCameraExposureAreaChangedCompleter.isCompleted) {
              onCameraExposureAreaChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onCameraExposureAreaChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onVideoStopped',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onVideoStoppedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoStopped: () {
          onVideoStoppedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        final eventJson = {};

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onVideoStopped',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onVideoStopped',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoStopped',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onVideoStoppedCompleter.isCompleted) {
              onVideoStoppedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoStoppedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioMixingStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioMixingStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioMixingStateChanged:
            (AudioMixingStateType state, AudioMixingReasonType reason) {
          onAudioMixingStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const AudioMixingStateType state =
            AudioMixingStateType.audioMixingStatePlaying;
        const AudioMixingReasonType reason =
            AudioMixingReasonType.audioMixingReasonCanNotOpen;

        final eventJson = {
          'state': state.value(),
          'reason': reason.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioMixingStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onAudioMixingStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioMixingStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioMixingStateChangedCompleter.isCompleted) {
              onAudioMixingStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioMixingStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRhythmPlayerStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRhythmPlayerStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRhythmPlayerStateChanged:
            (RhythmPlayerStateType state, RhythmPlayerErrorType errorCode) {
          onRhythmPlayerStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const RhythmPlayerStateType state =
            RhythmPlayerStateType.rhythmPlayerStateIdle;
        const RhythmPlayerErrorType errorCode =
            RhythmPlayerErrorType.rhythmPlayerErrorOk;

        final eventJson = {
          'state': state.value(),
          'errorCode': errorCode.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onRhythmPlayerStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onRhythmPlayerStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRhythmPlayerStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRhythmPlayerStateChangedCompleter.isCompleted) {
              onRhythmPlayerStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRhythmPlayerStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onConnectionLost',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onConnectionLostCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onConnectionLost: (RtcConnection connection) {
          onConnectionLostCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onConnectionLost',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onConnectionLost',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onConnectionLostEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onConnectionLostCompleter.isCompleted) {
              onConnectionLostCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onConnectionLostCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onConnectionInterrupted',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onConnectionInterruptedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onConnectionInterrupted: (RtcConnection connection) {
          onConnectionInterruptedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onConnectionInterrupted',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onConnectionInterrupted',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onConnectionInterruptedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onConnectionInterruptedCompleter.isCompleted) {
              onConnectionInterruptedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onConnectionInterruptedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onConnectionBanned',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onConnectionBannedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onConnectionBanned: (RtcConnection connection) {
          onConnectionBannedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onConnectionBanned',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onConnectionBanned',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onConnectionBannedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onConnectionBannedCompleter.isCompleted) {
              onConnectionBannedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onConnectionBannedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onStreamMessage',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onStreamMessageCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onStreamMessage: (RtcConnection connection, int remoteUid, int streamId,
            Uint8List data, int length, int sentTs) {
          onStreamMessageCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int streamId = 10;
        Uint8List data = Uint8List.fromList([1, 2, 3, 4, 5]);
        const int length = 10;
        const int sentTs = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'streamId': streamId,
          'data': data.toList(),
          'length': length,
          'sentTs': sentTs,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onStreamMessage',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onStreamMessage',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onStreamMessageEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onStreamMessageCompleter.isCompleted) {
              onStreamMessageCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onStreamMessageCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onStreamMessageError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onStreamMessageErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onStreamMessageError: (RtcConnection connection, int remoteUid,
            int streamId, ErrorCodeType code, int missed, int cached) {
          onStreamMessageErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int streamId = 10;
        const ErrorCodeType code = ErrorCodeType.errOk;
        const int missed = 10;
        const int cached = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'streamId': streamId,
          'code': code.value(),
          'missed': missed,
          'cached': cached,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onStreamMessageError',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onStreamMessageError',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onStreamMessageErrorEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onStreamMessageErrorCompleter.isCompleted) {
              onStreamMessageErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onStreamMessageErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRequestToken',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRequestTokenCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRequestToken: (RtcConnection connection) {
          onRequestTokenCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );

        final eventJson = {
          'connection': connection.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onRequestToken',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onRequestToken',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRequestTokenEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRequestTokenCompleter.isCompleted) {
              onRequestTokenCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRequestTokenCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onTokenPrivilegeWillExpire',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onTokenPrivilegeWillExpireCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onTokenPrivilegeWillExpire: (RtcConnection connection, String token) {
          onTokenPrivilegeWillExpireCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const String token = "hello";

        final eventJson = {
          'connection': connection.toJson(),
          'token': token,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onTokenPrivilegeWillExpire',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onTokenPrivilegeWillExpire',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onTokenPrivilegeWillExpireEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onTokenPrivilegeWillExpireCompleter.isCompleted) {
              onTokenPrivilegeWillExpireCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onTokenPrivilegeWillExpireCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLicenseValidationFailure',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLicenseValidationFailureCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLicenseValidationFailure:
            (RtcConnection connection, LicenseErrorType reason) {
          onLicenseValidationFailureCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const LicenseErrorType reason = LicenseErrorType.licenseErrInvalid;

        final eventJson = {
          'connection': connection.toJson(),
          'reason': reason.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onLicenseValidationFailure',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onLicenseValidationFailure',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLicenseValidationFailureEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLicenseValidationFailureCompleter.isCompleted) {
              onLicenseValidationFailureCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLicenseValidationFailureCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onFirstLocalAudioFramePublished',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onFirstLocalAudioFramePublishedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstLocalAudioFramePublished:
            (RtcConnection connection, int elapsed) {
          onFirstLocalAudioFramePublishedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstLocalAudioFramePublished',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onFirstLocalAudioFramePublished',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstLocalAudioFramePublishedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onFirstLocalAudioFramePublishedCompleter.isCompleted) {
              onFirstLocalAudioFramePublishedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstLocalAudioFramePublishedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onFirstRemoteAudioFrame',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onFirstRemoteAudioFrameCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstRemoteAudioFrame:
            (RtcConnection connection, int userId, int elapsed) {
          onFirstRemoteAudioFrameCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int userId = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'userId': userId,
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onFirstRemoteAudioFrame',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onFirstRemoteAudioFrame',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstRemoteAudioFrameEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onFirstRemoteAudioFrameCompleter.isCompleted) {
              onFirstRemoteAudioFrameCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstRemoteAudioFrameCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onFirstRemoteAudioDecoded',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onFirstRemoteAudioDecodedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onFirstRemoteAudioDecoded:
            (RtcConnection connection, int uid, int elapsed) {
          onFirstRemoteAudioDecodedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int uid = 10;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'uid': uid,
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstRemoteAudioDecoded',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onFirstRemoteAudioDecoded',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onFirstRemoteAudioDecodedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onFirstRemoteAudioDecodedCompleter.isCompleted) {
              onFirstRemoteAudioDecodedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onFirstRemoteAudioDecodedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLocalAudioStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLocalAudioStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalAudioStateChanged: (RtcConnection connection,
            LocalAudioStreamState state, LocalAudioStreamError error) {
          onLocalAudioStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const LocalAudioStreamState state =
            LocalAudioStreamState.localAudioStreamStateStopped;
        const LocalAudioStreamError error =
            LocalAudioStreamError.localAudioStreamErrorOk;

        final eventJson = {
          'connection': connection.toJson(),
          'state': state.value(),
          'error': error.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onLocalAudioStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onLocalAudioStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLocalAudioStateChangedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLocalAudioStateChangedCompleter.isCompleted) {
              onLocalAudioStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalAudioStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRemoteAudioStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRemoteAudioStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteAudioStateChanged: (RtcConnection connection,
            int remoteUid,
            RemoteAudioState state,
            RemoteAudioStateReason reason,
            int elapsed) {
          onRemoteAudioStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const RemoteAudioState state = RemoteAudioState.remoteAudioStateStopped;
        const RemoteAudioStateReason reason =
            RemoteAudioStateReason.remoteAudioReasonInternal;
        const int elapsed = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'state': state.value(),
          'reason': reason.value(),
          'elapsed': elapsed,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteAudioStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onRemoteAudioStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteAudioStateChangedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRemoteAudioStateChangedCompleter.isCompleted) {
              onRemoteAudioStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteAudioStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onActiveSpeaker',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onActiveSpeakerCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onActiveSpeaker: (RtcConnection connection, int uid) {
          onActiveSpeakerCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int uid = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'uid': uid,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onActiveSpeaker',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onActiveSpeaker',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onActiveSpeakerEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onActiveSpeakerCompleter.isCompleted) {
              onActiveSpeakerCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onActiveSpeakerCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onContentInspectResult',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onContentInspectResultCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onContentInspectResult: (ContentInspectResult result) {
          onContentInspectResultCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const ContentInspectResult result =
            ContentInspectResult.contentInspectNeutral;

        final eventJson = {
          'result': result.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onContentInspectResult',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onContentInspectResult',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onContentInspectResult',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onContentInspectResultCompleter.isCompleted) {
              onContentInspectResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onContentInspectResultCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onSnapshotTaken',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onSnapshotTakenCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onSnapshotTaken: (RtcConnection connection, int uid, String filePath,
            int width, int height, int errCode) {
          onSnapshotTakenCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int uid = 10;
        const String filePath = "hello";
        const int width = 10;
        const int height = 10;
        const int errCode = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'uid': uid,
          'filePath': filePath,
          'width': width,
          'height': height,
          'errCode': errCode,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onSnapshotTaken',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onSnapshotTaken',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onSnapshotTakenEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onSnapshotTakenCompleter.isCompleted) {
              onSnapshotTakenCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onSnapshotTakenCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onClientRoleChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onClientRoleChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onClientRoleChanged: (RtcConnection connection, ClientRoleType oldRole,
            ClientRoleType newRole, ClientRoleOptions newRoleOptions) {
          onClientRoleChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const ClientRoleType oldRole = ClientRoleType.clientRoleBroadcaster;
        const ClientRoleType newRole = ClientRoleType.clientRoleBroadcaster;
        const AudienceLatencyLevelType newRoleOptionsAudienceLatencyLevel =
            AudienceLatencyLevelType.audienceLatencyLevelLowLatency;
        const ClientRoleOptions newRoleOptions = ClientRoleOptions(
          audienceLatencyLevel: newRoleOptionsAudienceLatencyLevel,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'oldRole': oldRole.value(),
          'newRole': newRole.value(),
          'newRoleOptions': newRoleOptions.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onClientRoleChanged',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onClientRoleChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onClientRoleChangedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onClientRoleChangedCompleter.isCompleted) {
              onClientRoleChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onClientRoleChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onClientRoleChangeFailed',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onClientRoleChangeFailedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onClientRoleChangeFailed: (RtcConnection connection,
            ClientRoleChangeFailedReason reason, ClientRoleType currentRole) {
          onClientRoleChangeFailedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const ClientRoleChangeFailedReason reason = ClientRoleChangeFailedReason
            .clientRoleChangeFailedTooManyBroadcasters;
        const ClientRoleType currentRole = ClientRoleType.clientRoleBroadcaster;

        final eventJson = {
          'connection': connection.toJson(),
          'reason': reason.value(),
          'currentRole': currentRole.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onClientRoleChangeFailed',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onClientRoleChangeFailed',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onClientRoleChangeFailedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onClientRoleChangeFailedCompleter.isCompleted) {
              onClientRoleChangeFailedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onClientRoleChangeFailedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioDeviceVolumeChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioDeviceVolumeChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioDeviceVolumeChanged:
            (MediaDeviceType deviceType, int volume, bool muted) {
          onAudioDeviceVolumeChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const MediaDeviceType deviceType = MediaDeviceType.unknownAudioDevice;
        const int volume = 10;
        const bool muted = true;

        final eventJson = {
          'deviceType': deviceType.value(),
          'volume': volume,
          'muted': muted,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioDeviceVolumeChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onAudioDeviceVolumeChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioDeviceVolumeChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioDeviceVolumeChangedCompleter.isCompleted) {
              onAudioDeviceVolumeChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioDeviceVolumeChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRtmpStreamingStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRtmpStreamingStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRtmpStreamingStateChanged: (String url, RtmpStreamPublishState state,
            RtmpStreamPublishErrorType errCode) {
          onRtmpStreamingStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String url = "hello";
        const RtmpStreamPublishState state =
            RtmpStreamPublishState.rtmpStreamPublishStateIdle;
        const RtmpStreamPublishErrorType errCode =
            RtmpStreamPublishErrorType.rtmpStreamPublishErrorOk;

        final eventJson = {
          'url': url,
          'state': state.value(),
          'errCode': errCode.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onRtmpStreamingStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onRtmpStreamingStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRtmpStreamingStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRtmpStreamingStateChangedCompleter.isCompleted) {
              onRtmpStreamingStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRtmpStreamingStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRtmpStreamingEvent',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRtmpStreamingEventCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRtmpStreamingEvent: (String url, RtmpStreamingEvent eventCode) {
          onRtmpStreamingEventCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String url = "hello";
        const RtmpStreamingEvent eventCode =
            RtmpStreamingEvent.rtmpStreamingEventFailedLoadImage;

        final eventJson = {
          'url': url,
          'eventCode': eventCode.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onRtmpStreamingEvent',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onRtmpStreamingEvent',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRtmpStreamingEvent',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRtmpStreamingEventCompleter.isCompleted) {
              onRtmpStreamingEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRtmpStreamingEventCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onTranscodingUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onTranscodingUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onTranscodingUpdated: () {
          onTranscodingUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        final eventJson = {};

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onTranscodingUpdated',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onTranscodingUpdated',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onTranscodingUpdated',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onTranscodingUpdatedCompleter.isCompleted) {
              onTranscodingUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onTranscodingUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onChannelMediaRelayStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onChannelMediaRelayStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onChannelMediaRelayStateChanged:
            (ChannelMediaRelayState state, ChannelMediaRelayError code) {
          onChannelMediaRelayStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const ChannelMediaRelayState state =
            ChannelMediaRelayState.relayStateIdle;
        const ChannelMediaRelayError code = ChannelMediaRelayError.relayOk;

        final eventJson = {
          'state': state.value(),
          'code': code.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onChannelMediaRelayStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onChannelMediaRelayStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onChannelMediaRelayStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onChannelMediaRelayStateChangedCompleter.isCompleted) {
              onChannelMediaRelayStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onChannelMediaRelayStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onChannelMediaRelayEvent',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onChannelMediaRelayEventCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onChannelMediaRelayEvent: (ChannelMediaRelayEvent code) {
          onChannelMediaRelayEventCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const ChannelMediaRelayEvent code =
            ChannelMediaRelayEvent.relayEventNetworkDisconnected;

        final eventJson = {
          'code': code.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onChannelMediaRelayEvent',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onChannelMediaRelayEvent',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onChannelMediaRelayEvent',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onChannelMediaRelayEventCompleter.isCompleted) {
              onChannelMediaRelayEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onChannelMediaRelayEventCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLocalPublishFallbackToAudioOnly',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLocalPublishFallbackToAudioOnlyCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalPublishFallbackToAudioOnly: (bool isFallbackOrRecover) {
          onLocalPublishFallbackToAudioOnlyCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const bool isFallbackOrRecover = true;

        final eventJson = {
          'isFallbackOrRecover': isFallbackOrRecover,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onLocalPublishFallbackToAudioOnly',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onLocalPublishFallbackToAudioOnly',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLocalPublishFallbackToAudioOnly',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLocalPublishFallbackToAudioOnlyCompleter.isCompleted) {
              onLocalPublishFallbackToAudioOnlyCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled =
          await onLocalPublishFallbackToAudioOnlyCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRemoteSubscribeFallbackToAudioOnly',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRemoteSubscribeFallbackToAudioOnlyCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteSubscribeFallbackToAudioOnly:
            (int uid, bool isFallbackOrRecover) {
          onRemoteSubscribeFallbackToAudioOnlyCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int uid = 10;
        const bool isFallbackOrRecover = true;

        final eventJson = {
          'uid': uid,
          'isFallbackOrRecover': isFallbackOrRecover,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteSubscribeFallbackToAudioOnly',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onRemoteSubscribeFallbackToAudioOnly',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteSubscribeFallbackToAudioOnly',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRemoteSubscribeFallbackToAudioOnlyCompleter.isCompleted) {
              onRemoteSubscribeFallbackToAudioOnlyCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled =
          await onRemoteSubscribeFallbackToAudioOnlyCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRemoteAudioTransportStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRemoteAudioTransportStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteAudioTransportStats: (RtcConnection connection, int remoteUid,
            int delay, int lost, int rxKBitRate) {
          onRemoteAudioTransportStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int delay = 10;
        const int lost = 10;
        const int rxKBitRate = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'delay': delay,
          'lost': lost,
          'rxKBitRate': rxKBitRate,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteAudioTransportStats',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onRemoteAudioTransportStats',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteAudioTransportStatsEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRemoteAudioTransportStatsCompleter.isCompleted) {
              onRemoteAudioTransportStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteAudioTransportStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onRemoteVideoTransportStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onRemoteVideoTransportStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onRemoteVideoTransportStats: (RtcConnection connection, int remoteUid,
            int delay, int lost, int rxKBitRate) {
          onRemoteVideoTransportStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const int delay = 10;
        const int lost = 10;
        const int rxKBitRate = 10;

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'delay': delay,
          'lost': lost,
          'rxKBitRate': rxKBitRate,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteVideoTransportStats',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onRemoteVideoTransportStats',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onRemoteVideoTransportStatsEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onRemoteVideoTransportStatsCompleter.isCompleted) {
              onRemoteVideoTransportStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onRemoteVideoTransportStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onConnectionStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onConnectionStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onConnectionStateChanged: (RtcConnection connection,
            ConnectionStateType state, ConnectionChangedReasonType reason) {
          onConnectionStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const ConnectionStateType state =
            ConnectionStateType.connectionStateDisconnected;
        const ConnectionChangedReasonType reason =
            ConnectionChangedReasonType.connectionChangedConnecting;

        final eventJson = {
          'connection': connection.toJson(),
          'state': state.value(),
          'reason': reason.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onConnectionStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onConnectionStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onConnectionStateChangedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onConnectionStateChangedCompleter.isCompleted) {
              onConnectionStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onConnectionStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onWlAccMessage',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onWlAccMessageCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onWlAccMessage: (RtcConnection connection, WlaccMessageReason reason,
            WlaccSuggestAction action, String wlAccMsg) {
          onWlAccMessageCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const WlaccMessageReason reason =
            WlaccMessageReason.wlaccMessageReasonWeakSignal;
        const WlaccSuggestAction action =
            WlaccSuggestAction.wlaccSuggestActionCloseToWifi;
        const String wlAccMsg = "hello";

        final eventJson = {
          'connection': connection.toJson(),
          'reason': reason.value(),
          'action': action.value(),
          'wlAccMsg': wlAccMsg,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onWlAccMessage',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onWlAccMessage',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onWlAccMessageEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onWlAccMessageCompleter.isCompleted) {
              onWlAccMessageCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onWlAccMessageCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onWlAccStats',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onWlAccStatsCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onWlAccStats: (RtcConnection connection, WlAccStats currentStats,
            WlAccStats averageStats) {
          onWlAccStatsCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int currentStatsE2eDelayPercent = 10;
        const int currentStatsFrozenRatioPercent = 10;
        const int currentStatsLossRatePercent = 10;
        const WlAccStats currentStats = WlAccStats(
          e2eDelayPercent: currentStatsE2eDelayPercent,
          frozenRatioPercent: currentStatsFrozenRatioPercent,
          lossRatePercent: currentStatsLossRatePercent,
        );
        const int averageStatsE2eDelayPercent = 10;
        const int averageStatsFrozenRatioPercent = 10;
        const int averageStatsLossRatePercent = 10;
        const WlAccStats averageStats = WlAccStats(
          e2eDelayPercent: averageStatsE2eDelayPercent,
          frozenRatioPercent: averageStatsFrozenRatioPercent,
          lossRatePercent: averageStatsLossRatePercent,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'currentStats': currentStats.toJson(),
          'averageStats': averageStats.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onWlAccStats',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onWlAccStats',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onWlAccStatsEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onWlAccStatsCompleter.isCompleted) {
              onWlAccStatsCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onWlAccStatsCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onNetworkTypeChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onNetworkTypeChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onNetworkTypeChanged: (RtcConnection connection, NetworkType type) {
          onNetworkTypeChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const NetworkType type = NetworkType.networkTypeUnknown;

        final eventJson = {
          'connection': connection.toJson(),
          'type': type.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onNetworkTypeChanged',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onNetworkTypeChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onNetworkTypeChangedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onNetworkTypeChangedCompleter.isCompleted) {
              onNetworkTypeChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onNetworkTypeChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onEncryptionError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onEncryptionErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onEncryptionError:
            (RtcConnection connection, EncryptionErrorType errorType) {
          onEncryptionErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const EncryptionErrorType errorType =
            EncryptionErrorType.encryptionErrorInternalFailure;

        final eventJson = {
          'connection': connection.toJson(),
          'errorType': errorType.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onEncryptionError',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onEncryptionError',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onEncryptionErrorEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onEncryptionErrorCompleter.isCompleted) {
              onEncryptionErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onEncryptionErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onPermissionError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onPermissionErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onPermissionError: (PermissionType permissionType) {
          onPermissionErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const PermissionType permissionType = PermissionType.recordAudio;

        final eventJson = {
          'permissionType': permissionType.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onPermissionError',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onPermissionError',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onPermissionError',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onPermissionErrorCompleter.isCompleted) {
              onPermissionErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onPermissionErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLocalUserRegistered',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLocalUserRegisteredCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalUserRegistered: (int uid, String userAccount) {
          onLocalUserRegisteredCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int uid = 10;
        const String userAccount = "hello";

        final eventJson = {
          'uid': uid,
          'userAccount': userAccount,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onLocalUserRegistered',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onLocalUserRegistered',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLocalUserRegistered',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLocalUserRegisteredCompleter.isCompleted) {
              onLocalUserRegisteredCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalUserRegisteredCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUserInfoUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUserInfoUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserInfoUpdated: (int uid, UserInfo info) {
          onUserInfoUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int uid = 10;
        const int infoUid = 10;
        const String infoUserAccount = "hello";
        const UserInfo info = UserInfo(
          uid: infoUid,
          userAccount: infoUserAccount,
        );

        final eventJson = {
          'uid': uid,
          'info': info.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUserInfoUpdated',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUserInfoUpdated',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUserInfoUpdated',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUserInfoUpdatedCompleter.isCompleted) {
              onUserInfoUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserInfoUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUploadLogResult',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUploadLogResultCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUploadLogResult: (RtcConnection connection, String requestId,
            bool success, UploadErrorReason reason) {
          onUploadLogResultCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const String requestId = "hello";
        const bool success = true;
        const UploadErrorReason reason = UploadErrorReason.uploadSuccess;

        final eventJson = {
          'connection': connection.toJson(),
          'requestId': requestId,
          'success': success,
          'reason': reason.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUploadLogResult',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUploadLogResult',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUploadLogResultEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUploadLogResultCompleter.isCompleted) {
              onUploadLogResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUploadLogResultCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioSubscribeStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioSubscribeStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioSubscribeStateChanged: (String channel,
            int uid,
            StreamSubscribeState oldState,
            StreamSubscribeState newState,
            int elapseSinceLastState) {
          onAudioSubscribeStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String channel = "hello";
        const int uid = 10;
        const StreamSubscribeState oldState = StreamSubscribeState.subStateIdle;
        const StreamSubscribeState newState = StreamSubscribeState.subStateIdle;
        const int elapseSinceLastState = 10;

        final eventJson = {
          'channel': channel,
          'uid': uid,
          'oldState': oldState.value(),
          'newState': newState.value(),
          'elapseSinceLastState': elapseSinceLastState,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioSubscribeStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onAudioSubscribeStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioSubscribeStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioSubscribeStateChangedCompleter.isCompleted) {
              onAudioSubscribeStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioSubscribeStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onVideoSubscribeStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onVideoSubscribeStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoSubscribeStateChanged: (String channel,
            int uid,
            StreamSubscribeState oldState,
            StreamSubscribeState newState,
            int elapseSinceLastState) {
          onVideoSubscribeStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String channel = "hello";
        const int uid = 10;
        const StreamSubscribeState oldState = StreamSubscribeState.subStateIdle;
        const StreamSubscribeState newState = StreamSubscribeState.subStateIdle;
        const int elapseSinceLastState = 10;

        final eventJson = {
          'channel': channel,
          'uid': uid,
          'oldState': oldState.value(),
          'newState': newState.value(),
          'elapseSinceLastState': elapseSinceLastState,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoSubscribeStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onVideoSubscribeStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoSubscribeStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onVideoSubscribeStateChangedCompleter.isCompleted) {
              onVideoSubscribeStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoSubscribeStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onAudioPublishStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onAudioPublishStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onAudioPublishStateChanged: (String channel,
            StreamPublishState oldState,
            StreamPublishState newState,
            int elapseSinceLastState) {
          onAudioPublishStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String channel = "hello";
        const StreamPublishState oldState = StreamPublishState.pubStateIdle;
        const StreamPublishState newState = StreamPublishState.pubStateIdle;
        const int elapseSinceLastState = 10;

        final eventJson = {
          'channel': channel,
          'oldState': oldState.value(),
          'newState': newState.value(),
          'elapseSinceLastState': elapseSinceLastState,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioPublishStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onAudioPublishStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onAudioPublishStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onAudioPublishStateChangedCompleter.isCompleted) {
              onAudioPublishStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onAudioPublishStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onVideoPublishStateChanged',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onVideoPublishStateChangedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoPublishStateChanged: (VideoSourceType source,
            String channel,
            StreamPublishState oldState,
            StreamPublishState newState,
            int elapseSinceLastState) {
          onVideoPublishStateChangedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType source = VideoSourceType.videoSourceCameraPrimary;
        const String channel = "hello";
        const StreamPublishState oldState = StreamPublishState.pubStateIdle;
        const StreamPublishState newState = StreamPublishState.pubStateIdle;
        const int elapseSinceLastState = 10;

        final eventJson = {
          'source': source.value(),
          'channel': channel,
          'oldState': oldState.value(),
          'newState': newState.value(),
          'elapseSinceLastState': elapseSinceLastState,
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoPublishStateChanged',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onVideoPublishStateChanged',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoPublishStateChanged',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onVideoPublishStateChangedCompleter.isCompleted) {
              onVideoPublishStateChangedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoPublishStateChangedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onExtensionEvent',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onExtensionEventCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onExtensionEvent:
            (String provider, String extension, String key, String value) {
          onExtensionEventCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String provider = "hello";
        const String extension = "hello";
        const String key = "hello";
        const String value = "hello";

        final eventJson = {
          'provider': provider,
          'extension': extension,
          'key': key,
          'value': value,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onExtensionEvent',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onExtensionEvent',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onExtensionEvent',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onExtensionEventCompleter.isCompleted) {
              onExtensionEventCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onExtensionEventCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onExtensionStarted',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onExtensionStartedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onExtensionStarted: (String provider, String extension) {
          onExtensionStartedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String provider = "hello";
        const String extension = "hello";

        final eventJson = {
          'provider': provider,
          'extension': extension,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onExtensionStarted',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onExtensionStarted',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onExtensionStarted',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onExtensionStartedCompleter.isCompleted) {
              onExtensionStartedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onExtensionStartedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onExtensionStopped',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onExtensionStoppedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onExtensionStopped: (String provider, String extension) {
          onExtensionStoppedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String provider = "hello";
        const String extension = "hello";

        final eventJson = {
          'provider': provider,
          'extension': extension,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onExtensionStopped',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onExtensionStopped',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onExtensionStopped',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onExtensionStoppedCompleter.isCompleted) {
              onExtensionStoppedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onExtensionStoppedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onExtensionError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onExtensionErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onExtensionError:
            (String provider, String extension, int error, String message) {
          onExtensionErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String provider = "hello";
        const String extension = "hello";
        const int error = 10;
        const String message = "hello";

        final eventJson = {
          'provider': provider,
          'extension': extension,
          'error': error,
          'message': message,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onExtensionError',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onExtensionError',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onExtensionError',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onExtensionErrorCompleter.isCompleted) {
              onExtensionErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onExtensionErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onUserAccountUpdated',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onUserAccountUpdatedCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onUserAccountUpdated:
            (RtcConnection connection, int remoteUid, String userAccount) {
          onUserAccountUpdatedCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int remoteUid = 10;
        const String userAccount = "hello";

        final eventJson = {
          'connection': connection.toJson(),
          'remoteUid': remoteUid,
          'userAccount': userAccount,
        };

        if (!kIsWeb) {
          irisTester.fireEvent('RtcEngineEventHandler_onUserAccountUpdated',
              params: eventJson);
          irisTester.fireEvent('RtcEngineEventHandlerEx_onUserAccountUpdated',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onUserAccountUpdatedEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onUserAccountUpdatedCompleter.isCompleted) {
              onUserAccountUpdatedCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onUserAccountUpdatedCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onLocalVideoTranscoderError',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onLocalVideoTranscoderErrorCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onLocalVideoTranscoderError:
            (TranscodingVideoStream stream, VideoTranscoderError error) {
          onLocalVideoTranscoderErrorCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const VideoSourceType streamSourceType =
            VideoSourceType.videoSourceCameraPrimary;
        const int streamRemoteUserUid = 10;
        const String streamImageUrl = "hello";
        const int streamMediaPlayerId = 10;
        const int streamX = 10;
        const int streamY = 10;
        const int streamWidth = 10;
        const int streamHeight = 10;
        const int streamZOrder = 10;
        const double streamAlpha = 10.0;
        const bool streamMirror = true;
        const TranscodingVideoStream stream = TranscodingVideoStream(
          sourceType: streamSourceType,
          remoteUserUid: streamRemoteUserUid,
          imageUrl: streamImageUrl,
          mediaPlayerId: streamMediaPlayerId,
          x: streamX,
          y: streamY,
          width: streamWidth,
          height: streamHeight,
          zOrder: streamZOrder,
          alpha: streamAlpha,
          mirror: streamMirror,
        );
        const VideoTranscoderError error =
            VideoTranscoderError.vtErrVideoSourceNotReady;

        final eventJson = {
          'stream': stream.toJson(),
          'error': error.value(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onLocalVideoTranscoderError',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onLocalVideoTranscoderError',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onLocalVideoTranscoderError',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onLocalVideoTranscoderErrorCompleter.isCompleted) {
              onLocalVideoTranscoderErrorCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onLocalVideoTranscoderErrorCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );

  testWidgets(
    'onVideoRenderingTracingResult',
    (WidgetTester tester) async {
      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      final onVideoRenderingTracingResultCompleter = Completer<bool>();
      final theRtcEngineEventHandler = RtcEngineEventHandler(
        onVideoRenderingTracingResult: (RtcConnection connection,
            int uid,
            MediaTraceEvent currentEvent,
            VideoRenderingTracingInfo tracingInfo) {
          onVideoRenderingTracingResultCompleter.complete(true);
        },
      );

      rtcEngine.registerEventHandler(
        theRtcEngineEventHandler,
      );

// Delay 500 milliseconds to ensure the registerEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const String connectionChannelId = "hello";
        const int connectionLocalUid = 10;
        const RtcConnection connection = RtcConnection(
          channelId: connectionChannelId,
          localUid: connectionLocalUid,
        );
        const int uid = 10;
        const MediaTraceEvent currentEvent =
            MediaTraceEvent.mediaTraceEventVideoRendered;
        const int tracingInfoElapsedTime = 10;
        const int tracingInfoStart2JoinChannel = 10;
        const int tracingInfoJoin2JoinSuccess = 10;
        const int tracingInfoJoinSuccess2RemoteJoined = 10;
        const int tracingInfoRemoteJoined2SetView = 10;
        const int tracingInfoRemoteJoined2UnmuteVideo = 10;
        const int tracingInfoRemoteJoined2PacketReceived = 10;
        const VideoRenderingTracingInfo tracingInfo = VideoRenderingTracingInfo(
          elapsedTime: tracingInfoElapsedTime,
          start2JoinChannel: tracingInfoStart2JoinChannel,
          join2JoinSuccess: tracingInfoJoin2JoinSuccess,
          joinSuccess2RemoteJoined: tracingInfoJoinSuccess2RemoteJoined,
          remoteJoined2SetView: tracingInfoRemoteJoined2SetView,
          remoteJoined2UnmuteVideo: tracingInfoRemoteJoined2UnmuteVideo,
          remoteJoined2PacketReceived: tracingInfoRemoteJoined2PacketReceived,
        );

        final eventJson = {
          'connection': connection.toJson(),
          'uid': uid,
          'currentEvent': currentEvent.value(),
          'tracingInfo': tracingInfo.toJson(),
        };

        if (!kIsWeb) {
          irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoRenderingTracingResult',
              params: eventJson);
          irisTester.fireEvent(
              'RtcEngineEventHandlerEx_onVideoRenderingTracingResult',
              params: eventJson);
        } else {
          final ret = irisTester.fireEvent(
              'RtcEngineEventHandler_onVideoRenderingTracingResultEx',
              params: eventJson);
// Delay 200 milliseconds to ensure the callback is called.
          await Future.delayed(const Duration(milliseconds: 200));
// TODO(littlegnal): Most of callbacks on web are not implemented, we're temporarily skip these callbacks at this time.
          if (ret) {
            if (!onVideoRenderingTracingResultCompleter.isCompleted) {
              onVideoRenderingTracingResultCompleter.complete(true);
            }
          }
        }
      }

      final eventCalled = await onVideoRenderingTracingResultCompleter.future;
      expect(eventCalled, isTrue);

      {
        rtcEngine.unregisterEventHandler(
          theRtcEngineEventHandler,
        );
      }
// Delay 500 milliseconds to ensure the unregisterEventHandler call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 2)),
  );
}

