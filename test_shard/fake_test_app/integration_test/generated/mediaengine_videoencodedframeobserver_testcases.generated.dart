/// GENERATED BY testcase_gen. DO NOT MODIFY BY HAND.

// ignore_for_file: deprecated_member_use,constant_identifier_names

import 'dart:async';
import 'dart:typed_data';

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:iris_tester/iris_tester.dart';
import 'package:agora_rtc_engine/src/impl/api_caller.dart';

void generatedTestCases() {
  testWidgets(
    'onEncodedVideoFrameReceived',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.getDebugApiEngineNativeHandle();
      setMockIrisApiEngineIntPtr(debugApiEngineIntPtr);

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: 'app_id',
        areaCode: AreaCode.areaCodeGlob.value(),
      ));
      final mediaEngine = rtcEngine.getMediaEngine();

      final onEncodedVideoFrameReceivedCompleter = Completer<bool>();
      final theVideoEncodedFrameObserver = VideoEncodedFrameObserver(
        onEncodedVideoFrameReceived: (int uid, Uint8List imageBuffer,
            int length, EncodedVideoFrameInfo videoEncodedFrameInfo) {
          onEncodedVideoFrameReceivedCompleter.complete(true);
        },
      );

      mediaEngine.registerVideoEncodedFrameObserver(
        theVideoEncodedFrameObserver,
      );

// Delay 500 milliseconds to ensure the registerVideoEncodedFrameObserver call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      {
        const int uid = 10;
        Uint8List imageBuffer = Uint8List.fromList([1, 2, 3, 4, 5]);
        const int length = 10;
        const VideoCodecType videoEncodedFrameInfoCodecType =
            VideoCodecType.videoCodecNone;
        const VideoFrameType videoEncodedFrameInfoFrameType =
            VideoFrameType.videoFrameTypeBlankFrame;
        const VideoOrientation videoEncodedFrameInfoRotation =
            VideoOrientation.videoOrientation0;
        const VideoStreamType videoEncodedFrameInfoStreamType =
            VideoStreamType.videoStreamHigh;
        const int videoEncodedFrameInfoWidth = 10;
        const int videoEncodedFrameInfoHeight = 10;
        const int videoEncodedFrameInfoFramesPerSecond = 10;
        const int videoEncodedFrameInfoTrackId = 10;
        const int videoEncodedFrameInfoCaptureTimeMs = 10;
        const int videoEncodedFrameInfoDecodeTimeMs = 10;
        const int videoEncodedFrameInfoUid = 10;
        const EncodedVideoFrameInfo videoEncodedFrameInfo =
            EncodedVideoFrameInfo(
          codecType: videoEncodedFrameInfoCodecType,
          width: videoEncodedFrameInfoWidth,
          height: videoEncodedFrameInfoHeight,
          framesPerSecond: videoEncodedFrameInfoFramesPerSecond,
          frameType: videoEncodedFrameInfoFrameType,
          rotation: videoEncodedFrameInfoRotation,
          trackId: videoEncodedFrameInfoTrackId,
          captureTimeMs: videoEncodedFrameInfoCaptureTimeMs,
          decodeTimeMs: videoEncodedFrameInfoDecodeTimeMs,
          uid: videoEncodedFrameInfoUid,
          streamType: videoEncodedFrameInfoStreamType,
        );

        final eventJson = {
          'uid': uid,
          'imageBuffer': imageBuffer.toList(),
          'length': length,
          'videoEncodedFrameInfo': videoEncodedFrameInfo.toJson(),
        };

        irisTester.fireEvent(
            'VideoEncodedFrameObserver_onEncodedVideoFrameReceived',
            params: eventJson);
      }

      final eventCalled = await onEncodedVideoFrameReceivedCompleter.future;
      expect(eventCalled, isTrue);

      {
        mediaEngine.unregisterVideoEncodedFrameObserver(
          theVideoEncodedFrameObserver,
        );
      }
// Delay 500 milliseconds to ensure the unregisterVideoEncodedFrameObserver call completed.
      await Future.delayed(const Duration(milliseconds: 500));

      await rtcEngine.release();
    },
    timeout: const Timeout(Duration(minutes: 1)),
  );
}

