/// GENERATED BY testcase_gen. DO NOT MODIFY BY HAND.

// ignore_for_file: deprecated_member_use,constant_identifier_names

import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:flutter_test/flutter_test.dart';
import 'dart:typed_data';
import 'package:flutter/foundation.dart';
import 'package:fake_test_app/main.dart' as app;
import 'package:iris_tester/iris_tester.dart';
import 'package:iris_method_channel/iris_method_channel.dart';

void rtcEngineSmokeTestCases() {
  testWidgets(
    'release',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool sync = true;
        await rtcEngine.release(
          sync: sync,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[release] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'initialize',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const ChannelProfileType contextChannelProfile =
            ChannelProfileType.channelProfileCommunication;
        const AudioScenarioType contextAudioScenario =
            AudioScenarioType.audioScenarioDefault;
        const LogLevel logConfigLevel = LogLevel.logLevelNone;
        const String logConfigFilePath = "hello";
        const int logConfigFileSizeInKB = 10;
        const LogConfig contextLogConfig = LogConfig(
          filePath: logConfigFilePath,
          fileSizeInKB: logConfigFileSizeInKB,
          level: logConfigLevel,
        );
        const ThreadPriorityType contextThreadPriority =
            ThreadPriorityType.lowest;
        const String contextAppId = "hello";
        const String contextLicense = "hello";
        const int contextAreaCode = 10;
        const bool contextUseExternalEglContext = true;
        const bool contextDomainLimit = true;
        const RtcEngineContext context = RtcEngineContext(
          appId: contextAppId,
          channelProfile: contextChannelProfile,
          license: contextLicense,
          audioScenario: contextAudioScenario,
          areaCode: contextAreaCode,
          logConfig: contextLogConfig,
          threadPriority: contextThreadPriority,
          useExternalEglContext: contextUseExternalEglContext,
          domainLimit: contextDomainLimit,
        );
        await rtcEngine.initialize(
          context,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[initialize] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getVersion',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getVersion();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getVersion] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getErrorDescription',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int code = 10;
        await rtcEngine.getErrorDescription(
          code,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getErrorDescription] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'joinChannel',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String token = "hello";
        const String channelId = "hello";
        const int uid = 10;
        const ClientRoleType optionsClientRoleType =
            ClientRoleType.clientRoleBroadcaster;
        const AudienceLatencyLevelType optionsAudienceLatencyLevel =
            AudienceLatencyLevelType.audienceLatencyLevelLowLatency;
        const VideoStreamType optionsDefaultVideoStreamType =
            VideoStreamType.videoStreamHigh;
        const ChannelProfileType optionsChannelProfile =
            ChannelProfileType.channelProfileCommunication;
        const bool optionsPublishCameraTrack = true;
        const bool optionsPublishSecondaryCameraTrack = true;
        const bool optionsPublishMicrophoneTrack = true;
        const bool optionsPublishScreenCaptureVideo = true;
        const bool optionsPublishScreenCaptureAudio = true;
        const bool optionsPublishScreenTrack = true;
        const bool optionsPublishSecondaryScreenTrack = true;
        const bool optionsPublishCustomAudioTrack = true;
        const int optionsPublishCustomAudioSourceId = 10;
        const bool optionsPublishCustomAudioTrackEnableAec = true;
        const bool optionsPublishDirectCustomAudioTrack = true;
        const bool optionsPublishCustomAudioTrackAec = true;
        const bool optionsPublishCustomVideoTrack = true;
        const bool optionsPublishEncodedVideoTrack = true;
        const bool optionsPublishMediaPlayerAudioTrack = true;
        const bool optionsPublishMediaPlayerVideoTrack = true;
        const bool optionsPublishTrancodedVideoTrack = true;
        const bool optionsAutoSubscribeAudio = true;
        const bool optionsAutoSubscribeVideo = true;
        const bool optionsEnableAudioRecordingOrPlayout = true;
        const int optionsPublishMediaPlayerId = 10;
        const int optionsAudioDelayMs = 10;
        const int optionsMediaPlayerAudioDelayMs = 10;
        const String optionsToken = "hello";
        const bool optionsEnableBuiltInMediaEncryption = true;
        const bool optionsPublishRhythmPlayerTrack = true;
        const bool optionsIsInteractiveAudience = true;
        const int optionsCustomVideoTrackId = 10;
        const bool optionsIsAudioFilterable = true;
        const ChannelMediaOptions options = ChannelMediaOptions(
          publishCameraTrack: optionsPublishCameraTrack,
          publishSecondaryCameraTrack: optionsPublishSecondaryCameraTrack,
          publishMicrophoneTrack: optionsPublishMicrophoneTrack,
          publishScreenCaptureVideo: optionsPublishScreenCaptureVideo,
          publishScreenCaptureAudio: optionsPublishScreenCaptureAudio,
          publishScreenTrack: optionsPublishScreenTrack,
          publishSecondaryScreenTrack: optionsPublishSecondaryScreenTrack,
          publishCustomAudioTrack: optionsPublishCustomAudioTrack,
          publishCustomAudioSourceId: optionsPublishCustomAudioSourceId,
          publishCustomAudioTrackEnableAec:
              optionsPublishCustomAudioTrackEnableAec,
          publishDirectCustomAudioTrack: optionsPublishDirectCustomAudioTrack,
          publishCustomAudioTrackAec: optionsPublishCustomAudioTrackAec,
          publishCustomVideoTrack: optionsPublishCustomVideoTrack,
          publishEncodedVideoTrack: optionsPublishEncodedVideoTrack,
          publishMediaPlayerAudioTrack: optionsPublishMediaPlayerAudioTrack,
          publishMediaPlayerVideoTrack: optionsPublishMediaPlayerVideoTrack,
          publishTrancodedVideoTrack: optionsPublishTrancodedVideoTrack,
          autoSubscribeAudio: optionsAutoSubscribeAudio,
          autoSubscribeVideo: optionsAutoSubscribeVideo,
          enableAudioRecordingOrPlayout: optionsEnableAudioRecordingOrPlayout,
          publishMediaPlayerId: optionsPublishMediaPlayerId,
          clientRoleType: optionsClientRoleType,
          audienceLatencyLevel: optionsAudienceLatencyLevel,
          defaultVideoStreamType: optionsDefaultVideoStreamType,
          channelProfile: optionsChannelProfile,
          audioDelayMs: optionsAudioDelayMs,
          mediaPlayerAudioDelayMs: optionsMediaPlayerAudioDelayMs,
          token: optionsToken,
          enableBuiltInMediaEncryption: optionsEnableBuiltInMediaEncryption,
          publishRhythmPlayerTrack: optionsPublishRhythmPlayerTrack,
          isInteractiveAudience: optionsIsInteractiveAudience,
          customVideoTrackId: optionsCustomVideoTrackId,
          isAudioFilterable: optionsIsAudioFilterable,
        );
        await rtcEngine.joinChannel(
          token: token,
          channelId: channelId,
          uid: uid,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[joinChannel] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'updateChannelMediaOptions',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const ClientRoleType optionsClientRoleType =
            ClientRoleType.clientRoleBroadcaster;
        const AudienceLatencyLevelType optionsAudienceLatencyLevel =
            AudienceLatencyLevelType.audienceLatencyLevelLowLatency;
        const VideoStreamType optionsDefaultVideoStreamType =
            VideoStreamType.videoStreamHigh;
        const ChannelProfileType optionsChannelProfile =
            ChannelProfileType.channelProfileCommunication;
        const bool optionsPublishCameraTrack = true;
        const bool optionsPublishSecondaryCameraTrack = true;
        const bool optionsPublishMicrophoneTrack = true;
        const bool optionsPublishScreenCaptureVideo = true;
        const bool optionsPublishScreenCaptureAudio = true;
        const bool optionsPublishScreenTrack = true;
        const bool optionsPublishSecondaryScreenTrack = true;
        const bool optionsPublishCustomAudioTrack = true;
        const int optionsPublishCustomAudioSourceId = 10;
        const bool optionsPublishCustomAudioTrackEnableAec = true;
        const bool optionsPublishDirectCustomAudioTrack = true;
        const bool optionsPublishCustomAudioTrackAec = true;
        const bool optionsPublishCustomVideoTrack = true;
        const bool optionsPublishEncodedVideoTrack = true;
        const bool optionsPublishMediaPlayerAudioTrack = true;
        const bool optionsPublishMediaPlayerVideoTrack = true;
        const bool optionsPublishTrancodedVideoTrack = true;
        const bool optionsAutoSubscribeAudio = true;
        const bool optionsAutoSubscribeVideo = true;
        const bool optionsEnableAudioRecordingOrPlayout = true;
        const int optionsPublishMediaPlayerId = 10;
        const int optionsAudioDelayMs = 10;
        const int optionsMediaPlayerAudioDelayMs = 10;
        const String optionsToken = "hello";
        const bool optionsEnableBuiltInMediaEncryption = true;
        const bool optionsPublishRhythmPlayerTrack = true;
        const bool optionsIsInteractiveAudience = true;
        const int optionsCustomVideoTrackId = 10;
        const bool optionsIsAudioFilterable = true;
        const ChannelMediaOptions options = ChannelMediaOptions(
          publishCameraTrack: optionsPublishCameraTrack,
          publishSecondaryCameraTrack: optionsPublishSecondaryCameraTrack,
          publishMicrophoneTrack: optionsPublishMicrophoneTrack,
          publishScreenCaptureVideo: optionsPublishScreenCaptureVideo,
          publishScreenCaptureAudio: optionsPublishScreenCaptureAudio,
          publishScreenTrack: optionsPublishScreenTrack,
          publishSecondaryScreenTrack: optionsPublishSecondaryScreenTrack,
          publishCustomAudioTrack: optionsPublishCustomAudioTrack,
          publishCustomAudioSourceId: optionsPublishCustomAudioSourceId,
          publishCustomAudioTrackEnableAec:
              optionsPublishCustomAudioTrackEnableAec,
          publishDirectCustomAudioTrack: optionsPublishDirectCustomAudioTrack,
          publishCustomAudioTrackAec: optionsPublishCustomAudioTrackAec,
          publishCustomVideoTrack: optionsPublishCustomVideoTrack,
          publishEncodedVideoTrack: optionsPublishEncodedVideoTrack,
          publishMediaPlayerAudioTrack: optionsPublishMediaPlayerAudioTrack,
          publishMediaPlayerVideoTrack: optionsPublishMediaPlayerVideoTrack,
          publishTrancodedVideoTrack: optionsPublishTrancodedVideoTrack,
          autoSubscribeAudio: optionsAutoSubscribeAudio,
          autoSubscribeVideo: optionsAutoSubscribeVideo,
          enableAudioRecordingOrPlayout: optionsEnableAudioRecordingOrPlayout,
          publishMediaPlayerId: optionsPublishMediaPlayerId,
          clientRoleType: optionsClientRoleType,
          audienceLatencyLevel: optionsAudienceLatencyLevel,
          defaultVideoStreamType: optionsDefaultVideoStreamType,
          channelProfile: optionsChannelProfile,
          audioDelayMs: optionsAudioDelayMs,
          mediaPlayerAudioDelayMs: optionsMediaPlayerAudioDelayMs,
          token: optionsToken,
          enableBuiltInMediaEncryption: optionsEnableBuiltInMediaEncryption,
          publishRhythmPlayerTrack: optionsPublishRhythmPlayerTrack,
          isInteractiveAudience: optionsIsInteractiveAudience,
          customVideoTrackId: optionsCustomVideoTrackId,
          isAudioFilterable: optionsIsAudioFilterable,
        );
        await rtcEngine.updateChannelMediaOptions(
          options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[updateChannelMediaOptions] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'leaveChannel',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool optionsStopAudioMixing = true;
        const bool optionsStopAllEffect = true;
        const bool optionsStopMicrophoneRecording = true;
        const LeaveChannelOptions options = LeaveChannelOptions(
          stopAudioMixing: optionsStopAudioMixing,
          stopAllEffect: optionsStopAllEffect,
          stopMicrophoneRecording: optionsStopMicrophoneRecording,
        );
        await rtcEngine.leaveChannel(
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[leaveChannel] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'renewToken',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String token = "hello";
        await rtcEngine.renewToken(
          token,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[renewToken] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setChannelProfile',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const ChannelProfileType profile =
            ChannelProfileType.channelProfileCommunication;
        await rtcEngine.setChannelProfile(
          profile,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setChannelProfile] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setClientRole',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const ClientRoleType role = ClientRoleType.clientRoleBroadcaster;
        const AudienceLatencyLevelType optionsAudienceLatencyLevel =
            AudienceLatencyLevelType.audienceLatencyLevelLowLatency;
        const ClientRoleOptions options = ClientRoleOptions(
          audienceLatencyLevel: optionsAudienceLatencyLevel,
        );
        await rtcEngine.setClientRole(
          role: role,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setClientRole] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startEchoTest',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int intervalInSeconds = 10;
        await rtcEngine.startEchoTest(
          intervalInSeconds: intervalInSeconds,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startEchoTest] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopEchoTest',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopEchoTest();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopEchoTest] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableMultiCamera',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const CameraDirection configCameraDirection =
            CameraDirection.cameraRear;
        const int formatWidth = 10;
        const int formatHeight = 10;
        const int formatFps = 10;
        const VideoFormat configFormat = VideoFormat(
          width: formatWidth,
          height: formatHeight,
          fps: formatFps,
        );
        const String configDeviceId = "hello";
        const bool configFollowEncodeDimensionRatio = true;
        const CameraCapturerConfiguration config = CameraCapturerConfiguration(
          cameraDirection: configCameraDirection,
          deviceId: configDeviceId,
          format: configFormat,
          followEncodeDimensionRatio: configFollowEncodeDimensionRatio,
        );
        await rtcEngine.enableMultiCamera(
          enabled: enabled,
          config: config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableMultiCamera] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableVideo',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.enableVideo();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableVideo] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'disableVideo',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.disableVideo();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[disableVideo] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startPreview',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoSourceType sourceType =
            VideoSourceType.videoSourceCameraPrimary;
        await rtcEngine.startPreview(
          sourceType: sourceType,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startPreview] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopPreview',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoSourceType sourceType =
            VideoSourceType.videoSourceCameraPrimary;
        await rtcEngine.stopPreview(
          sourceType: sourceType,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopPreview] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startLastmileProbeTest',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool configProbeUplink = true;
        const bool configProbeDownlink = true;
        const int configExpectedUplinkBitrate = 10;
        const int configExpectedDownlinkBitrate = 10;
        const LastmileProbeConfig config = LastmileProbeConfig(
          probeUplink: configProbeUplink,
          probeDownlink: configProbeDownlink,
          expectedUplinkBitrate: configExpectedUplinkBitrate,
          expectedDownlinkBitrate: configExpectedDownlinkBitrate,
        );
        await rtcEngine.startLastmileProbeTest(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startLastmileProbeTest] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopLastmileProbeTest',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopLastmileProbeTest();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopLastmileProbeTest] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setVideoEncoderConfiguration',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoCodecType configCodecType = VideoCodecType.videoCodecNone;
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions configDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const OrientationMode configOrientationMode =
            OrientationMode.orientationModeAdaptive;
        const DegradationPreference configDegradationPreference =
            DegradationPreference.maintainQuality;
        const VideoMirrorModeType configMirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const EncodingPreference advanceOptionsEncodingPreference =
            EncodingPreference.preferAuto;
        const CompressionPreference advanceOptionsCompressionPreference =
            CompressionPreference.preferLowLatency;
        const AdvanceOptions configAdvanceOptions = AdvanceOptions(
          encodingPreference: advanceOptionsEncodingPreference,
          compressionPreference: advanceOptionsCompressionPreference,
        );
        const int configFrameRate = 10;
        const int configBitrate = 10;
        const int configMinBitrate = 10;
        const VideoEncoderConfiguration config = VideoEncoderConfiguration(
          codecType: configCodecType,
          dimensions: configDimensions,
          frameRate: configFrameRate,
          bitrate: configBitrate,
          minBitrate: configMinBitrate,
          orientationMode: configOrientationMode,
          degradationPreference: configDegradationPreference,
          mirrorMode: configMirrorMode,
          advanceOptions: configAdvanceOptions,
        );
        await rtcEngine.setVideoEncoderConfiguration(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setVideoEncoderConfiguration] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setBeautyEffectOptions',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const LighteningContrastLevel optionsLighteningContrastLevel =
            LighteningContrastLevel.lighteningContrastLow;
        const double optionsLighteningLevel = 10.0;
        const double optionsSmoothnessLevel = 10.0;
        const double optionsRednessLevel = 10.0;
        const double optionsSharpnessLevel = 10.0;
        const BeautyOptions options = BeautyOptions(
          lighteningContrastLevel: optionsLighteningContrastLevel,
          lighteningLevel: optionsLighteningLevel,
          smoothnessLevel: optionsSmoothnessLevel,
          rednessLevel: optionsRednessLevel,
          sharpnessLevel: optionsSharpnessLevel,
        );
        const MediaSourceType type = MediaSourceType.audioPlayoutSource;
        await rtcEngine.setBeautyEffectOptions(
          enabled: enabled,
          options: options,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setBeautyEffectOptions] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLowlightEnhanceOptions',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const LowLightEnhanceMode optionsMode =
            LowLightEnhanceMode.lowLightEnhanceAuto;
        const LowLightEnhanceLevel optionsLevel =
            LowLightEnhanceLevel.lowLightEnhanceLevelHighQuality;
        const LowlightEnhanceOptions options = LowlightEnhanceOptions(
          mode: optionsMode,
          level: optionsLevel,
        );
        const MediaSourceType type = MediaSourceType.audioPlayoutSource;
        await rtcEngine.setLowlightEnhanceOptions(
          enabled: enabled,
          options: options,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLowlightEnhanceOptions] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setVideoDenoiserOptions',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const VideoDenoiserMode optionsMode =
            VideoDenoiserMode.videoDenoiserAuto;
        const VideoDenoiserLevel optionsLevel =
            VideoDenoiserLevel.videoDenoiserLevelHighQuality;
        const VideoDenoiserOptions options = VideoDenoiserOptions(
          mode: optionsMode,
          level: optionsLevel,
        );
        const MediaSourceType type = MediaSourceType.audioPlayoutSource;
        await rtcEngine.setVideoDenoiserOptions(
          enabled: enabled,
          options: options,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setVideoDenoiserOptions] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setColorEnhanceOptions',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const double optionsStrengthLevel = 10.0;
        const double optionsSkinProtectLevel = 10.0;
        const ColorEnhanceOptions options = ColorEnhanceOptions(
          strengthLevel: optionsStrengthLevel,
          skinProtectLevel: optionsSkinProtectLevel,
        );
        const MediaSourceType type = MediaSourceType.audioPlayoutSource;
        await rtcEngine.setColorEnhanceOptions(
          enabled: enabled,
          options: options,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setColorEnhanceOptions] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableVirtualBackground',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const BackgroundSourceType backgroundSourceBackgroundSourceType =
            BackgroundSourceType.backgroundColor;
        const BackgroundBlurDegree backgroundSourceBlurDegree =
            BackgroundBlurDegree.blurDegreeLow;
        const int backgroundSourceColor = 10;
        const String backgroundSourceSource = "hello";
        const VirtualBackgroundSource backgroundSource =
            VirtualBackgroundSource(
          backgroundSourceType: backgroundSourceBackgroundSourceType,
          color: backgroundSourceColor,
          source: backgroundSourceSource,
          blurDegree: backgroundSourceBlurDegree,
        );
        const SegModelType segpropertyModelType = SegModelType.segModelAi;
        const double segpropertyGreenCapacity = 10.0;
        const SegmentationProperty segproperty = SegmentationProperty(
          modelType: segpropertyModelType,
          greenCapacity: segpropertyGreenCapacity,
        );
        const MediaSourceType type = MediaSourceType.audioPlayoutSource;
        await rtcEngine.enableVirtualBackground(
          enabled: enabled,
          backgroundSource: backgroundSource,
          segproperty: segproperty,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableVirtualBackground] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableRemoteSuperResolution',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int userId = 10;
        const bool enable = true;
        await rtcEngine.enableRemoteSuperResolution(
          userId: userId,
          enable: enable,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableRemoteSuperResolution] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setupRemoteVideo',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const RenderModeType canvasRenderMode = RenderModeType.renderModeHidden;
        const VideoMirrorModeType canvasMirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const VideoViewSetupMode canvasSetupMode =
            VideoViewSetupMode.videoViewSetupReplace;
        const VideoSourceType canvasSourceType =
            VideoSourceType.videoSourceCameraPrimary;
        const int cropAreaX = 10;
        const int cropAreaY = 10;
        const int cropAreaWidth = 10;
        const int cropAreaHeight = 10;
        const Rectangle canvasCropArea = Rectangle(
          x: cropAreaX,
          y: cropAreaY,
          width: cropAreaWidth,
          height: cropAreaHeight,
        );
        const int canvasView = 10;
        const int canvasUid = 10;
        const int canvasMediaPlayerId = 10;
        const VideoCanvas canvas = VideoCanvas(
          view: canvasView,
          uid: canvasUid,
          renderMode: canvasRenderMode,
          mirrorMode: canvasMirrorMode,
          setupMode: canvasSetupMode,
          sourceType: canvasSourceType,
          mediaPlayerId: canvasMediaPlayerId,
          cropArea: canvasCropArea,
        );
        await rtcEngine.setupRemoteVideo(
          canvas,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setupRemoteVideo] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setupLocalVideo',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const RenderModeType canvasRenderMode = RenderModeType.renderModeHidden;
        const VideoMirrorModeType canvasMirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const VideoViewSetupMode canvasSetupMode =
            VideoViewSetupMode.videoViewSetupReplace;
        const VideoSourceType canvasSourceType =
            VideoSourceType.videoSourceCameraPrimary;
        const int cropAreaX = 10;
        const int cropAreaY = 10;
        const int cropAreaWidth = 10;
        const int cropAreaHeight = 10;
        const Rectangle canvasCropArea = Rectangle(
          x: cropAreaX,
          y: cropAreaY,
          width: cropAreaWidth,
          height: cropAreaHeight,
        );
        const int canvasView = 10;
        const int canvasUid = 10;
        const int canvasMediaPlayerId = 10;
        const VideoCanvas canvas = VideoCanvas(
          view: canvasView,
          uid: canvasUid,
          renderMode: canvasRenderMode,
          mirrorMode: canvasMirrorMode,
          setupMode: canvasSetupMode,
          sourceType: canvasSourceType,
          mediaPlayerId: canvasMediaPlayerId,
          cropArea: canvasCropArea,
        );
        await rtcEngine.setupLocalVideo(
          canvas,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setupLocalVideo] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableAudio',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.enableAudio();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableAudio] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'disableAudio',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.disableAudio();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[disableAudio] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAudioProfile',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioProfileType profile = AudioProfileType.audioProfileDefault;
        const AudioScenarioType scenario =
            AudioScenarioType.audioScenarioDefault;
        await rtcEngine.setAudioProfile(
          profile: profile,
          scenario: scenario,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setAudioProfile] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAudioScenario',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioScenarioType scenario =
            AudioScenarioType.audioScenarioDefault;
        await rtcEngine.setAudioScenario(
          scenario,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setAudioScenario] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableLocalAudio',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngine.enableLocalAudio(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableLocalAudio] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'muteLocalAudioStream',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        await rtcEngine.muteLocalAudioStream(
          mute,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteLocalAudioStream] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'muteAllRemoteAudioStreams',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        await rtcEngine.muteAllRemoteAudioStreams(
          mute,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteAllRemoteAudioStreams] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setDefaultMuteAllRemoteAudioStreams',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        await rtcEngine.setDefaultMuteAllRemoteAudioStreams(
          mute,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setDefaultMuteAllRemoteAudioStreams] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'muteRemoteAudioStream',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const bool mute = true;
        await rtcEngine.muteRemoteAudioStream(
          uid: uid,
          mute: mute,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteRemoteAudioStream] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'muteLocalVideoStream',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        await rtcEngine.muteLocalVideoStream(
          mute,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteLocalVideoStream] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableLocalVideo',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngine.enableLocalVideo(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableLocalVideo] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'muteAllRemoteVideoStreams',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        await rtcEngine.muteAllRemoteVideoStreams(
          mute,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteAllRemoteVideoStreams] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setDefaultMuteAllRemoteVideoStreams',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        await rtcEngine.setDefaultMuteAllRemoteVideoStreams(
          mute,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setDefaultMuteAllRemoteVideoStreams] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'muteRemoteVideoStream',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const bool mute = true;
        await rtcEngine.muteRemoteVideoStream(
          uid: uid,
          mute: mute,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteRemoteVideoStream] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setRemoteVideoStreamType',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const VideoStreamType streamType = VideoStreamType.videoStreamHigh;
        await rtcEngine.setRemoteVideoStreamType(
          uid: uid,
          streamType: streamType,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setRemoteVideoStreamType] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setRemoteVideoSubscriptionOptions',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const VideoStreamType optionsType = VideoStreamType.videoStreamHigh;
        const bool optionsEncodedFrameOnly = true;
        const VideoSubscriptionOptions options = VideoSubscriptionOptions(
          type: optionsType,
          encodedFrameOnly: optionsEncodedFrameOnly,
        );
        await rtcEngine.setRemoteVideoSubscriptionOptions(
          uid: uid,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setRemoteVideoSubscriptionOptions] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setRemoteDefaultVideoStreamType',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoStreamType streamType = VideoStreamType.videoStreamHigh;
        await rtcEngine.setRemoteDefaultVideoStreamType(
          streamType,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setRemoteDefaultVideoStreamType] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableAudioVolumeIndication',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int interval = 10;
        const int smooth = 10;
        const bool reportVad = true;
        await rtcEngine.enableAudioVolumeIndication(
          interval: interval,
          smooth: smooth,
          reportVad: reportVad,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableAudioVolumeIndication] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startAudioRecording',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioFileRecordingType configFileRecordingType =
            AudioFileRecordingType.audioFileRecordingMic;
        const AudioRecordingQualityType configQuality =
            AudioRecordingQualityType.audioRecordingQualityLow;
        const String configFilePath = "hello";
        const bool configEncode = true;
        const int configSampleRate = 10;
        const int configRecordingChannel = 10;
        const AudioRecordingConfiguration config = AudioRecordingConfiguration(
          filePath: configFilePath,
          encode: configEncode,
          sampleRate: configSampleRate,
          fileRecordingType: configFileRecordingType,
          quality: configQuality,
          recordingChannel: configRecordingChannel,
        );
        await rtcEngine.startAudioRecording(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startAudioRecording] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'registerAudioEncodedFrameObserver',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioEncodedFrameObserverPosition configPostionType =
            AudioEncodedFrameObserverPosition
                .audioEncodedFrameObserverPositionRecord;
        const AudioEncodingType configEncodingType =
            AudioEncodingType.audioEncodingTypeAac16000Low;
        const AudioEncodedFrameObserverConfig config =
            AudioEncodedFrameObserverConfig(
          postionType: configPostionType,
          encodingType: configEncodingType,
        );
        final AudioEncodedFrameObserver observer = AudioEncodedFrameObserver(
          onRecordAudioEncodedFrame: (Uint8List frameBuffer, int length,
              EncodedAudioFrameInfo audioEncodedFrameInfo) {},
          onPlaybackAudioEncodedFrame: (Uint8List frameBuffer, int length,
              EncodedAudioFrameInfo audioEncodedFrameInfo) {},
          onMixedAudioEncodedFrame: (Uint8List frameBuffer, int length,
              EncodedAudioFrameInfo audioEncodedFrameInfo) {},
        );
        rtcEngine.registerAudioEncodedFrameObserver(
          config: config,
          observer: observer,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[registerAudioEncodedFrameObserver] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopAudioRecording',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopAudioRecording();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopAudioRecording] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startAudioMixing',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String filePath = "hello";
        const bool loopback = true;
        const int cycle = 10;
        const int startPos = 10;
        await rtcEngine.startAudioMixing(
          filePath: filePath,
          loopback: loopback,
          cycle: cycle,
          startPos: startPos,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startAudioMixing] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopAudioMixing',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopAudioMixing();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopAudioMixing] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'pauseAudioMixing',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.pauseAudioMixing();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[pauseAudioMixing] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'resumeAudioMixing',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.resumeAudioMixing();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[resumeAudioMixing] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'selectAudioTrack',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int index = 10;
        await rtcEngine.selectAudioTrack(
          index,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[selectAudioTrack] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getAudioTrackCount',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getAudioTrackCount();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getAudioTrackCount] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'adjustAudioMixingVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int volume = 10;
        await rtcEngine.adjustAudioMixingVolume(
          volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustAudioMixingVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'adjustAudioMixingPublishVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int volume = 10;
        await rtcEngine.adjustAudioMixingPublishVolume(
          volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustAudioMixingPublishVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getAudioMixingPublishVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getAudioMixingPublishVolume();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getAudioMixingPublishVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'adjustAudioMixingPlayoutVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int volume = 10;
        await rtcEngine.adjustAudioMixingPlayoutVolume(
          volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustAudioMixingPlayoutVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getAudioMixingPlayoutVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getAudioMixingPlayoutVolume();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getAudioMixingPlayoutVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getAudioMixingDuration',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getAudioMixingDuration();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getAudioMixingDuration] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getAudioMixingCurrentPosition',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getAudioMixingCurrentPosition();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getAudioMixingCurrentPosition] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAudioMixingPosition',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int pos = 10;
        await rtcEngine.setAudioMixingPosition(
          pos,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setAudioMixingPosition] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAudioMixingDualMonoMode',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioMixingDualMonoMode mode =
            AudioMixingDualMonoMode.audioMixingDualMonoAuto;
        await rtcEngine.setAudioMixingDualMonoMode(
          mode,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setAudioMixingDualMonoMode] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAudioMixingPitch',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int pitch = 10;
        await rtcEngine.setAudioMixingPitch(
          pitch,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setAudioMixingPitch] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getEffectsVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getEffectsVolume();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getEffectsVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setEffectsVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int volume = 10;
        await rtcEngine.setEffectsVolume(
          volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setEffectsVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'preloadEffect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        const String filePath = "hello";
        const int startPos = 10;
        await rtcEngine.preloadEffect(
          soundId: soundId,
          filePath: filePath,
          startPos: startPos,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[preloadEffect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'playEffect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        const String filePath = "hello";
        const int loopCount = 10;
        const double pitch = 10.0;
        const double pan = 10.0;
        const int gain = 10;
        const bool publish = true;
        const int startPos = 10;
        await rtcEngine.playEffect(
          soundId: soundId,
          filePath: filePath,
          loopCount: loopCount,
          pitch: pitch,
          pan: pan,
          gain: gain,
          publish: publish,
          startPos: startPos,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[playEffect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'playAllEffects',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int loopCount = 10;
        const double pitch = 10.0;
        const double pan = 10.0;
        const int gain = 10;
        const bool publish = true;
        await rtcEngine.playAllEffects(
          loopCount: loopCount,
          pitch: pitch,
          pan: pan,
          gain: gain,
          publish: publish,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[playAllEffects] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getVolumeOfEffect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        await rtcEngine.getVolumeOfEffect(
          soundId,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getVolumeOfEffect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setVolumeOfEffect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        const int volume = 10;
        await rtcEngine.setVolumeOfEffect(
          soundId: soundId,
          volume: volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setVolumeOfEffect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'pauseEffect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        await rtcEngine.pauseEffect(
          soundId,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[pauseEffect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'pauseAllEffects',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.pauseAllEffects();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[pauseAllEffects] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'resumeEffect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        await rtcEngine.resumeEffect(
          soundId,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[resumeEffect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'resumeAllEffects',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.resumeAllEffects();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[resumeAllEffects] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopEffect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        await rtcEngine.stopEffect(
          soundId,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopEffect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopAllEffects',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopAllEffects();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopAllEffects] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'unloadEffect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        await rtcEngine.unloadEffect(
          soundId,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[unloadEffect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'unloadAllEffects',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.unloadAllEffects();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[unloadAllEffects] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getEffectDuration',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String filePath = "hello";
        await rtcEngine.getEffectDuration(
          filePath,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getEffectDuration] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setEffectPosition',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        const int pos = 10;
        await rtcEngine.setEffectPosition(
          soundId: soundId,
          pos: pos,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setEffectPosition] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getEffectCurrentPosition',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int soundId = 10;
        await rtcEngine.getEffectCurrentPosition(
          soundId,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getEffectCurrentPosition] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableSoundPositionIndication',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngine.enableSoundPositionIndication(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableSoundPositionIndication] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setRemoteVoicePosition',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const double pan = 10.0;
        const double gain = 10.0;
        await rtcEngine.setRemoteVoicePosition(
          uid: uid,
          pan: pan,
          gain: gain,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setRemoteVoicePosition] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableSpatialAudio',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngine.enableSpatialAudio(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableSpatialAudio] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setRemoteUserSpatialAudioParams',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const double paramsSpeakerAzimuth = 10.0;
        const double paramsSpeakerElevation = 10.0;
        const double paramsSpeakerDistance = 10.0;
        const int paramsSpeakerOrientation = 10;
        const bool paramsEnableBlur = true;
        const bool paramsEnableAirAbsorb = true;
        const double paramsSpeakerAttenuation = 10.0;
        const bool paramsEnableDoppler = true;
        const SpatialAudioParams params = SpatialAudioParams(
          speakerAzimuth: paramsSpeakerAzimuth,
          speakerElevation: paramsSpeakerElevation,
          speakerDistance: paramsSpeakerDistance,
          speakerOrientation: paramsSpeakerOrientation,
          enableBlur: paramsEnableBlur,
          enableAirAbsorb: paramsEnableAirAbsorb,
          speakerAttenuation: paramsSpeakerAttenuation,
          enableDoppler: paramsEnableDoppler,
        );
        await rtcEngine.setRemoteUserSpatialAudioParams(
          uid: uid,
          params: params,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setRemoteUserSpatialAudioParams] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setVoiceBeautifierPreset',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VoiceBeautifierPreset preset =
            VoiceBeautifierPreset.voiceBeautifierOff;
        await rtcEngine.setVoiceBeautifierPreset(
          preset,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setVoiceBeautifierPreset] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAudioEffectPreset',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioEffectPreset preset = AudioEffectPreset.audioEffectOff;
        await rtcEngine.setAudioEffectPreset(
          preset,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setAudioEffectPreset] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setVoiceConversionPreset',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VoiceConversionPreset preset =
            VoiceConversionPreset.voiceConversionOff;
        await rtcEngine.setVoiceConversionPreset(
          preset,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setVoiceConversionPreset] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAudioEffectParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioEffectPreset preset = AudioEffectPreset.audioEffectOff;
        const int param1 = 10;
        const int param2 = 10;
        await rtcEngine.setAudioEffectParameters(
          preset: preset,
          param1: param1,
          param2: param2,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setAudioEffectParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setVoiceBeautifierParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VoiceBeautifierPreset preset =
            VoiceBeautifierPreset.voiceBeautifierOff;
        const int param1 = 10;
        const int param2 = 10;
        await rtcEngine.setVoiceBeautifierParameters(
          preset: preset,
          param1: param1,
          param2: param2,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setVoiceBeautifierParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setVoiceConversionParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VoiceConversionPreset preset =
            VoiceConversionPreset.voiceConversionOff;
        const int param1 = 10;
        const int param2 = 10;
        await rtcEngine.setVoiceConversionParameters(
          preset: preset,
          param1: param1,
          param2: param2,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setVoiceConversionParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLocalVoicePitch',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const double pitch = 10.0;
        await rtcEngine.setLocalVoicePitch(
          pitch,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLocalVoicePitch] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLocalVoiceEqualization',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioEqualizationBandFrequency bandFrequency =
            AudioEqualizationBandFrequency.audioEqualizationBand31;
        const int bandGain = 10;
        await rtcEngine.setLocalVoiceEqualization(
          bandFrequency: bandFrequency,
          bandGain: bandGain,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLocalVoiceEqualization] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLocalVoiceReverb',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioReverbType reverbKey = AudioReverbType.audioReverbDryLevel;
        const int value = 10;
        await rtcEngine.setLocalVoiceReverb(
          reverbKey: reverbKey,
          value: value,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLocalVoiceReverb] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setHeadphoneEQPreset',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const HeadphoneEqualizerPreset preset =
            HeadphoneEqualizerPreset.headphoneEqualizerOff;
        await rtcEngine.setHeadphoneEQPreset(
          preset,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setHeadphoneEQPreset] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setHeadphoneEQParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int lowGain = 10;
        const int highGain = 10;
        await rtcEngine.setHeadphoneEQParameters(
          lowGain: lowGain,
          highGain: highGain,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setHeadphoneEQParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLogFile',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String filePath = "hello";
        await rtcEngine.setLogFile(
          filePath,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLogFile] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLogFilter',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const LogFilterType filter = LogFilterType.logFilterOff;
        await rtcEngine.setLogFilter(
          filter,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLogFilter] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLogLevel',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const LogLevel level = LogLevel.logLevelNone;
        await rtcEngine.setLogLevel(
          level,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLogLevel] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLogFileSize',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int fileSizeInKBytes = 10;
        await rtcEngine.setLogFileSize(
          fileSizeInKBytes,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLogFileSize] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'uploadLogFile',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String requestId = "hello";
        await rtcEngine.uploadLogFile(
          requestId,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[uploadLogFile] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLocalRenderMode',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const RenderModeType renderMode = RenderModeType.renderModeHidden;
        const VideoMirrorModeType mirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        await rtcEngine.setLocalRenderMode(
          renderMode: renderMode,
          mirrorMode: mirrorMode,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLocalRenderMode] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setRemoteRenderMode',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const RenderModeType renderMode = RenderModeType.renderModeHidden;
        const VideoMirrorModeType mirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        await rtcEngine.setRemoteRenderMode(
          uid: uid,
          renderMode: renderMode,
          mirrorMode: mirrorMode,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setRemoteRenderMode] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLocalVideoMirrorMode',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoMirrorModeType mirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        await rtcEngine.setLocalVideoMirrorMode(
          mirrorMode,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLocalVideoMirrorMode] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableDualStreamMode',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions streamConfigDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int streamConfigKBitrate = 10;
        const int streamConfigFramerate = 10;
        const SimulcastStreamConfig streamConfig = SimulcastStreamConfig(
          dimensions: streamConfigDimensions,
          kBitrate: streamConfigKBitrate,
          framerate: streamConfigFramerate,
        );
        await rtcEngine.enableDualStreamMode(
          enabled: enabled,
          streamConfig: streamConfig,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableDualStreamMode] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setDualStreamMode',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const SimulcastStreamMode mode =
            SimulcastStreamMode.autoSimulcastStream;
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions streamConfigDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int streamConfigKBitrate = 10;
        const int streamConfigFramerate = 10;
        const SimulcastStreamConfig streamConfig = SimulcastStreamConfig(
          dimensions: streamConfigDimensions,
          kBitrate: streamConfigKBitrate,
          framerate: streamConfigFramerate,
        );
        await rtcEngine.setDualStreamMode(
          mode: mode,
          streamConfig: streamConfig,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setDualStreamMode] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableEchoCancellationExternal',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const int audioSourceDelay = 10;
        await rtcEngine.enableEchoCancellationExternal(
          enabled: enabled,
          audioSourceDelay: audioSourceDelay,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableEchoCancellationExternal] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableCustomAudioLocalPlayback',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int sourceId = 10;
        const bool enabled = true;
        await rtcEngine.enableCustomAudioLocalPlayback(
          sourceId: sourceId,
          enabled: enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableCustomAudioLocalPlayback] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startPrimaryCustomAudioTrack',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool configEnableLocalPlayback = true;
        const AudioTrackConfig config = AudioTrackConfig(
          enableLocalPlayback: configEnableLocalPlayback,
        );
        await rtcEngine.startPrimaryCustomAudioTrack(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startPrimaryCustomAudioTrack] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopPrimaryCustomAudioTrack',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopPrimaryCustomAudioTrack();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopPrimaryCustomAudioTrack] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startSecondaryCustomAudioTrack',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool configEnableLocalPlayback = true;
        const AudioTrackConfig config = AudioTrackConfig(
          enableLocalPlayback: configEnableLocalPlayback,
        );
        await rtcEngine.startSecondaryCustomAudioTrack(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startSecondaryCustomAudioTrack] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopSecondaryCustomAudioTrack',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopSecondaryCustomAudioTrack();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopSecondaryCustomAudioTrack] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setRecordingAudioFrameParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int sampleRate = 10;
        const int channel = 10;
        const RawAudioFrameOpModeType mode =
            RawAudioFrameOpModeType.rawAudioFrameOpModeReadOnly;
        const int samplesPerCall = 10;
        await rtcEngine.setRecordingAudioFrameParameters(
          sampleRate: sampleRate,
          channel: channel,
          mode: mode,
          samplesPerCall: samplesPerCall,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setRecordingAudioFrameParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setPlaybackAudioFrameParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int sampleRate = 10;
        const int channel = 10;
        const RawAudioFrameOpModeType mode =
            RawAudioFrameOpModeType.rawAudioFrameOpModeReadOnly;
        const int samplesPerCall = 10;
        await rtcEngine.setPlaybackAudioFrameParameters(
          sampleRate: sampleRate,
          channel: channel,
          mode: mode,
          samplesPerCall: samplesPerCall,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setPlaybackAudioFrameParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setMixedAudioFrameParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int sampleRate = 10;
        const int channel = 10;
        const int samplesPerCall = 10;
        await rtcEngine.setMixedAudioFrameParameters(
          sampleRate: sampleRate,
          channel: channel,
          samplesPerCall: samplesPerCall,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setMixedAudioFrameParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setEarMonitoringAudioFrameParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int sampleRate = 10;
        const int channel = 10;
        const RawAudioFrameOpModeType mode =
            RawAudioFrameOpModeType.rawAudioFrameOpModeReadOnly;
        const int samplesPerCall = 10;
        await rtcEngine.setEarMonitoringAudioFrameParameters(
          sampleRate: sampleRate,
          channel: channel,
          mode: mode,
          samplesPerCall: samplesPerCall,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setEarMonitoringAudioFrameParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setPlaybackAudioFrameBeforeMixingParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int sampleRate = 10;
        const int channel = 10;
        await rtcEngine.setPlaybackAudioFrameBeforeMixingParameters(
          sampleRate: sampleRate,
          channel: channel,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setPlaybackAudioFrameBeforeMixingParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableAudioSpectrumMonitor',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int intervalInMS = 10;
        await rtcEngine.enableAudioSpectrumMonitor(
          intervalInMS: intervalInMS,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableAudioSpectrumMonitor] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'disableAudioSpectrumMonitor',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.disableAudioSpectrumMonitor();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[disableAudioSpectrumMonitor] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'registerAudioSpectrumObserver',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        final AudioSpectrumObserver observer = AudioSpectrumObserver(
          onLocalAudioSpectrum: (AudioSpectrumData data) {},
          onRemoteAudioSpectrum: (List spectrums, int spectrumNumber) {},
        );
        rtcEngine.registerAudioSpectrumObserver(
          observer,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[registerAudioSpectrumObserver] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'unregisterAudioSpectrumObserver',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        final AudioSpectrumObserver observer = AudioSpectrumObserver(
          onLocalAudioSpectrum: (AudioSpectrumData data) {},
          onRemoteAudioSpectrum: (List spectrums, int spectrumNumber) {},
        );
        rtcEngine.unregisterAudioSpectrumObserver(
          observer,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[unregisterAudioSpectrumObserver] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'adjustRecordingSignalVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int volume = 10;
        await rtcEngine.adjustRecordingSignalVolume(
          volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustRecordingSignalVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'muteRecordingSignal',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool mute = true;
        await rtcEngine.muteRecordingSignal(
          mute,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[muteRecordingSignal] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'adjustPlaybackSignalVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int volume = 10;
        await rtcEngine.adjustPlaybackSignalVolume(
          volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustPlaybackSignalVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'adjustUserPlaybackSignalVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const int volume = 10;
        await rtcEngine.adjustUserPlaybackSignalVolume(
          uid: uid,
          volume: volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustUserPlaybackSignalVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setLocalPublishFallbackOption',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const StreamFallbackOptions option =
            StreamFallbackOptions.streamFallbackOptionDisabled;
        await rtcEngine.setLocalPublishFallbackOption(
          option,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setLocalPublishFallbackOption] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setRemoteSubscribeFallbackOption',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const StreamFallbackOptions option =
            StreamFallbackOptions.streamFallbackOptionDisabled;
        await rtcEngine.setRemoteSubscribeFallbackOption(
          option,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setRemoteSubscribeFallbackOption] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableLoopbackRecording',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const String deviceName = "hello";
        await rtcEngine.enableLoopbackRecording(
          enabled: enabled,
          deviceName: deviceName,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableLoopbackRecording] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'adjustLoopbackSignalVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int volume = 10;
        await rtcEngine.adjustLoopbackSignalVolume(
          volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustLoopbackSignalVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getLoopbackRecordingVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getLoopbackRecordingVolume();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getLoopbackRecordingVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableInEarMonitoring',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const EarMonitoringFilterType includeAudioFilters =
            EarMonitoringFilterType.earMonitoringFilterNone;
        await rtcEngine.enableInEarMonitoring(
          enabled: enabled,
          includeAudioFilters: includeAudioFilters,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableInEarMonitoring] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setInEarMonitoringVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int volume = 10;
        await rtcEngine.setInEarMonitoringVolume(
          volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setInEarMonitoringVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'loadExtensionProvider',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String path = "hello";
        const bool unloadAfterUse = true;
        await rtcEngine.loadExtensionProvider(
          path: path,
          unloadAfterUse: unloadAfterUse,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[loadExtensionProvider] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setExtensionProviderProperty',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String provider = "hello";
        const String key = "hello";
        const String value = "hello";
        await rtcEngine.setExtensionProviderProperty(
          provider: provider,
          key: key,
          value: value,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setExtensionProviderProperty] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'registerExtension',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String provider = "hello";
        const String extension = "hello";
        const MediaSourceType type = MediaSourceType.audioPlayoutSource;
        await rtcEngine.registerExtension(
          provider: provider,
          extension: extension,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[registerExtension] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableExtension',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String provider = "hello";
        const String extension = "hello";
        const bool enable = true;
        const MediaSourceType type = MediaSourceType.audioPlayoutSource;
        await rtcEngine.enableExtension(
          provider: provider,
          extension: extension,
          enable: enable,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableExtension] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setExtensionProperty',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String provider = "hello";
        const String extension = "hello";
        const String key = "hello";
        const String value = "hello";
        const MediaSourceType type = MediaSourceType.audioPlayoutSource;
        await rtcEngine.setExtensionProperty(
          provider: provider,
          extension: extension,
          key: key,
          value: value,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setExtensionProperty] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getExtensionProperty',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String provider = "hello";
        const String extension = "hello";
        const String key = "hello";
        const int bufLen = 10;
        const MediaSourceType type = MediaSourceType.audioPlayoutSource;
        await rtcEngine.getExtensionProperty(
          provider: provider,
          extension: extension,
          key: key,
          bufLen: bufLen,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getExtensionProperty] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setCameraCapturerConfiguration',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const CameraDirection configCameraDirection =
            CameraDirection.cameraRear;
        const int formatWidth = 10;
        const int formatHeight = 10;
        const int formatFps = 10;
        const VideoFormat configFormat = VideoFormat(
          width: formatWidth,
          height: formatHeight,
          fps: formatFps,
        );
        const String configDeviceId = "hello";
        const bool configFollowEncodeDimensionRatio = true;
        const CameraCapturerConfiguration config = CameraCapturerConfiguration(
          cameraDirection: configCameraDirection,
          deviceId: configDeviceId,
          format: configFormat,
          followEncodeDimensionRatio: configFollowEncodeDimensionRatio,
        );
        await rtcEngine.setCameraCapturerConfiguration(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setCameraCapturerConfiguration] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'destroyCustomVideoTrack',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int videoTrackId = 10;
        await rtcEngine.destroyCustomVideoTrack(
          videoTrackId,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[destroyCustomVideoTrack] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'destroyCustomEncodedVideoTrack',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int videoTrackId = 10;
        await rtcEngine.destroyCustomEncodedVideoTrack(
          videoTrackId,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[destroyCustomEncodedVideoTrack] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'switchCamera',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.switchCamera();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[switchCamera] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'isCameraZoomSupported',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.isCameraZoomSupported();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[isCameraZoomSupported] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'isCameraFaceDetectSupported',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.isCameraFaceDetectSupported();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[isCameraFaceDetectSupported] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'isCameraTorchSupported',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.isCameraTorchSupported();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[isCameraTorchSupported] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'isCameraFocusSupported',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.isCameraFocusSupported();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[isCameraFocusSupported] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'isCameraAutoFocusFaceModeSupported',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.isCameraAutoFocusFaceModeSupported();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[isCameraAutoFocusFaceModeSupported] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setCameraZoomFactor',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const double factor = 10.0;
        await rtcEngine.setCameraZoomFactor(
          factor,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setCameraZoomFactor] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableFaceDetection',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngine.enableFaceDetection(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableFaceDetection] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getCameraMaxZoomFactor',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getCameraMaxZoomFactor();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getCameraMaxZoomFactor] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setCameraFocusPositionInPreview',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const double positionX = 10.0;
        const double positionY = 10.0;
        await rtcEngine.setCameraFocusPositionInPreview(
          positionX: positionX,
          positionY: positionY,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setCameraFocusPositionInPreview] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setCameraTorchOn',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool isOn = true;
        await rtcEngine.setCameraTorchOn(
          isOn,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setCameraTorchOn] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setCameraAutoFocusFaceModeEnabled',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngine.setCameraAutoFocusFaceModeEnabled(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setCameraAutoFocusFaceModeEnabled] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'isCameraExposurePositionSupported',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.isCameraExposurePositionSupported();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[isCameraExposurePositionSupported] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setCameraExposurePosition',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const double positionXinView = 10.0;
        const double positionYinView = 10.0;
        await rtcEngine.setCameraExposurePosition(
          positionXinView: positionXinView,
          positionYinView: positionYinView,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setCameraExposurePosition] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'isCameraAutoExposureFaceModeSupported',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.isCameraAutoExposureFaceModeSupported();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[isCameraAutoExposureFaceModeSupported] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setCameraAutoExposureFaceModeEnabled',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngine.setCameraAutoExposureFaceModeEnabled(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setCameraAutoExposureFaceModeEnabled] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setDefaultAudioRouteToSpeakerphone',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool defaultToSpeaker = true;
        await rtcEngine.setDefaultAudioRouteToSpeakerphone(
          defaultToSpeaker,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setDefaultAudioRouteToSpeakerphone] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setEnableSpeakerphone',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool speakerOn = true;
        await rtcEngine.setEnableSpeakerphone(
          speakerOn,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setEnableSpeakerphone] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'isSpeakerphoneEnabled',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.isSpeakerphoneEnabled();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[isSpeakerphoneEnabled] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getScreenCaptureSources',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int thumbSizeWidth = 10;
        const int thumbSizeHeight = 10;
        const SIZE thumbSize = SIZE(
          width: thumbSizeWidth,
          height: thumbSizeHeight,
        );
        const int iconSizeWidth = 10;
        const int iconSizeHeight = 10;
        const SIZE iconSize = SIZE(
          width: iconSizeWidth,
          height: iconSizeHeight,
        );
        const bool includeScreen = true;
        await rtcEngine.getScreenCaptureSources(
          thumbSize: thumbSize,
          iconSize: iconSize,
          includeScreen: includeScreen,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getScreenCaptureSources] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAudioSessionOperationRestriction',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioSessionOperationRestriction restriction =
            AudioSessionOperationRestriction
                .audioSessionOperationRestrictionNone;
        await rtcEngine.setAudioSessionOperationRestriction(
          restriction,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setAudioSessionOperationRestriction] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startScreenCaptureByDisplayId',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int displayId = 10;
        const int regionRectX = 10;
        const int regionRectY = 10;
        const int regionRectWidth = 10;
        const int regionRectHeight = 10;
        const Rectangle regionRect = Rectangle(
          x: regionRectX,
          y: regionRectY,
          width: regionRectWidth,
          height: regionRectHeight,
        );
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions captureParamsDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int captureParamsFrameRate = 10;
        const int captureParamsBitrate = 10;
        const bool captureParamsCaptureMouseCursor = true;
        const bool captureParamsWindowFocus = true;
        const List<int> captureParamsExcludeWindowList = [];
        const int captureParamsExcludeWindowCount = 10;
        const int captureParamsHighLightWidth = 10;
        const int captureParamsHighLightColor = 10;
        const bool captureParamsEnableHighLight = true;
        const ScreenCaptureParameters captureParams = ScreenCaptureParameters(
          dimensions: captureParamsDimensions,
          frameRate: captureParamsFrameRate,
          bitrate: captureParamsBitrate,
          captureMouseCursor: captureParamsCaptureMouseCursor,
          windowFocus: captureParamsWindowFocus,
          excludeWindowList: captureParamsExcludeWindowList,
          excludeWindowCount: captureParamsExcludeWindowCount,
          highLightWidth: captureParamsHighLightWidth,
          highLightColor: captureParamsHighLightColor,
          enableHighLight: captureParamsEnableHighLight,
        );
        await rtcEngine.startScreenCaptureByDisplayId(
          displayId: displayId,
          regionRect: regionRect,
          captureParams: captureParams,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startScreenCaptureByDisplayId] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startScreenCaptureByScreenRect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int screenRectX = 10;
        const int screenRectY = 10;
        const int screenRectWidth = 10;
        const int screenRectHeight = 10;
        const Rectangle screenRect = Rectangle(
          x: screenRectX,
          y: screenRectY,
          width: screenRectWidth,
          height: screenRectHeight,
        );
        const int regionRectX = 10;
        const int regionRectY = 10;
        const int regionRectWidth = 10;
        const int regionRectHeight = 10;
        const Rectangle regionRect = Rectangle(
          x: regionRectX,
          y: regionRectY,
          width: regionRectWidth,
          height: regionRectHeight,
        );
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions captureParamsDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int captureParamsFrameRate = 10;
        const int captureParamsBitrate = 10;
        const bool captureParamsCaptureMouseCursor = true;
        const bool captureParamsWindowFocus = true;
        const List<int> captureParamsExcludeWindowList = [];
        const int captureParamsExcludeWindowCount = 10;
        const int captureParamsHighLightWidth = 10;
        const int captureParamsHighLightColor = 10;
        const bool captureParamsEnableHighLight = true;
        const ScreenCaptureParameters captureParams = ScreenCaptureParameters(
          dimensions: captureParamsDimensions,
          frameRate: captureParamsFrameRate,
          bitrate: captureParamsBitrate,
          captureMouseCursor: captureParamsCaptureMouseCursor,
          windowFocus: captureParamsWindowFocus,
          excludeWindowList: captureParamsExcludeWindowList,
          excludeWindowCount: captureParamsExcludeWindowCount,
          highLightWidth: captureParamsHighLightWidth,
          highLightColor: captureParamsHighLightColor,
          enableHighLight: captureParamsEnableHighLight,
        );
        await rtcEngine.startScreenCaptureByScreenRect(
          screenRect: screenRect,
          regionRect: regionRect,
          captureParams: captureParams,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startScreenCaptureByScreenRect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getAudioDeviceInfo',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getAudioDeviceInfo();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getAudioDeviceInfo] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startScreenCaptureByWindowId',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int windowId = 10;
        const int regionRectX = 10;
        const int regionRectY = 10;
        const int regionRectWidth = 10;
        const int regionRectHeight = 10;
        const Rectangle regionRect = Rectangle(
          x: regionRectX,
          y: regionRectY,
          width: regionRectWidth,
          height: regionRectHeight,
        );
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions captureParamsDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int captureParamsFrameRate = 10;
        const int captureParamsBitrate = 10;
        const bool captureParamsCaptureMouseCursor = true;
        const bool captureParamsWindowFocus = true;
        const List<int> captureParamsExcludeWindowList = [];
        const int captureParamsExcludeWindowCount = 10;
        const int captureParamsHighLightWidth = 10;
        const int captureParamsHighLightColor = 10;
        const bool captureParamsEnableHighLight = true;
        const ScreenCaptureParameters captureParams = ScreenCaptureParameters(
          dimensions: captureParamsDimensions,
          frameRate: captureParamsFrameRate,
          bitrate: captureParamsBitrate,
          captureMouseCursor: captureParamsCaptureMouseCursor,
          windowFocus: captureParamsWindowFocus,
          excludeWindowList: captureParamsExcludeWindowList,
          excludeWindowCount: captureParamsExcludeWindowCount,
          highLightWidth: captureParamsHighLightWidth,
          highLightColor: captureParamsHighLightColor,
          enableHighLight: captureParamsEnableHighLight,
        );
        await rtcEngine.startScreenCaptureByWindowId(
          windowId: windowId,
          regionRect: regionRect,
          captureParams: captureParams,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startScreenCaptureByWindowId] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setScreenCaptureContentHint',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoContentHint contentHint = VideoContentHint.contentHintNone;
        await rtcEngine.setScreenCaptureContentHint(
          contentHint,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setScreenCaptureContentHint] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setScreenCaptureScenario',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const ScreenScenarioType screenScenario =
            ScreenScenarioType.screenScenarioDocument;
        await rtcEngine.setScreenCaptureScenario(
          screenScenario,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setScreenCaptureScenario] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'updateScreenCaptureRegion',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int regionRectX = 10;
        const int regionRectY = 10;
        const int regionRectWidth = 10;
        const int regionRectHeight = 10;
        const Rectangle regionRect = Rectangle(
          x: regionRectX,
          y: regionRectY,
          width: regionRectWidth,
          height: regionRectHeight,
        );
        await rtcEngine.updateScreenCaptureRegion(
          regionRect,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[updateScreenCaptureRegion] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'updateScreenCaptureParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions captureParamsDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int captureParamsFrameRate = 10;
        const int captureParamsBitrate = 10;
        const bool captureParamsCaptureMouseCursor = true;
        const bool captureParamsWindowFocus = true;
        const List<int> captureParamsExcludeWindowList = [];
        const int captureParamsExcludeWindowCount = 10;
        const int captureParamsHighLightWidth = 10;
        const int captureParamsHighLightColor = 10;
        const bool captureParamsEnableHighLight = true;
        const ScreenCaptureParameters captureParams = ScreenCaptureParameters(
          dimensions: captureParamsDimensions,
          frameRate: captureParamsFrameRate,
          bitrate: captureParamsBitrate,
          captureMouseCursor: captureParamsCaptureMouseCursor,
          windowFocus: captureParamsWindowFocus,
          excludeWindowList: captureParamsExcludeWindowList,
          excludeWindowCount: captureParamsExcludeWindowCount,
          highLightWidth: captureParamsHighLightWidth,
          highLightColor: captureParamsHighLightColor,
          enableHighLight: captureParamsEnableHighLight,
        );
        await rtcEngine.updateScreenCaptureParameters(
          captureParams,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[updateScreenCaptureParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startScreenCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int audioParamsSampleRate = 10;
        const int audioParamsChannels = 10;
        const int audioParamsCaptureSignalVolume = 10;
        const ScreenAudioParameters captureParamsAudioParams =
            ScreenAudioParameters(
          sampleRate: audioParamsSampleRate,
          channels: audioParamsChannels,
          captureSignalVolume: audioParamsCaptureSignalVolume,
        );
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions videoParamsDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const VideoContentHint videoParamsContentHint =
            VideoContentHint.contentHintNone;
        const int videoParamsFrameRate = 10;
        const int videoParamsBitrate = 10;
        const ScreenVideoParameters captureParamsVideoParams =
            ScreenVideoParameters(
          dimensions: videoParamsDimensions,
          frameRate: videoParamsFrameRate,
          bitrate: videoParamsBitrate,
          contentHint: videoParamsContentHint,
        );
        const bool captureParamsCaptureAudio = true;
        const bool captureParamsCaptureVideo = true;
        const ScreenCaptureParameters2 captureParams = ScreenCaptureParameters2(
          captureAudio: captureParamsCaptureAudio,
          audioParams: captureParamsAudioParams,
          captureVideo: captureParamsCaptureVideo,
          videoParams: captureParamsVideoParams,
        );
        await rtcEngine.startScreenCapture(
          captureParams,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startScreenCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'updateScreenCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int audioParamsSampleRate = 10;
        const int audioParamsChannels = 10;
        const int audioParamsCaptureSignalVolume = 10;
        const ScreenAudioParameters captureParamsAudioParams =
            ScreenAudioParameters(
          sampleRate: audioParamsSampleRate,
          channels: audioParamsChannels,
          captureSignalVolume: audioParamsCaptureSignalVolume,
        );
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions videoParamsDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const VideoContentHint videoParamsContentHint =
            VideoContentHint.contentHintNone;
        const int videoParamsFrameRate = 10;
        const int videoParamsBitrate = 10;
        const ScreenVideoParameters captureParamsVideoParams =
            ScreenVideoParameters(
          dimensions: videoParamsDimensions,
          frameRate: videoParamsFrameRate,
          bitrate: videoParamsBitrate,
          contentHint: videoParamsContentHint,
        );
        const bool captureParamsCaptureAudio = true;
        const bool captureParamsCaptureVideo = true;
        const ScreenCaptureParameters2 captureParams = ScreenCaptureParameters2(
          captureAudio: captureParamsCaptureAudio,
          audioParams: captureParamsAudioParams,
          captureVideo: captureParamsCaptureVideo,
          videoParams: captureParamsVideoParams,
        );
        await rtcEngine.updateScreenCapture(
          captureParams,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[updateScreenCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopScreenCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopScreenCapture();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopScreenCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getCallId',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getCallId();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getCallId] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'rate',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String callId = "hello";
        const int rating = 10;
        const String description = "hello";
        await rtcEngine.rate(
          callId: callId,
          rating: rating,
          description: description,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[rate] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'complain',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String callId = "hello";
        const String description = "hello";
        await rtcEngine.complain(
          callId: callId,
          description: description,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[complain] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startRtmpStreamWithoutTranscoding',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String url = "hello";
        await rtcEngine.startRtmpStreamWithoutTranscoding(
          url,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[startRtmpStreamWithoutTranscoding] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startRtmpStreamWithTranscoding',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String url = "hello";
        const VideoCodecProfileType transcodingVideoCodecProfile =
            VideoCodecProfileType.videoCodecProfileBaseline;
        const VideoCodecTypeForStream transcodingVideoCodecType =
            VideoCodecTypeForStream.videoCodecH264ForStream;
        const AudioSampleRateType transcodingAudioSampleRate =
            AudioSampleRateType.audioSampleRate32000;
        const AudioCodecProfileType transcodingAudioCodecProfile =
            AudioCodecProfileType.audioCodecProfileLcAac;
        const int transcodingWidth = 10;
        const int transcodingHeight = 10;
        const int transcodingVideoBitrate = 10;
        const int transcodingVideoFramerate = 10;
        const bool transcodingLowLatency = true;
        const int transcodingVideoGop = 10;
        const int transcodingBackgroundColor = 10;
        const int transcodingUserCount = 10;
        const List<TranscodingUser> transcodingTranscodingUsers = [];
        const String transcodingTranscodingExtraInfo = "hello";
        const String transcodingMetadata = "hello";
        const List<RtcImage> transcodingWatermark = [];
        const int transcodingWatermarkCount = 10;
        const List<RtcImage> transcodingBackgroundImage = [];
        const int transcodingBackgroundImageCount = 10;
        const int transcodingAudioBitrate = 10;
        const int transcodingAudioChannels = 10;
        const List<LiveStreamAdvancedFeature> transcodingAdvancedFeatures = [];
        const int transcodingAdvancedFeatureCount = 10;
        const LiveTranscoding transcoding = LiveTranscoding(
          width: transcodingWidth,
          height: transcodingHeight,
          videoBitrate: transcodingVideoBitrate,
          videoFramerate: transcodingVideoFramerate,
          lowLatency: transcodingLowLatency,
          videoGop: transcodingVideoGop,
          videoCodecProfile: transcodingVideoCodecProfile,
          backgroundColor: transcodingBackgroundColor,
          videoCodecType: transcodingVideoCodecType,
          userCount: transcodingUserCount,
          transcodingUsers: transcodingTranscodingUsers,
          transcodingExtraInfo: transcodingTranscodingExtraInfo,
          metadata: transcodingMetadata,
          watermark: transcodingWatermark,
          watermarkCount: transcodingWatermarkCount,
          backgroundImage: transcodingBackgroundImage,
          backgroundImageCount: transcodingBackgroundImageCount,
          audioSampleRate: transcodingAudioSampleRate,
          audioBitrate: transcodingAudioBitrate,
          audioChannels: transcodingAudioChannels,
          audioCodecProfile: transcodingAudioCodecProfile,
          advancedFeatures: transcodingAdvancedFeatures,
          advancedFeatureCount: transcodingAdvancedFeatureCount,
        );
        await rtcEngine.startRtmpStreamWithTranscoding(
          url: url,
          transcoding: transcoding,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startRtmpStreamWithTranscoding] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'updateRtmpTranscoding',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoCodecProfileType transcodingVideoCodecProfile =
            VideoCodecProfileType.videoCodecProfileBaseline;
        const VideoCodecTypeForStream transcodingVideoCodecType =
            VideoCodecTypeForStream.videoCodecH264ForStream;
        const AudioSampleRateType transcodingAudioSampleRate =
            AudioSampleRateType.audioSampleRate32000;
        const AudioCodecProfileType transcodingAudioCodecProfile =
            AudioCodecProfileType.audioCodecProfileLcAac;
        const int transcodingWidth = 10;
        const int transcodingHeight = 10;
        const int transcodingVideoBitrate = 10;
        const int transcodingVideoFramerate = 10;
        const bool transcodingLowLatency = true;
        const int transcodingVideoGop = 10;
        const int transcodingBackgroundColor = 10;
        const int transcodingUserCount = 10;
        const List<TranscodingUser> transcodingTranscodingUsers = [];
        const String transcodingTranscodingExtraInfo = "hello";
        const String transcodingMetadata = "hello";
        const List<RtcImage> transcodingWatermark = [];
        const int transcodingWatermarkCount = 10;
        const List<RtcImage> transcodingBackgroundImage = [];
        const int transcodingBackgroundImageCount = 10;
        const int transcodingAudioBitrate = 10;
        const int transcodingAudioChannels = 10;
        const List<LiveStreamAdvancedFeature> transcodingAdvancedFeatures = [];
        const int transcodingAdvancedFeatureCount = 10;
        const LiveTranscoding transcoding = LiveTranscoding(
          width: transcodingWidth,
          height: transcodingHeight,
          videoBitrate: transcodingVideoBitrate,
          videoFramerate: transcodingVideoFramerate,
          lowLatency: transcodingLowLatency,
          videoGop: transcodingVideoGop,
          videoCodecProfile: transcodingVideoCodecProfile,
          backgroundColor: transcodingBackgroundColor,
          videoCodecType: transcodingVideoCodecType,
          userCount: transcodingUserCount,
          transcodingUsers: transcodingTranscodingUsers,
          transcodingExtraInfo: transcodingTranscodingExtraInfo,
          metadata: transcodingMetadata,
          watermark: transcodingWatermark,
          watermarkCount: transcodingWatermarkCount,
          backgroundImage: transcodingBackgroundImage,
          backgroundImageCount: transcodingBackgroundImageCount,
          audioSampleRate: transcodingAudioSampleRate,
          audioBitrate: transcodingAudioBitrate,
          audioChannels: transcodingAudioChannels,
          audioCodecProfile: transcodingAudioCodecProfile,
          advancedFeatures: transcodingAdvancedFeatures,
          advancedFeatureCount: transcodingAdvancedFeatureCount,
        );
        await rtcEngine.updateRtmpTranscoding(
          transcoding,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[updateRtmpTranscoding] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopRtmpStream',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String url = "hello";
        await rtcEngine.stopRtmpStream(
          url,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopRtmpStream] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startLocalVideoTranscoder',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoCodecType videoOutputConfigurationCodecType =
            VideoCodecType.videoCodecNone;
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions videoOutputConfigurationDimensions =
            VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const OrientationMode videoOutputConfigurationOrientationMode =
            OrientationMode.orientationModeAdaptive;
        const DegradationPreference
            videoOutputConfigurationDegradationPreference =
            DegradationPreference.maintainQuality;
        const VideoMirrorModeType videoOutputConfigurationMirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const EncodingPreference advanceOptionsEncodingPreference =
            EncodingPreference.preferAuto;
        const CompressionPreference advanceOptionsCompressionPreference =
            CompressionPreference.preferLowLatency;
        const AdvanceOptions videoOutputConfigurationAdvanceOptions =
            AdvanceOptions(
          encodingPreference: advanceOptionsEncodingPreference,
          compressionPreference: advanceOptionsCompressionPreference,
        );
        const int videoOutputConfigurationFrameRate = 10;
        const int videoOutputConfigurationBitrate = 10;
        const int videoOutputConfigurationMinBitrate = 10;
        const VideoEncoderConfiguration configVideoOutputConfiguration =
            VideoEncoderConfiguration(
          codecType: videoOutputConfigurationCodecType,
          dimensions: videoOutputConfigurationDimensions,
          frameRate: videoOutputConfigurationFrameRate,
          bitrate: videoOutputConfigurationBitrate,
          minBitrate: videoOutputConfigurationMinBitrate,
          orientationMode: videoOutputConfigurationOrientationMode,
          degradationPreference: videoOutputConfigurationDegradationPreference,
          mirrorMode: videoOutputConfigurationMirrorMode,
          advanceOptions: videoOutputConfigurationAdvanceOptions,
        );
        const int configStreamCount = 10;
        const List<TranscodingVideoStream> configVideoInputStreams = [];
        const bool configSyncWithPrimaryCamera = true;
        const LocalTranscoderConfiguration config =
            LocalTranscoderConfiguration(
          streamCount: configStreamCount,
          videoInputStreams: configVideoInputStreams,
          videoOutputConfiguration: configVideoOutputConfiguration,
          syncWithPrimaryCamera: configSyncWithPrimaryCamera,
        );
        await rtcEngine.startLocalVideoTranscoder(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startLocalVideoTranscoder] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'updateLocalTranscoderConfiguration',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoCodecType videoOutputConfigurationCodecType =
            VideoCodecType.videoCodecNone;
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions videoOutputConfigurationDimensions =
            VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const OrientationMode videoOutputConfigurationOrientationMode =
            OrientationMode.orientationModeAdaptive;
        const DegradationPreference
            videoOutputConfigurationDegradationPreference =
            DegradationPreference.maintainQuality;
        const VideoMirrorModeType videoOutputConfigurationMirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const EncodingPreference advanceOptionsEncodingPreference =
            EncodingPreference.preferAuto;
        const CompressionPreference advanceOptionsCompressionPreference =
            CompressionPreference.preferLowLatency;
        const AdvanceOptions videoOutputConfigurationAdvanceOptions =
            AdvanceOptions(
          encodingPreference: advanceOptionsEncodingPreference,
          compressionPreference: advanceOptionsCompressionPreference,
        );
        const int videoOutputConfigurationFrameRate = 10;
        const int videoOutputConfigurationBitrate = 10;
        const int videoOutputConfigurationMinBitrate = 10;
        const VideoEncoderConfiguration configVideoOutputConfiguration =
            VideoEncoderConfiguration(
          codecType: videoOutputConfigurationCodecType,
          dimensions: videoOutputConfigurationDimensions,
          frameRate: videoOutputConfigurationFrameRate,
          bitrate: videoOutputConfigurationBitrate,
          minBitrate: videoOutputConfigurationMinBitrate,
          orientationMode: videoOutputConfigurationOrientationMode,
          degradationPreference: videoOutputConfigurationDegradationPreference,
          mirrorMode: videoOutputConfigurationMirrorMode,
          advanceOptions: videoOutputConfigurationAdvanceOptions,
        );
        const int configStreamCount = 10;
        const List<TranscodingVideoStream> configVideoInputStreams = [];
        const bool configSyncWithPrimaryCamera = true;
        const LocalTranscoderConfiguration config =
            LocalTranscoderConfiguration(
          streamCount: configStreamCount,
          videoInputStreams: configVideoInputStreams,
          videoOutputConfiguration: configVideoOutputConfiguration,
          syncWithPrimaryCamera: configSyncWithPrimaryCamera,
        );
        await rtcEngine.updateLocalTranscoderConfiguration(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[updateLocalTranscoderConfiguration] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopLocalVideoTranscoder',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopLocalVideoTranscoder();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopLocalVideoTranscoder] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startPrimaryCameraCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const CameraDirection configCameraDirection =
            CameraDirection.cameraRear;
        const int formatWidth = 10;
        const int formatHeight = 10;
        const int formatFps = 10;
        const VideoFormat configFormat = VideoFormat(
          width: formatWidth,
          height: formatHeight,
          fps: formatFps,
        );
        const String configDeviceId = "hello";
        const bool configFollowEncodeDimensionRatio = true;
        const CameraCapturerConfiguration config = CameraCapturerConfiguration(
          cameraDirection: configCameraDirection,
          deviceId: configDeviceId,
          format: configFormat,
          followEncodeDimensionRatio: configFollowEncodeDimensionRatio,
        );
        await rtcEngine.startPrimaryCameraCapture(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startPrimaryCameraCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startSecondaryCameraCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const CameraDirection configCameraDirection =
            CameraDirection.cameraRear;
        const int formatWidth = 10;
        const int formatHeight = 10;
        const int formatFps = 10;
        const VideoFormat configFormat = VideoFormat(
          width: formatWidth,
          height: formatHeight,
          fps: formatFps,
        );
        const String configDeviceId = "hello";
        const bool configFollowEncodeDimensionRatio = true;
        const CameraCapturerConfiguration config = CameraCapturerConfiguration(
          cameraDirection: configCameraDirection,
          deviceId: configDeviceId,
          format: configFormat,
          followEncodeDimensionRatio: configFollowEncodeDimensionRatio,
        );
        await rtcEngine.startSecondaryCameraCapture(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startSecondaryCameraCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopPrimaryCameraCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopPrimaryCameraCapture();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopPrimaryCameraCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopSecondaryCameraCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopSecondaryCameraCapture();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopSecondaryCameraCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setCameraDeviceOrientation',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoSourceType type = VideoSourceType.videoSourceCameraPrimary;
        const VideoOrientation orientation = VideoOrientation.videoOrientation0;
        await rtcEngine.setCameraDeviceOrientation(
          type: type,
          orientation: orientation,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setCameraDeviceOrientation] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setScreenCaptureOrientation',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoSourceType type = VideoSourceType.videoSourceCameraPrimary;
        const VideoOrientation orientation = VideoOrientation.videoOrientation0;
        await rtcEngine.setScreenCaptureOrientation(
          type: type,
          orientation: orientation,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setScreenCaptureOrientation] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startPrimaryScreenCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int screenRectX = 10;
        const int screenRectY = 10;
        const int screenRectWidth = 10;
        const int screenRectHeight = 10;
        const Rectangle configScreenRect = Rectangle(
          x: screenRectX,
          y: screenRectY,
          width: screenRectWidth,
          height: screenRectHeight,
        );
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions paramsDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int paramsFrameRate = 10;
        const int paramsBitrate = 10;
        const bool paramsCaptureMouseCursor = true;
        const bool paramsWindowFocus = true;
        const List<int> paramsExcludeWindowList = [];
        const int paramsExcludeWindowCount = 10;
        const int paramsHighLightWidth = 10;
        const int paramsHighLightColor = 10;
        const bool paramsEnableHighLight = true;
        const ScreenCaptureParameters configParams = ScreenCaptureParameters(
          dimensions: paramsDimensions,
          frameRate: paramsFrameRate,
          bitrate: paramsBitrate,
          captureMouseCursor: paramsCaptureMouseCursor,
          windowFocus: paramsWindowFocus,
          excludeWindowList: paramsExcludeWindowList,
          excludeWindowCount: paramsExcludeWindowCount,
          highLightWidth: paramsHighLightWidth,
          highLightColor: paramsHighLightColor,
          enableHighLight: paramsEnableHighLight,
        );
        const int regionRectX = 10;
        const int regionRectY = 10;
        const int regionRectWidth = 10;
        const int regionRectHeight = 10;
        const Rectangle configRegionRect = Rectangle(
          x: regionRectX,
          y: regionRectY,
          width: regionRectWidth,
          height: regionRectHeight,
        );
        const bool configIsCaptureWindow = true;
        const int configDisplayId = 10;
        const int configWindowId = 10;
        const ScreenCaptureConfiguration config = ScreenCaptureConfiguration(
          isCaptureWindow: configIsCaptureWindow,
          displayId: configDisplayId,
          screenRect: configScreenRect,
          windowId: configWindowId,
          params: configParams,
          regionRect: configRegionRect,
        );
        await rtcEngine.startPrimaryScreenCapture(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startPrimaryScreenCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startSecondaryScreenCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int screenRectX = 10;
        const int screenRectY = 10;
        const int screenRectWidth = 10;
        const int screenRectHeight = 10;
        const Rectangle configScreenRect = Rectangle(
          x: screenRectX,
          y: screenRectY,
          width: screenRectWidth,
          height: screenRectHeight,
        );
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions paramsDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const int paramsFrameRate = 10;
        const int paramsBitrate = 10;
        const bool paramsCaptureMouseCursor = true;
        const bool paramsWindowFocus = true;
        const List<int> paramsExcludeWindowList = [];
        const int paramsExcludeWindowCount = 10;
        const int paramsHighLightWidth = 10;
        const int paramsHighLightColor = 10;
        const bool paramsEnableHighLight = true;
        const ScreenCaptureParameters configParams = ScreenCaptureParameters(
          dimensions: paramsDimensions,
          frameRate: paramsFrameRate,
          bitrate: paramsBitrate,
          captureMouseCursor: paramsCaptureMouseCursor,
          windowFocus: paramsWindowFocus,
          excludeWindowList: paramsExcludeWindowList,
          excludeWindowCount: paramsExcludeWindowCount,
          highLightWidth: paramsHighLightWidth,
          highLightColor: paramsHighLightColor,
          enableHighLight: paramsEnableHighLight,
        );
        const int regionRectX = 10;
        const int regionRectY = 10;
        const int regionRectWidth = 10;
        const int regionRectHeight = 10;
        const Rectangle configRegionRect = Rectangle(
          x: regionRectX,
          y: regionRectY,
          width: regionRectWidth,
          height: regionRectHeight,
        );
        const bool configIsCaptureWindow = true;
        const int configDisplayId = 10;
        const int configWindowId = 10;
        const ScreenCaptureConfiguration config = ScreenCaptureConfiguration(
          isCaptureWindow: configIsCaptureWindow,
          displayId: configDisplayId,
          screenRect: configScreenRect,
          windowId: configWindowId,
          params: configParams,
          regionRect: configRegionRect,
        );
        await rtcEngine.startSecondaryScreenCapture(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startSecondaryScreenCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopPrimaryScreenCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopPrimaryScreenCapture();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopPrimaryScreenCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopSecondaryScreenCapture',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopSecondaryScreenCapture();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopSecondaryScreenCapture] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getConnectionState',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getConnectionState();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getConnectionState] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'registerEventHandler',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        final RtcEngineEventHandler eventHandler = RtcEngineEventHandler(
          onJoinChannelSuccess: (RtcConnection connection, int elapsed) {},
          onRejoinChannelSuccess: (RtcConnection connection, int elapsed) {},
          onProxyConnected: (String channel, int uid, ProxyType proxyType,
              String localProxyIp, int elapsed) {},
          onError: (ErrorCodeType err, String msg) {},
          onAudioQuality: (RtcConnection connection, int remoteUid,
              QualityType quality, int delay, int lost) {},
          onLastmileProbeResult: (LastmileProbeResult result) {},
          onAudioVolumeIndication: (RtcConnection connection, List speakers,
              int speakerNumber, int totalVolume) {},
          onLeaveChannel: (RtcConnection connection, RtcStats stats) {},
          onRtcStats: (RtcConnection connection, RtcStats stats) {},
          onAudioDeviceStateChanged: (String deviceId,
              MediaDeviceType deviceType, MediaDeviceStateType deviceState) {},
          onAudioMixingPositionChanged: (int position) {},
          onAudioMixingFinished: () {},
          onAudioEffectFinished: (int soundId) {},
          onVideoDeviceStateChanged: (String deviceId,
              MediaDeviceType deviceType, MediaDeviceStateType deviceState) {},
          onNetworkQuality: (RtcConnection connection, int remoteUid,
              QualityType txQuality, QualityType rxQuality) {},
          onIntraRequestReceived: (RtcConnection connection) {},
          onUplinkNetworkInfoUpdated: (UplinkNetworkInfo info) {},
          onDownlinkNetworkInfoUpdated: (DownlinkNetworkInfo info) {},
          onLastmileQuality: (QualityType quality) {},
          onFirstLocalVideoFrame:
              (VideoSourceType source, int width, int height, int elapsed) {},
          onFirstLocalVideoFramePublished:
              (RtcConnection connection, int elapsed) {},
          onFirstRemoteVideoDecoded: (RtcConnection connection, int remoteUid,
              int width, int height, int elapsed) {},
          onVideoSizeChanged: (RtcConnection connection,
              VideoSourceType sourceType,
              int uid,
              int width,
              int height,
              int rotation) {},
          onLocalVideoStateChanged: (VideoSourceType source,
              LocalVideoStreamState state, LocalVideoStreamError error) {},
          onRemoteVideoStateChanged: (RtcConnection connection,
              int remoteUid,
              RemoteVideoState state,
              RemoteVideoStateReason reason,
              int elapsed) {},
          onFirstRemoteVideoFrame: (RtcConnection connection, int remoteUid,
              int width, int height, int elapsed) {},
          onUserJoined:
              (RtcConnection connection, int remoteUid, int elapsed) {},
          onUserOffline: (RtcConnection connection, int remoteUid,
              UserOfflineReasonType reason) {},
          onUserMuteAudio:
              (RtcConnection connection, int remoteUid, bool muted) {},
          onUserMuteVideo:
              (RtcConnection connection, int remoteUid, bool muted) {},
          onUserEnableVideo:
              (RtcConnection connection, int remoteUid, bool enabled) {},
          onUserStateChanged:
              (RtcConnection connection, int remoteUid, int state) {},
          onUserEnableLocalVideo:
              (RtcConnection connection, int remoteUid, bool enabled) {},
          onApiCallExecuted: (ErrorCodeType err, String api, String result) {},
          onLocalAudioStats:
              (RtcConnection connection, LocalAudioStats stats) {},
          onRemoteAudioStats:
              (RtcConnection connection, RemoteAudioStats stats) {},
          onLocalVideoStats:
              (RtcConnection connection, LocalVideoStats stats) {},
          onRemoteVideoStats:
              (RtcConnection connection, RemoteVideoStats stats) {},
          onCameraReady: () {},
          onCameraFocusAreaChanged: (int x, int y, int width, int height) {},
          onCameraExposureAreaChanged: (int x, int y, int width, int height) {},
          onFacePositionChanged: (int imageWidth, int imageHeight,
              Rectangle vecRectangle, int vecDistance, int numFaces) {},
          onVideoStopped: () {},
          onAudioMixingStateChanged:
              (AudioMixingStateType state, AudioMixingReasonType reason) {},
          onRhythmPlayerStateChanged:
              (RhythmPlayerStateType state, RhythmPlayerErrorType errorCode) {},
          onConnectionLost: (RtcConnection connection) {},
          onConnectionInterrupted: (RtcConnection connection) {},
          onConnectionBanned: (RtcConnection connection) {},
          onStreamMessage: (RtcConnection connection, int remoteUid,
              int streamId, Uint8List data, int length, int sentTs) {},
          onStreamMessageError: (RtcConnection connection, int remoteUid,
              int streamId, ErrorCodeType code, int missed, int cached) {},
          onRequestToken: (RtcConnection connection) {},
          onTokenPrivilegeWillExpire:
              (RtcConnection connection, String token) {},
          onLicenseValidationFailure:
              (RtcConnection connection, LicenseErrorType reason) {},
          onFirstLocalAudioFramePublished:
              (RtcConnection connection, int elapsed) {},
          onFirstRemoteAudioFrame:
              (RtcConnection connection, int userId, int elapsed) {},
          onFirstRemoteAudioDecoded:
              (RtcConnection connection, int uid, int elapsed) {},
          onLocalAudioStateChanged: (RtcConnection connection,
              LocalAudioStreamState state, LocalAudioStreamError error) {},
          onRemoteAudioStateChanged: (RtcConnection connection,
              int remoteUid,
              RemoteAudioState state,
              RemoteAudioStateReason reason,
              int elapsed) {},
          onActiveSpeaker: (RtcConnection connection, int uid) {},
          onContentInspectResult: (ContentInspectResult result) {},
          onSnapshotTaken: (RtcConnection connection, int uid, String filePath,
              int width, int height, int errCode) {},
          onClientRoleChanged: (RtcConnection connection,
              ClientRoleType oldRole,
              ClientRoleType newRole,
              ClientRoleOptions newRoleOptions) {},
          onClientRoleChangeFailed: (RtcConnection connection,
              ClientRoleChangeFailedReason reason,
              ClientRoleType currentRole) {},
          onAudioDeviceVolumeChanged:
              (MediaDeviceType deviceType, int volume, bool muted) {},
          onRtmpStreamingStateChanged: (String url,
              RtmpStreamPublishState state,
              RtmpStreamPublishErrorType errCode) {},
          onRtmpStreamingEvent: (String url, RtmpStreamingEvent eventCode) {},
          onTranscodingUpdated: () {},
          onAudioRoutingChanged: (int routing) {},
          onChannelMediaRelayStateChanged:
              (ChannelMediaRelayState state, ChannelMediaRelayError code) {},
          onChannelMediaRelayEvent: (ChannelMediaRelayEvent code) {},
          onLocalPublishFallbackToAudioOnly: (bool isFallbackOrRecover) {},
          onRemoteSubscribeFallbackToAudioOnly:
              (int uid, bool isFallbackOrRecover) {},
          onRemoteAudioTransportStats: (RtcConnection connection, int remoteUid,
              int delay, int lost, int rxKBitRate) {},
          onRemoteVideoTransportStats: (RtcConnection connection, int remoteUid,
              int delay, int lost, int rxKBitRate) {},
          onConnectionStateChanged: (RtcConnection connection,
              ConnectionStateType state, ConnectionChangedReasonType reason) {},
          onWlAccMessage: (RtcConnection connection, WlaccMessageReason reason,
              WlaccSuggestAction action, String wlAccMsg) {},
          onWlAccStats: (RtcConnection connection, WlAccStats currentStats,
              WlAccStats averageStats) {},
          onNetworkTypeChanged: (RtcConnection connection, NetworkType type) {},
          onEncryptionError:
              (RtcConnection connection, EncryptionErrorType errorType) {},
          onPermissionError: (PermissionType permissionType) {},
          onLocalUserRegistered: (int uid, String userAccount) {},
          onUserInfoUpdated: (int uid, UserInfo info) {},
          onUploadLogResult: (RtcConnection connection, String requestId,
              bool success, UploadErrorReason reason) {},
          onAudioSubscribeStateChanged: (String channel,
              int uid,
              StreamSubscribeState oldState,
              StreamSubscribeState newState,
              int elapseSinceLastState) {},
          onVideoSubscribeStateChanged: (String channel,
              int uid,
              StreamSubscribeState oldState,
              StreamSubscribeState newState,
              int elapseSinceLastState) {},
          onAudioPublishStateChanged: (String channel,
              StreamPublishState oldState,
              StreamPublishState newState,
              int elapseSinceLastState) {},
          onVideoPublishStateChanged: (VideoSourceType source,
              String channel,
              StreamPublishState oldState,
              StreamPublishState newState,
              int elapseSinceLastState) {},
          onExtensionEvent:
              (String provider, String extension, String key, String value) {},
          onExtensionStarted: (String provider, String extension) {},
          onExtensionStopped: (String provider, String extension) {},
          onExtensionError:
              (String provider, String extension, int error, String message) {},
          onUserAccountUpdated:
              (RtcConnection connection, int remoteUid, String userAccount) {},
        );
        rtcEngine.registerEventHandler(
          eventHandler,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[registerEventHandler] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'unregisterEventHandler',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        final RtcEngineEventHandler eventHandler = RtcEngineEventHandler(
          onJoinChannelSuccess: (RtcConnection connection, int elapsed) {},
          onRejoinChannelSuccess: (RtcConnection connection, int elapsed) {},
          onProxyConnected: (String channel, int uid, ProxyType proxyType,
              String localProxyIp, int elapsed) {},
          onError: (ErrorCodeType err, String msg) {},
          onAudioQuality: (RtcConnection connection, int remoteUid,
              QualityType quality, int delay, int lost) {},
          onLastmileProbeResult: (LastmileProbeResult result) {},
          onAudioVolumeIndication: (RtcConnection connection, List speakers,
              int speakerNumber, int totalVolume) {},
          onLeaveChannel: (RtcConnection connection, RtcStats stats) {},
          onRtcStats: (RtcConnection connection, RtcStats stats) {},
          onAudioDeviceStateChanged: (String deviceId,
              MediaDeviceType deviceType, MediaDeviceStateType deviceState) {},
          onAudioMixingPositionChanged: (int position) {},
          onAudioMixingFinished: () {},
          onAudioEffectFinished: (int soundId) {},
          onVideoDeviceStateChanged: (String deviceId,
              MediaDeviceType deviceType, MediaDeviceStateType deviceState) {},
          onNetworkQuality: (RtcConnection connection, int remoteUid,
              QualityType txQuality, QualityType rxQuality) {},
          onIntraRequestReceived: (RtcConnection connection) {},
          onUplinkNetworkInfoUpdated: (UplinkNetworkInfo info) {},
          onDownlinkNetworkInfoUpdated: (DownlinkNetworkInfo info) {},
          onLastmileQuality: (QualityType quality) {},
          onFirstLocalVideoFrame:
              (VideoSourceType source, int width, int height, int elapsed) {},
          onFirstLocalVideoFramePublished:
              (RtcConnection connection, int elapsed) {},
          onFirstRemoteVideoDecoded: (RtcConnection connection, int remoteUid,
              int width, int height, int elapsed) {},
          onVideoSizeChanged: (RtcConnection connection,
              VideoSourceType sourceType,
              int uid,
              int width,
              int height,
              int rotation) {},
          onLocalVideoStateChanged: (VideoSourceType source,
              LocalVideoStreamState state, LocalVideoStreamError error) {},
          onRemoteVideoStateChanged: (RtcConnection connection,
              int remoteUid,
              RemoteVideoState state,
              RemoteVideoStateReason reason,
              int elapsed) {},
          onFirstRemoteVideoFrame: (RtcConnection connection, int remoteUid,
              int width, int height, int elapsed) {},
          onUserJoined:
              (RtcConnection connection, int remoteUid, int elapsed) {},
          onUserOffline: (RtcConnection connection, int remoteUid,
              UserOfflineReasonType reason) {},
          onUserMuteAudio:
              (RtcConnection connection, int remoteUid, bool muted) {},
          onUserMuteVideo:
              (RtcConnection connection, int remoteUid, bool muted) {},
          onUserEnableVideo:
              (RtcConnection connection, int remoteUid, bool enabled) {},
          onUserStateChanged:
              (RtcConnection connection, int remoteUid, int state) {},
          onUserEnableLocalVideo:
              (RtcConnection connection, int remoteUid, bool enabled) {},
          onApiCallExecuted: (ErrorCodeType err, String api, String result) {},
          onLocalAudioStats:
              (RtcConnection connection, LocalAudioStats stats) {},
          onRemoteAudioStats:
              (RtcConnection connection, RemoteAudioStats stats) {},
          onLocalVideoStats:
              (RtcConnection connection, LocalVideoStats stats) {},
          onRemoteVideoStats:
              (RtcConnection connection, RemoteVideoStats stats) {},
          onCameraReady: () {},
          onCameraFocusAreaChanged: (int x, int y, int width, int height) {},
          onCameraExposureAreaChanged: (int x, int y, int width, int height) {},
          onFacePositionChanged: (int imageWidth, int imageHeight,
              Rectangle vecRectangle, int vecDistance, int numFaces) {},
          onVideoStopped: () {},
          onAudioMixingStateChanged:
              (AudioMixingStateType state, AudioMixingReasonType reason) {},
          onRhythmPlayerStateChanged:
              (RhythmPlayerStateType state, RhythmPlayerErrorType errorCode) {},
          onConnectionLost: (RtcConnection connection) {},
          onConnectionInterrupted: (RtcConnection connection) {},
          onConnectionBanned: (RtcConnection connection) {},
          onStreamMessage: (RtcConnection connection, int remoteUid,
              int streamId, Uint8List data, int length, int sentTs) {},
          onStreamMessageError: (RtcConnection connection, int remoteUid,
              int streamId, ErrorCodeType code, int missed, int cached) {},
          onRequestToken: (RtcConnection connection) {},
          onTokenPrivilegeWillExpire:
              (RtcConnection connection, String token) {},
          onLicenseValidationFailure:
              (RtcConnection connection, LicenseErrorType reason) {},
          onFirstLocalAudioFramePublished:
              (RtcConnection connection, int elapsed) {},
          onFirstRemoteAudioFrame:
              (RtcConnection connection, int userId, int elapsed) {},
          onFirstRemoteAudioDecoded:
              (RtcConnection connection, int uid, int elapsed) {},
          onLocalAudioStateChanged: (RtcConnection connection,
              LocalAudioStreamState state, LocalAudioStreamError error) {},
          onRemoteAudioStateChanged: (RtcConnection connection,
              int remoteUid,
              RemoteAudioState state,
              RemoteAudioStateReason reason,
              int elapsed) {},
          onActiveSpeaker: (RtcConnection connection, int uid) {},
          onContentInspectResult: (ContentInspectResult result) {},
          onSnapshotTaken: (RtcConnection connection, int uid, String filePath,
              int width, int height, int errCode) {},
          onClientRoleChanged: (RtcConnection connection,
              ClientRoleType oldRole,
              ClientRoleType newRole,
              ClientRoleOptions newRoleOptions) {},
          onClientRoleChangeFailed: (RtcConnection connection,
              ClientRoleChangeFailedReason reason,
              ClientRoleType currentRole) {},
          onAudioDeviceVolumeChanged:
              (MediaDeviceType deviceType, int volume, bool muted) {},
          onRtmpStreamingStateChanged: (String url,
              RtmpStreamPublishState state,
              RtmpStreamPublishErrorType errCode) {},
          onRtmpStreamingEvent: (String url, RtmpStreamingEvent eventCode) {},
          onTranscodingUpdated: () {},
          onAudioRoutingChanged: (int routing) {},
          onChannelMediaRelayStateChanged:
              (ChannelMediaRelayState state, ChannelMediaRelayError code) {},
          onChannelMediaRelayEvent: (ChannelMediaRelayEvent code) {},
          onLocalPublishFallbackToAudioOnly: (bool isFallbackOrRecover) {},
          onRemoteSubscribeFallbackToAudioOnly:
              (int uid, bool isFallbackOrRecover) {},
          onRemoteAudioTransportStats: (RtcConnection connection, int remoteUid,
              int delay, int lost, int rxKBitRate) {},
          onRemoteVideoTransportStats: (RtcConnection connection, int remoteUid,
              int delay, int lost, int rxKBitRate) {},
          onConnectionStateChanged: (RtcConnection connection,
              ConnectionStateType state, ConnectionChangedReasonType reason) {},
          onWlAccMessage: (RtcConnection connection, WlaccMessageReason reason,
              WlaccSuggestAction action, String wlAccMsg) {},
          onWlAccStats: (RtcConnection connection, WlAccStats currentStats,
              WlAccStats averageStats) {},
          onNetworkTypeChanged: (RtcConnection connection, NetworkType type) {},
          onEncryptionError:
              (RtcConnection connection, EncryptionErrorType errorType) {},
          onPermissionError: (PermissionType permissionType) {},
          onLocalUserRegistered: (int uid, String userAccount) {},
          onUserInfoUpdated: (int uid, UserInfo info) {},
          onUploadLogResult: (RtcConnection connection, String requestId,
              bool success, UploadErrorReason reason) {},
          onAudioSubscribeStateChanged: (String channel,
              int uid,
              StreamSubscribeState oldState,
              StreamSubscribeState newState,
              int elapseSinceLastState) {},
          onVideoSubscribeStateChanged: (String channel,
              int uid,
              StreamSubscribeState oldState,
              StreamSubscribeState newState,
              int elapseSinceLastState) {},
          onAudioPublishStateChanged: (String channel,
              StreamPublishState oldState,
              StreamPublishState newState,
              int elapseSinceLastState) {},
          onVideoPublishStateChanged: (VideoSourceType source,
              String channel,
              StreamPublishState oldState,
              StreamPublishState newState,
              int elapseSinceLastState) {},
          onExtensionEvent:
              (String provider, String extension, String key, String value) {},
          onExtensionStarted: (String provider, String extension) {},
          onExtensionStopped: (String provider, String extension) {},
          onExtensionError:
              (String provider, String extension, int error, String message) {},
          onUserAccountUpdated:
              (RtcConnection connection, int remoteUid, String userAccount) {},
        );
        rtcEngine.unregisterEventHandler(
          eventHandler,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[unregisterEventHandler] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setRemoteUserPriority',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const PriorityType userPriority = PriorityType.priorityHigh;
        await rtcEngine.setRemoteUserPriority(
          uid: uid,
          userPriority: userPriority,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setRemoteUserPriority] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setEncryptionMode',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String encryptionMode = "hello";
        await rtcEngine.setEncryptionMode(
          encryptionMode,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setEncryptionMode] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setEncryptionSecret',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String secret = "hello";
        await rtcEngine.setEncryptionSecret(
          secret,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setEncryptionSecret] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableEncryption',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const EncryptionMode configEncryptionMode = EncryptionMode.aes128Xts;
        const String configEncryptionKey = "hello";
        Uint8List configEncryptionKdfSalt = Uint8List.fromList([1, 2, 3, 4, 5]);
        final EncryptionConfig config = EncryptionConfig(
          encryptionMode: configEncryptionMode,
          encryptionKey: configEncryptionKey,
          encryptionKdfSalt: configEncryptionKdfSalt,
        );
        await rtcEngine.enableEncryption(
          enabled: enabled,
          config: config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableEncryption] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'sendStreamMessage',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int streamId = 10;
        Uint8List data = Uint8List.fromList([1, 2, 3, 4, 5]);
        const int length = 10;
        await rtcEngine.sendStreamMessage(
          streamId: streamId,
          data: data,
          length: length,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[sendStreamMessage] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'addVideoWatermark',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String watermarkUrl = "hello";
        const int positionInLandscapeModeX = 10;
        const int positionInLandscapeModeY = 10;
        const int positionInLandscapeModeWidth = 10;
        const int positionInLandscapeModeHeight = 10;
        const Rectangle optionsPositionInLandscapeMode = Rectangle(
          x: positionInLandscapeModeX,
          y: positionInLandscapeModeY,
          width: positionInLandscapeModeWidth,
          height: positionInLandscapeModeHeight,
        );
        const int positionInPortraitModeX = 10;
        const int positionInPortraitModeY = 10;
        const int positionInPortraitModeWidth = 10;
        const int positionInPortraitModeHeight = 10;
        const Rectangle optionsPositionInPortraitMode = Rectangle(
          x: positionInPortraitModeX,
          y: positionInPortraitModeY,
          width: positionInPortraitModeWidth,
          height: positionInPortraitModeHeight,
        );
        const double watermarkRatioXRatio = 10.0;
        const double watermarkRatioYRatio = 10.0;
        const double watermarkRatioWidthRatio = 10.0;
        const WatermarkRatio optionsWatermarkRatio = WatermarkRatio(
          xRatio: watermarkRatioXRatio,
          yRatio: watermarkRatioYRatio,
          widthRatio: watermarkRatioWidthRatio,
        );
        const WatermarkFitMode optionsMode =
            WatermarkFitMode.fitModeCoverPosition;
        const bool optionsVisibleInPreview = true;
        const WatermarkOptions options = WatermarkOptions(
          visibleInPreview: optionsVisibleInPreview,
          positionInLandscapeMode: optionsPositionInLandscapeMode,
          positionInPortraitMode: optionsPositionInPortraitMode,
          watermarkRatio: optionsWatermarkRatio,
          mode: optionsMode,
        );
        await rtcEngine.addVideoWatermark(
          watermarkUrl: watermarkUrl,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[addVideoWatermark] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'clearVideoWatermarks',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.clearVideoWatermarks();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[clearVideoWatermarks] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'pauseAudio',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.pauseAudio();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[pauseAudio] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'resumeAudio',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.resumeAudio();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[resumeAudio] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableWebSdkInteroperability',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngine.enableWebSdkInteroperability(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableWebSdkInteroperability] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'sendCustomReportMessage',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String id = "hello";
        const String category = "hello";
        const String event = "hello";
        const String label = "hello";
        const int value = 10;
        await rtcEngine.sendCustomReportMessage(
          id: id,
          category: category,
          event: event,
          label: label,
          value: value,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[sendCustomReportMessage] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'registerMediaMetadataObserver',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        final MetadataObserver observer = MetadataObserver(
          onMetadataReceived: (Metadata metadata) {},
        );
        const MetadataType type = MetadataType.unknownMetadata;
        rtcEngine.registerMediaMetadataObserver(
          observer: observer,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[registerMediaMetadataObserver] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'unregisterMediaMetadataObserver',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        final MetadataObserver observer = MetadataObserver(
          onMetadataReceived: (Metadata metadata) {},
        );
        const MetadataType type = MetadataType.unknownMetadata;
        rtcEngine.unregisterMediaMetadataObserver(
          observer: observer,
          type: type,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[unregisterMediaMetadataObserver] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startAudioFrameDump',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String channelId = "hello";
        const int userId = 10;
        const String location = "hello";
        const String uuid = "hello";
        const String passwd = "hello";
        const int durationMs = 10;
        const bool autoUpload = true;
        await rtcEngine.startAudioFrameDump(
          channelId: channelId,
          userId: userId,
          location: location,
          uuid: uuid,
          passwd: passwd,
          durationMs: durationMs,
          autoUpload: autoUpload,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startAudioFrameDump] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopAudioFrameDump',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String channelId = "hello";
        const int userId = 10;
        const String location = "hello";
        await rtcEngine.stopAudioFrameDump(
          channelId: channelId,
          userId: userId,
          location: location,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopAudioFrameDump] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'registerLocalUserAccount',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String appId = "hello";
        const String userAccount = "hello";
        await rtcEngine.registerLocalUserAccount(
          appId: appId,
          userAccount: userAccount,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[registerLocalUserAccount] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'joinChannelWithUserAccount',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String token = "hello";
        const String channelId = "hello";
        const String userAccount = "hello";
        const ClientRoleType optionsClientRoleType =
            ClientRoleType.clientRoleBroadcaster;
        const AudienceLatencyLevelType optionsAudienceLatencyLevel =
            AudienceLatencyLevelType.audienceLatencyLevelLowLatency;
        const VideoStreamType optionsDefaultVideoStreamType =
            VideoStreamType.videoStreamHigh;
        const ChannelProfileType optionsChannelProfile =
            ChannelProfileType.channelProfileCommunication;
        const bool optionsPublishCameraTrack = true;
        const bool optionsPublishSecondaryCameraTrack = true;
        const bool optionsPublishMicrophoneTrack = true;
        const bool optionsPublishScreenCaptureVideo = true;
        const bool optionsPublishScreenCaptureAudio = true;
        const bool optionsPublishScreenTrack = true;
        const bool optionsPublishSecondaryScreenTrack = true;
        const bool optionsPublishCustomAudioTrack = true;
        const int optionsPublishCustomAudioSourceId = 10;
        const bool optionsPublishCustomAudioTrackEnableAec = true;
        const bool optionsPublishDirectCustomAudioTrack = true;
        const bool optionsPublishCustomAudioTrackAec = true;
        const bool optionsPublishCustomVideoTrack = true;
        const bool optionsPublishEncodedVideoTrack = true;
        const bool optionsPublishMediaPlayerAudioTrack = true;
        const bool optionsPublishMediaPlayerVideoTrack = true;
        const bool optionsPublishTrancodedVideoTrack = true;
        const bool optionsAutoSubscribeAudio = true;
        const bool optionsAutoSubscribeVideo = true;
        const bool optionsEnableAudioRecordingOrPlayout = true;
        const int optionsPublishMediaPlayerId = 10;
        const int optionsAudioDelayMs = 10;
        const int optionsMediaPlayerAudioDelayMs = 10;
        const String optionsToken = "hello";
        const bool optionsEnableBuiltInMediaEncryption = true;
        const bool optionsPublishRhythmPlayerTrack = true;
        const bool optionsIsInteractiveAudience = true;
        const int optionsCustomVideoTrackId = 10;
        const bool optionsIsAudioFilterable = true;
        const ChannelMediaOptions options = ChannelMediaOptions(
          publishCameraTrack: optionsPublishCameraTrack,
          publishSecondaryCameraTrack: optionsPublishSecondaryCameraTrack,
          publishMicrophoneTrack: optionsPublishMicrophoneTrack,
          publishScreenCaptureVideo: optionsPublishScreenCaptureVideo,
          publishScreenCaptureAudio: optionsPublishScreenCaptureAudio,
          publishScreenTrack: optionsPublishScreenTrack,
          publishSecondaryScreenTrack: optionsPublishSecondaryScreenTrack,
          publishCustomAudioTrack: optionsPublishCustomAudioTrack,
          publishCustomAudioSourceId: optionsPublishCustomAudioSourceId,
          publishCustomAudioTrackEnableAec:
              optionsPublishCustomAudioTrackEnableAec,
          publishDirectCustomAudioTrack: optionsPublishDirectCustomAudioTrack,
          publishCustomAudioTrackAec: optionsPublishCustomAudioTrackAec,
          publishCustomVideoTrack: optionsPublishCustomVideoTrack,
          publishEncodedVideoTrack: optionsPublishEncodedVideoTrack,
          publishMediaPlayerAudioTrack: optionsPublishMediaPlayerAudioTrack,
          publishMediaPlayerVideoTrack: optionsPublishMediaPlayerVideoTrack,
          publishTrancodedVideoTrack: optionsPublishTrancodedVideoTrack,
          autoSubscribeAudio: optionsAutoSubscribeAudio,
          autoSubscribeVideo: optionsAutoSubscribeVideo,
          enableAudioRecordingOrPlayout: optionsEnableAudioRecordingOrPlayout,
          publishMediaPlayerId: optionsPublishMediaPlayerId,
          clientRoleType: optionsClientRoleType,
          audienceLatencyLevel: optionsAudienceLatencyLevel,
          defaultVideoStreamType: optionsDefaultVideoStreamType,
          channelProfile: optionsChannelProfile,
          audioDelayMs: optionsAudioDelayMs,
          mediaPlayerAudioDelayMs: optionsMediaPlayerAudioDelayMs,
          token: optionsToken,
          enableBuiltInMediaEncryption: optionsEnableBuiltInMediaEncryption,
          publishRhythmPlayerTrack: optionsPublishRhythmPlayerTrack,
          isInteractiveAudience: optionsIsInteractiveAudience,
          customVideoTrackId: optionsCustomVideoTrackId,
          isAudioFilterable: optionsIsAudioFilterable,
        );
        await rtcEngine.joinChannelWithUserAccount(
          token: token,
          channelId: channelId,
          userAccount: userAccount,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[joinChannelWithUserAccount] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'joinChannelWithUserAccountEx',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String token = "hello";
        const String channelId = "hello";
        const String userAccount = "hello";
        const ClientRoleType optionsClientRoleType =
            ClientRoleType.clientRoleBroadcaster;
        const AudienceLatencyLevelType optionsAudienceLatencyLevel =
            AudienceLatencyLevelType.audienceLatencyLevelLowLatency;
        const VideoStreamType optionsDefaultVideoStreamType =
            VideoStreamType.videoStreamHigh;
        const ChannelProfileType optionsChannelProfile =
            ChannelProfileType.channelProfileCommunication;
        const bool optionsPublishCameraTrack = true;
        const bool optionsPublishSecondaryCameraTrack = true;
        const bool optionsPublishMicrophoneTrack = true;
        const bool optionsPublishScreenCaptureVideo = true;
        const bool optionsPublishScreenCaptureAudio = true;
        const bool optionsPublishScreenTrack = true;
        const bool optionsPublishSecondaryScreenTrack = true;
        const bool optionsPublishCustomAudioTrack = true;
        const int optionsPublishCustomAudioSourceId = 10;
        const bool optionsPublishCustomAudioTrackEnableAec = true;
        const bool optionsPublishDirectCustomAudioTrack = true;
        const bool optionsPublishCustomAudioTrackAec = true;
        const bool optionsPublishCustomVideoTrack = true;
        const bool optionsPublishEncodedVideoTrack = true;
        const bool optionsPublishMediaPlayerAudioTrack = true;
        const bool optionsPublishMediaPlayerVideoTrack = true;
        const bool optionsPublishTrancodedVideoTrack = true;
        const bool optionsAutoSubscribeAudio = true;
        const bool optionsAutoSubscribeVideo = true;
        const bool optionsEnableAudioRecordingOrPlayout = true;
        const int optionsPublishMediaPlayerId = 10;
        const int optionsAudioDelayMs = 10;
        const int optionsMediaPlayerAudioDelayMs = 10;
        const String optionsToken = "hello";
        const bool optionsEnableBuiltInMediaEncryption = true;
        const bool optionsPublishRhythmPlayerTrack = true;
        const bool optionsIsInteractiveAudience = true;
        const int optionsCustomVideoTrackId = 10;
        const bool optionsIsAudioFilterable = true;
        const ChannelMediaOptions options = ChannelMediaOptions(
          publishCameraTrack: optionsPublishCameraTrack,
          publishSecondaryCameraTrack: optionsPublishSecondaryCameraTrack,
          publishMicrophoneTrack: optionsPublishMicrophoneTrack,
          publishScreenCaptureVideo: optionsPublishScreenCaptureVideo,
          publishScreenCaptureAudio: optionsPublishScreenCaptureAudio,
          publishScreenTrack: optionsPublishScreenTrack,
          publishSecondaryScreenTrack: optionsPublishSecondaryScreenTrack,
          publishCustomAudioTrack: optionsPublishCustomAudioTrack,
          publishCustomAudioSourceId: optionsPublishCustomAudioSourceId,
          publishCustomAudioTrackEnableAec:
              optionsPublishCustomAudioTrackEnableAec,
          publishDirectCustomAudioTrack: optionsPublishDirectCustomAudioTrack,
          publishCustomAudioTrackAec: optionsPublishCustomAudioTrackAec,
          publishCustomVideoTrack: optionsPublishCustomVideoTrack,
          publishEncodedVideoTrack: optionsPublishEncodedVideoTrack,
          publishMediaPlayerAudioTrack: optionsPublishMediaPlayerAudioTrack,
          publishMediaPlayerVideoTrack: optionsPublishMediaPlayerVideoTrack,
          publishTrancodedVideoTrack: optionsPublishTrancodedVideoTrack,
          autoSubscribeAudio: optionsAutoSubscribeAudio,
          autoSubscribeVideo: optionsAutoSubscribeVideo,
          enableAudioRecordingOrPlayout: optionsEnableAudioRecordingOrPlayout,
          publishMediaPlayerId: optionsPublishMediaPlayerId,
          clientRoleType: optionsClientRoleType,
          audienceLatencyLevel: optionsAudienceLatencyLevel,
          defaultVideoStreamType: optionsDefaultVideoStreamType,
          channelProfile: optionsChannelProfile,
          audioDelayMs: optionsAudioDelayMs,
          mediaPlayerAudioDelayMs: optionsMediaPlayerAudioDelayMs,
          token: optionsToken,
          enableBuiltInMediaEncryption: optionsEnableBuiltInMediaEncryption,
          publishRhythmPlayerTrack: optionsPublishRhythmPlayerTrack,
          isInteractiveAudience: optionsIsInteractiveAudience,
          customVideoTrackId: optionsCustomVideoTrackId,
          isAudioFilterable: optionsIsAudioFilterable,
        );
        await rtcEngine.joinChannelWithUserAccountEx(
          token: token,
          channelId: channelId,
          userAccount: userAccount,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[joinChannelWithUserAccountEx] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getUserInfoByUserAccount',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String userAccount = "hello";
        await rtcEngine.getUserInfoByUserAccount(
          userAccount,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getUserInfoByUserAccount] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getUserInfoByUid',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        await rtcEngine.getUserInfoByUid(
          uid,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getUserInfoByUid] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopChannelMediaRelay',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopChannelMediaRelay();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopChannelMediaRelay] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'pauseAllChannelMediaRelay',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.pauseAllChannelMediaRelay();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[pauseAllChannelMediaRelay] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'resumeAllChannelMediaRelay',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.resumeAllChannelMediaRelay();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[resumeAllChannelMediaRelay] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setDirectCdnStreamingAudioConfiguration',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const AudioProfileType profile = AudioProfileType.audioProfileDefault;
        await rtcEngine.setDirectCdnStreamingAudioConfiguration(
          profile,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setDirectCdnStreamingAudioConfiguration] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setDirectCdnStreamingVideoConfiguration',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const VideoCodecType configCodecType = VideoCodecType.videoCodecNone;
        const int dimensionsWidth = 10;
        const int dimensionsHeight = 10;
        const VideoDimensions configDimensions = VideoDimensions(
          width: dimensionsWidth,
          height: dimensionsHeight,
        );
        const OrientationMode configOrientationMode =
            OrientationMode.orientationModeAdaptive;
        const DegradationPreference configDegradationPreference =
            DegradationPreference.maintainQuality;
        const VideoMirrorModeType configMirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const EncodingPreference advanceOptionsEncodingPreference =
            EncodingPreference.preferAuto;
        const CompressionPreference advanceOptionsCompressionPreference =
            CompressionPreference.preferLowLatency;
        const AdvanceOptions configAdvanceOptions = AdvanceOptions(
          encodingPreference: advanceOptionsEncodingPreference,
          compressionPreference: advanceOptionsCompressionPreference,
        );
        const int configFrameRate = 10;
        const int configBitrate = 10;
        const int configMinBitrate = 10;
        const VideoEncoderConfiguration config = VideoEncoderConfiguration(
          codecType: configCodecType,
          dimensions: configDimensions,
          frameRate: configFrameRate,
          bitrate: configBitrate,
          minBitrate: configMinBitrate,
          orientationMode: configOrientationMode,
          degradationPreference: configDegradationPreference,
          mirrorMode: configMirrorMode,
          advanceOptions: configAdvanceOptions,
        );
        await rtcEngine.setDirectCdnStreamingVideoConfiguration(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[setDirectCdnStreamingVideoConfiguration] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startDirectCdnStreaming',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        final DirectCdnStreamingEventHandler eventHandler =
            DirectCdnStreamingEventHandler(
          onDirectCdnStreamingStateChanged: (DirectCdnStreamingState state,
              DirectCdnStreamingError error, String message) {},
          onDirectCdnStreamingStats: (DirectCdnStreamingStats stats) {},
        );
        const String publishUrl = "hello";
        const bool optionsPublishCameraTrack = true;
        const bool optionsPublishMicrophoneTrack = true;
        const bool optionsPublishCustomAudioTrack = true;
        const bool optionsPublishCustomVideoTrack = true;
        const bool optionsPublishMediaPlayerAudioTrack = true;
        const int optionsPublishMediaPlayerId = 10;
        const int optionsCustomVideoTrackId = 10;
        const DirectCdnStreamingMediaOptions options =
            DirectCdnStreamingMediaOptions(
          publishCameraTrack: optionsPublishCameraTrack,
          publishMicrophoneTrack: optionsPublishMicrophoneTrack,
          publishCustomAudioTrack: optionsPublishCustomAudioTrack,
          publishCustomVideoTrack: optionsPublishCustomVideoTrack,
          publishMediaPlayerAudioTrack: optionsPublishMediaPlayerAudioTrack,
          publishMediaPlayerId: optionsPublishMediaPlayerId,
          customVideoTrackId: optionsCustomVideoTrackId,
        );
        await rtcEngine.startDirectCdnStreaming(
          eventHandler: eventHandler,
          publishUrl: publishUrl,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startDirectCdnStreaming] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopDirectCdnStreaming',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopDirectCdnStreaming();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopDirectCdnStreaming] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'updateDirectCdnStreamingMediaOptions',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool optionsPublishCameraTrack = true;
        const bool optionsPublishMicrophoneTrack = true;
        const bool optionsPublishCustomAudioTrack = true;
        const bool optionsPublishCustomVideoTrack = true;
        const bool optionsPublishMediaPlayerAudioTrack = true;
        const int optionsPublishMediaPlayerId = 10;
        const int optionsCustomVideoTrackId = 10;
        const DirectCdnStreamingMediaOptions options =
            DirectCdnStreamingMediaOptions(
          publishCameraTrack: optionsPublishCameraTrack,
          publishMicrophoneTrack: optionsPublishMicrophoneTrack,
          publishCustomAudioTrack: optionsPublishCustomAudioTrack,
          publishCustomVideoTrack: optionsPublishCustomVideoTrack,
          publishMediaPlayerAudioTrack: optionsPublishMediaPlayerAudioTrack,
          publishMediaPlayerId: optionsPublishMediaPlayerId,
          customVideoTrackId: optionsCustomVideoTrackId,
        );
        await rtcEngine.updateDirectCdnStreamingMediaOptions(
          options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[updateDirectCdnStreamingMediaOptions] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'startRhythmPlayer',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String sound1 = "hello";
        const String sound2 = "hello";
        const int configBeatsPerMeasure = 10;
        const int configBeatsPerMinute = 10;
        const AgoraRhythmPlayerConfig config = AgoraRhythmPlayerConfig(
          beatsPerMeasure: configBeatsPerMeasure,
          beatsPerMinute: configBeatsPerMinute,
        );
        await rtcEngine.startRhythmPlayer(
          sound1: sound1,
          sound2: sound2,
          config: config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[startRhythmPlayer] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'stopRhythmPlayer',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.stopRhythmPlayer();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[stopRhythmPlayer] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'configRhythmPlayer',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int configBeatsPerMeasure = 10;
        const int configBeatsPerMinute = 10;
        const AgoraRhythmPlayerConfig config = AgoraRhythmPlayerConfig(
          beatsPerMeasure: configBeatsPerMeasure,
          beatsPerMinute: configBeatsPerMinute,
        );
        await rtcEngine.configRhythmPlayer(
          config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[configRhythmPlayer] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'takeSnapshot',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int uid = 10;
        const String filePath = "hello";
        await rtcEngine.takeSnapshot(
          uid: uid,
          filePath: filePath,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[takeSnapshot] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableContentInspect',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        const String configExtraInfo = "hello";
        const List<ContentInspectModule> configModules = [];
        const int configModuleCount = 10;
        const ContentInspectConfig config = ContentInspectConfig(
          extraInfo: configExtraInfo,
          modules: configModules,
          moduleCount: configModuleCount,
        );
        await rtcEngine.enableContentInspect(
          enabled: enabled,
          config: config,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableContentInspect] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'adjustCustomAudioPublishVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int sourceId = 10;
        const int volume = 10;
        await rtcEngine.adjustCustomAudioPublishVolume(
          sourceId: sourceId,
          volume: volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustCustomAudioPublishVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'adjustCustomAudioPlayoutVolume',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int sourceId = 10;
        const int volume = 10;
        await rtcEngine.adjustCustomAudioPlayoutVolume(
          sourceId: sourceId,
          volume: volume,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[adjustCustomAudioPlayoutVolume] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setCloudProxy',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const CloudProxyType proxyType = CloudProxyType.noneProxy;
        await rtcEngine.setCloudProxy(
          proxyType,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setCloudProxy] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAdvancedAudioOptions',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int optionsAudioProcessingChannels = 10;
        const AdvancedAudioOptions options = AdvancedAudioOptions(
          audioProcessingChannels: optionsAudioProcessingChannels,
        );
        const int sourceType = 10;
        await rtcEngine.setAdvancedAudioOptions(
          options: options,
          sourceType: sourceType,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setAdvancedAudioOptions] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setAVSyncSource',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String channelId = "hello";
        const int uid = 10;
        await rtcEngine.setAVSyncSource(
          channelId: channelId,
          uid: uid,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setAVSyncSource] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableVideoImageSource',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enable = true;
        const VideoMirrorModeType optionsMirrorMode =
            VideoMirrorModeType.videoMirrorModeAuto;
        const String optionsImageUrl = "hello";
        const int optionsFps = 10;
        const ImageTrackOptions options = ImageTrackOptions(
          imageUrl: optionsImageUrl,
          fps: optionsFps,
          mirrorMode: optionsMirrorMode,
        );
        await rtcEngine.enableVideoImageSource(
          enable: enable,
          options: options,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableVideoImageSource] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getCurrentMonotonicTimeInMs',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getCurrentMonotonicTimeInMs();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getCurrentMonotonicTimeInMs] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'enableWirelessAccelerate',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const bool enabled = true;
        await rtcEngine.enableWirelessAccelerate(
          enabled,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[enableWirelessAccelerate] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getNetworkType',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getNetworkType();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getNetworkType] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getAudioDeviceManager',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        rtcEngine.getAudioDeviceManager();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getAudioDeviceManager] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getVideoDeviceManager',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        rtcEngine.getVideoDeviceManager();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getVideoDeviceManager] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getMusicContentCenter',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        rtcEngine.getMusicContentCenter();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getMusicContentCenter] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getMediaEngine',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        rtcEngine.getMediaEngine();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getMediaEngine] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getMediaRecorder',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        rtcEngine.getMediaRecorder();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getMediaRecorder] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getLocalSpatialAudioEngine',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        rtcEngine.getLocalSpatialAudioEngine();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getLocalSpatialAudioEngine] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'sendMetaData',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int metadataUid = 10;
        const int metadataSize = 10;
        Uint8List metadataBuffer = Uint8List.fromList([1, 2, 3, 4, 5]);
        const int metadataTimeStampMs = 10;
        final Metadata metadata = Metadata(
          uid: metadataUid,
          size: metadataSize,
          buffer: metadataBuffer,
          timeStampMs: metadataTimeStampMs,
        );
        const VideoSourceType sourceType =
            VideoSourceType.videoSourceCameraPrimary;
        await rtcEngine.sendMetaData(
          metadata: metadata,
          sourceType: sourceType,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[sendMetaData] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setMaxMetadataSize',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const int size = 10;
        await rtcEngine.setMaxMetadataSize(
          size,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setMaxMetadataSize] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'unregisterAudioEncodedFrameObserver',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        final AudioEncodedFrameObserver observer = AudioEncodedFrameObserver(
          onRecordAudioEncodedFrame: (Uint8List frameBuffer, int length,
              EncodedAudioFrameInfo audioEncodedFrameInfo) {},
          onPlaybackAudioEncodedFrame: (Uint8List frameBuffer, int length,
              EncodedAudioFrameInfo audioEncodedFrameInfo) {},
          onMixedAudioEncodedFrame: (Uint8List frameBuffer, int length,
              EncodedAudioFrameInfo audioEncodedFrameInfo) {},
        );
        rtcEngine.unregisterAudioEncodedFrameObserver(
          observer,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint(
              '[unregisterAudioEncodedFrameObserver] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'setParameters',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        const String parameters = "hello";
        await rtcEngine.setParameters(
          parameters,
        );
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[setParameters] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );

  testWidgets(
    'getNativeHandle',
    (WidgetTester tester) async {
      final irisTester = IrisTester();
      final debugApiEngineIntPtr = irisTester.createDebugApiEngine();
      setMockIrisMethodChannelNativeHandle(debugApiEngineIntPtr);

      String engineAppId = const String.fromEnvironment('TEST_APP_ID',
          defaultValue: '<YOUR_APP_ID>');

      RtcEngine rtcEngine = createAgoraRtcEngine();
      await rtcEngine.initialize(RtcEngineContext(
        appId: engineAppId,
        areaCode: AreaCode.areaCodeGlob.value(),
      ));

      try {
        await rtcEngine.getNativeHandle();
      } catch (e) {
        if (e is! AgoraRtcException) {
          debugPrint('[getNativeHandle] error: ${e.toString()}');
          rethrow;
        }

        if (e.code != -4) {
          // Only not supported error supported.
          rethrow;
        }
      }

      await rtcEngine.release();
    },
  );
}

